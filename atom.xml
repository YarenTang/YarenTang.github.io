<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prefert</title>
  <subtitle>prefer-tyl</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prefer-tyl.site/"/>
  <updated>2017-07-11T15:22:34.658Z</updated>
  <id>http://prefer-tyl.site/</id>
  
  <author>
    <name>Prefert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala 与设计模式（一）：Singleton 单例模式</title>
    <link href="http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/"/>
    <id>http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/</id>
    <published>2017-07-09T08:04:13.000Z</published>
    <updated>2017-07-11T15:22:34.658Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（<code>Singleton Pattern</code>）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<a id="more"></a>
<p>二十年前，软件设计领域的四位大师（GoF，“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson &amp; John Vlissides）通过论著《设计模式：可复用面向对象软件的基础》阐述了设计模式领域的开创性成果。设计模式（<code>Design Pattern</code>）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<p>在 2017 年的今天，虽然一些传统的设计模式仍然适用，但部分设计已经发生改变，甚至被全新的语言特征所取代。<br>本系列文章首先会介绍传统的设计模式在 Java 与 Scala 中的实现，之后会介绍 Scala 可以实现的 “新” 的设计模式。</p>
<p>本文将会简单介绍单例模式在 Java 中的实现方式，以及如何将单例模式应用在 Scala 中，通过比较来阐述单例模式。</p>
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#why-singleton">Why Singleton</a></li>
<li><a href="#结构图">结构图</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#饿汉-基础版">饿汉 —— 基础版</a></li>
<li><a href="#懒汉-基础版">懒汉 —— 基础版</a></li>
<li><a href="#懒汉-双重检查锁版double-checked-locking">懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</a></li>
<li><a href="#静态内部类版">静态内部类版</a></li>
<li><a href="#枚举类模式">枚举类模式</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#obeject"><code>obeject</code></a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。  </p>
</blockquote>
<p>通俗一点单例类就是：全局可以访问的唯一实例。</p>
<h2 id="why-singleton"><a href="#Why-Singleton" class="headerlink" title="Why Singleton"></a>Why Singleton</h2><p>什么时候需要使用单例模式呢？ 如果某个类创建时需要消耗很多资源，即创建出这个类的代价很大时我们就需要使用单例模式。通俗的讲，我们可以将单例对象比作地球，因为很难创建出第二颗这样的星球，这时我们就需要共用地球。</p>
<p>在编写程序的时候，很多操作都会占用大量的资源，如：日志类、配置类、共享资源类等等，我们倡导节能减排，高效利用资源。所以，对于这些操作我们需要一个全局的可访问接口的实现（也可能是懒加载）。</p>
<p>但是我们如何才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但是它并不可以防止我们实例化多个对象。一个更有效的方法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求),并且它可以提供一个访问该实例的方法。这就是单例模式。  </p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://om6vvgjw7.bkt.clouddn.com/Singleton-dp.PNG" alt="singleton"></p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>单例模式应该是 Java 中最出名的设计模式，虽然 Java 语言中包含了静态关键词( <code>static</code>)，但是静态成员与任何对象都不存在直接联系，并且静态成员类不能实现接口。因此，静态方法的概念违背了 <a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">OOP</a> 的前提：所有东西都是对象。  </p>
<p>一般来说在 Java 中单例模式有两种形式：<strong>饿汉模式（eager）</strong>、<strong>懒汉模式(lazy)</strong> 。</p>
<h4 id="饿汉-基础版"><a href="#饿汉-——-基础版" class="headerlink" title="饿汉 —— 基础版"></a>饿汉 —— 基础版</h4><p>对于一个初学者来说，写出的第一个单例类应该是类似下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        HungrySingleton.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码中有了全局访问点，同时单例类也是静态的，看着也比较清晰。</p>
<p>运行测试代码后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HungrySingleton is created</div><div class="line">HungrySingleton is running</div></pre></td></tr></table></figure></p>
<p>从以上结果我们可以发现这种模式有一个缺点: 不是惰性初始化(<code>lazy initialization</code>)，即单例会在 JVM 加载单例类后一开始就被初始化，如果此时单例类在系统中还扮演其他角色，不管是否用到都会初始化这个单例变量。因为这种写法下单例会被立即初始化，所以我们称这种单例为 <strong>饿汉 (eager)</strong> 。</p>
<h4 id="懒汉-基础版"><a href="#懒汉-——-基础版" class="headerlink" title="懒汉 —— 基础版"></a>懒汉 —— 基础版</h4><p>为了解决上述的问题，我们就需要引入延迟加载。比较容易想到的做法是：在获取实例的时候判断实例是否存在，不存在则创建。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonOne</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonOne instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingletonOne();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LazySingletonOne.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LazySingletonOne is running</div></pre></td></tr></table></figure></p>
<p>可见这种形式在这样的环境下确实已经能满足我们的需求。但是在多线程环境下，缺点就非常明显：会出现创建出多个实例的情况（由于篇幅限制，测试代码见文末源码）。这时候通常的做法是在方法上加一个同步锁<br>（<code>synchronized</code>），但是仅仅这样就够了吗？</p>
<h4 id="懒汉-双重检查锁版double-checked-locking"><a href="#懒汉-——-双重检查锁版-Double-checked-locking" class="headerlink" title="懒汉 —— 双重检查锁版(Double-checked locking)"></a>懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</h4><p>在 <code>getInstance</code> 整个方法外加同步锁（<code>synchronized</code>），每次访会还是会造成很大的性能开销。我们就只能在方法的临界区做一些文章，<code>Double-checked locking</code> 应声而至。<br>我们先看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingletonTwo instance;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">// 第一次检查</span></div><div class="line">          <span class="keyword">synchronized</span> (LazySingletonTwo.class) &#123;</div><div class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">// 第二次检查</span></div><div class="line">                  instance = <span class="keyword">new</span> LazySingletonTwo();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance ;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>为了避开多次同步锁的开销，我们先判断单例实体是否存在再进行同步锁操作。这样虽然已经能应对大部分的问题，但是依然存在一个问题：其他线程可能会 <code>read</code> 初始化到一半的 <code>instance</code>。只有将 <code>instance</code> 设置为 <code>volatile</code> ，才能保证每次的 <code>write</code> 操作优先于 <code>read</code> 操作，即能确保每次引用到都是最新状态。<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl" target="_blank" rel="external">了解更多</a><br>只用将代码稍加改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// private static LazySingletonTwo instance;           ----old</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingletonTwo instance;  ----<span class="keyword">new</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong> ：我们至少要创建一个 <code>private</code> 构造器，否则编译器默认将为我们生成一个 <code>friendly</code> 的构造器，而非 <code>private</code>；其次，<code>instance</code> 成员变量和 <code>getInstance()</code> 方法必须是 <code>static</code> 的；如果单例类实现了 <code>java.io.Serializable</code> 接口，就可能被反序列化，从而产生新的实例。</p>
<h4 id="静态内部类版"><a href="#静态内部类版" class="headerlink" title="静态内部类版"></a>静态内部类版</h4><p>除了以上几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedSingleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明为 final 能防止其在派生类中被 clone</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticNestedSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">       System.out.println((<span class="string">"StaticNestedSingleton is created"</span>));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticNestedSingleton <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> NestedClass.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在第一次被引用时被加载</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticNestedSingleton instance = <span class="keyword">new</span> StaticNestedSingleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，我们将单例类设置为 <code>final</code> 类型，这样能够禁止克隆的发生。同样静态内部类只有在第一次被引用时才加载，即随着类的加载而产生（而不是随着对象的产生）。</p>
<h4 id="枚举类模式"><a href="#枚举类模式" class="headerlink" title="枚举类模式"></a>枚举类模式</h4><p>上面的几种使我们常见到的单例类形式，可能有的同学会抱怨道：有没有简短一点的？<br>当然我们还可以使用 Java 中的枚举类实现单例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] preference =</div><div class="line">            &#123; <span class="string">"intresting"</span>,<span class="string">"nice"</span>,<span class="string">"just so so"</span> &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Arrays.toString(preference));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 《Effictive Java》 中所推荐的单例模式在 Java 中的最佳实现方式，同时也是 Stack Overflow 中 <a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="external">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a> 最高票回答。</p>
<p>注意：<code>Enum</code> 与 <code>enum</code> 是不同的。后者只是 Java 1.5 后增加的一个语法糖，不是新的类型。 我们可以反编译 <code>EnumSingleton.class</code> 查看一下内部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ javap EnumSingleton.class</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span>&gt;</span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton.Java.EnumSingleton INSTANCE;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.EnumSingleton[]values();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.<span class="function">EnumSingleton <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">static</span> &#123;&#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>简单总结一下，选用 <code>enum</code> 原因如下：</p>
<ul>
<li><code>enum</code> 防止反序列化重新创建新的对象。</li>
<li>类的修饰 <code>abstract</code>，所以没法实例化，反射也无能为力。</li>
<li>关于线程安全的保证，其实是通过类加载机制来保证的，我们看看 <code>INSTANCE</code> 的实例化时机，是在 <code>static</code> 块中，JVM加载类的过程显然是线程安全的。</li>
</ul>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中并没有 <code>static</code> 关键字，你不用纠结太多，我们用 <code>object</code> 便能实现单例，再也不用为你的选择困难症烦恼！</p>
<h4 id="obeject"><a href="#obeject" class="headerlink" title="obeject"></a><code>obeject</code></h4><p><code>object</code> 在 Scala 中被称作 “伴生对象” (<code>companion object</code>)。因其可与类同名存在而得名，我们可以在 <code>object</code> 中写一些常量或者工具函数等，比较典型的一点是 Scala 类的 <code>apply</code> 函数也写于 <code>obejct</code> 中（将在本系列工厂模式中详细提到，敬请期待）。看到 <code>object</code> 的介绍，大家就应该能从它身上闻到强烈的单例味。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singleton2Scala</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(l: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = l.sum</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="type">Singleton2Scala</span>.sum(<span class="type">List</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来是不是比 Java 优雅多了！  </p>
<p>你问有没有多线程问题？是否是惰性初始化？这些都不用你来处理。</p>
<p>Scala 被编译后生成 <code>&#39;Singleton2Scala$.class&#39;</code> 和  <code>Singleton2Scala.class</code>，我们可以对其进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ javap  &apos;Singleton2Scala$.class&apos;</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala$ &#123;</div><div class="line">  public static Singleton.Scala.Singleton2Scala$ MODULE$;</div><div class="line">  public static &#123;&#125;;</div><div class="line">  public int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">$ javap  Singleton2Scala.class</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala &#123;</div><div class="line">  public static int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上方代码我们能看到，所有的方法前都带上了 <code>static</code> 关键字。</p>
<p>在实际项目开发的时候，我们还可以继承其他 类 与 特质。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">xxClass</span> <span class="keyword">with</span> <span class="title">xxtrait</span></span>&#123;</div><div class="line">  println(<span class="string">"Registry initialization block called."</span>)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> lazyXX  = ???</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users: scala.collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>] =  scala.collection.mutable.<span class="type">HashMap</span>.empty</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addUser</span></span>(id: <span class="type">String</span>, name: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.put(id, name) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>(id: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.remove(id) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUserRegistered</span></span>(id: <span class="type">String</span>): <span class="type">Boolean</span> = users.contains(id)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAllUserNames</span></span>(): <span class="type">List</span>[<span class="type">String</span>] = users.map(_._2).toList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比 <code>static class</code> 更易于理解  </li>
<li>语法简洁</li>
<li>按需初始化(<code>lazy initialization</code>)</li>
<li>线程安全(Scala 中不用考虑 <code>double-checked locking</code>)  </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>缺乏对初始化行为的控制  </li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是对 Scala 和 Java 是实现单例模式的一个简单比较：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Java</th>
<th style="text-align:center">Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td><code>static</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>多线程</td>
<td><code>synchronized</code> +  <code>volatile</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>延迟加载</td>
<td><code>enum</code> 、 <code>double-checked locking</code></td>
<td style="text-align:center"><code>object</code> + <code>lazy</code></td>
</tr>
</tbody>
</table>
<p>人们对单例模式的看法褒贬不一，甚至被称为是 <code>anti-pattern</code> (反面模式）。如果你是一名 Java 开发者，可能 Spring 框架中 <code>Dependency Injection</code> 是你的更优先的选择。但是单例模式你不能否认的是单例模式在 Android SDK 中得到了广泛的应用。在 Scala 中，伴生对象出现的频率更是非常之高。当你面对的业务场景需要用到单例模式的时候，请务必注意 <strong>多线程</strong> 与 <strong>性能开销</strong> 的问题。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples" target="_blank" rel="external">源码链接</a><br>如有说错的地方还请指出，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（&lt;code&gt;Singleton Pattern&lt;/code&gt;）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web前端模块化发展历程</title>
    <link href="http://prefer-tyl.site/2017/06/27/front-page-modular-history/"/>
    <id>http://prefer-tyl.site/2017/06/27/front-page-modular-history/</id>
    <published>2017-06-27T12:00:13.000Z</published>
    <updated>2017-06-27T15:24:03.892Z</updated>
    
    <content type="html"><![CDATA[<p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是模块化">1. 什么是模块化</a></li>
<li><a href="#2-为什么要模块化">2. 为什么要模块化</a></li>
<li><a href="#3-web-前端的模块化的历史浪潮">3. Web 前端的模块化的历史浪潮</a><ul>
<li><a href="#31-发展历史">3.1 发展历史</a></li>
<li><a href="#311-函数封装">3.1.1 函数封装</a></li>
<li><a href="#312-对象">3.1.2 对象</a></li>
<li><a href="#313-立即执行函数immediately-invoked-function-expression">3.1.3 立即执行函数(immediately-invoked function expression )</a></li>
<li><a href="#314-script-loader">3.1.4 Script Loader</a><ul>
<li><a href="#labjs">LABjs</a></li>
<li><a href="#commonjs">CommonJS</a></li>
<li><a href="#双塔奇兵-amdcmd">双塔奇兵 AMD/CMD</a></li>
</ul>
</li>
<li><a href="#32-解决方案">3.2 解决方案</a><ul>
<li><a href="#webpack">Webpack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-未来的模块化">4. 未来的模块化</a><ul>
<li><a href="#webassembly-是什么">WebAssembly 是什么</a></li>
<li><a href="#webassembly-的目标">WebAssembly 的目标</a></li>
<li><a href="#webassembly-的核心">WebAssembly 的核心</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1. 什么是模块化"></a>1. 什么是模块化</h2><p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
<h2 id="2-为什么要模块化"><a href="#2-为什么要模块化" class="headerlink" title="2. 为什么要模块化"></a>2. 为什么要模块化</h2><p>随着互联网的飞速发展，新的前端框架与技术不断涌现。这些框架在带给开发者便利的同时，也带去了维护困难的隐患———项目逻辑的复杂化与代码库膨胀。我们可以将原因概括为以下三点：  </p>
<ul>
<li>Web 网站正在转变为 Web 应用  </li>
<li>网站规模越大，代码也越来越复杂   </li>
<li>高度解耦的 JS 文件被大家所需求<br>前端开发领域(<code>JavaScript</code>、<code>CSS</code>、<code>Template</code>)并没有为开发者们提供以一种简洁、有条理地的方式来管理模块的方法。为了解决以上问题，我们必须进行合理的模块化管理。  </li>
</ul>
<p>熟悉 Java 语言的同学都知道，在 Java 中有一个重要的概念——<code>package</code> (包)，我们会将相同逻辑的代码放到一个 <code>package</code> 下，在需要的地方 <code>import</code> (引入)即可。    </p>
<p>前端是否有类似 <code>package</code> 的概念呢？  </p>
<h2 id="3-web-前端的模块化的历史浪潮"><a href="#3-Web-前端的模块化的历史浪潮" class="headerlink" title="3. Web 前端的模块化的历史浪潮"></a>3. Web 前端的模块化的历史浪潮</h2><h3 id="31-发展历史"><a href="#3-1-发展历史" class="headerlink" title="3.1 发展历史"></a>3.1 发展历史</h3><p>由于 JavaScript 这门语言设计用时非常短，所以很多方面都没有考虑周全。好在它的生态圈非常强大，广大开发者为了更好的使用它，对它不断优化。</p>
<h3 id="311-函数封装"><a href="#3-1-1-函数封装" class="headerlink" title="3.1.1 函数封装"></a>3.1.1 函数封装</h3><p>  最早期的时候，我们在一个文件里编写相关函数，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要的时候加载文件并调用相关函数即可。<br><strong>缺点：Global 被污染，代码中很容易出现命名冲突。</strong>  </p>
<h3 id="312-对象"><a href="#3-1-2-对象" class="headerlink" title="3.1.2 对象"></a>3.1.2 对象</h3><p>为了解决上面的问题，我们又将一个个文件划分为一个个对象，这样在加载的时候就不用加载很多文件。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MYAPP = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">MYAPP.foo(); <span class="comment">//需要时执行</span></div></pre></td></tr></table></figure></p>
<p>这样虽然能减少 Global 上的变量数目，避免变量污染。但是<strong>本质是对象，外部对象可以对其他对象进行修改，很不安全</strong>。  </p>
<h3 id="313-立即执行函数immediately-invoked-function-expression"><a href="#3-1-3-立即执行函数-immediately-invoked-function-expression" class="headerlink" title="3.1.3 立即执行函数(immediately-invoked function expression )"></a>3.1.3 立即执行函数(immediately-invoked function expression )</h3><blockquote>
<p>IIFE (立即调用函数表达式) 是一个 JavaScript 函数 ，它会在定义时立即执行.<br>也有人将 IIFE 称为匿名闭包.</p>
</blockquote>
<p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _private = <span class="string">"safe now"</span>;</div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_private)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: foo</div><div class="line">    &#125;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">Module.foo();</div><div class="line">Module._private; <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>我们可以调用定义的方法，但是不能调用定义的属性。这样的模式使得变量冲突降到最低，并且能够控制暴露的方法(类似于接口）。这便是现代模块实现的基石！  </p>
<h3 id="314-script-loader"><a href="#3-1-4-Script-Loader" class="headerlink" title="3.1.4 Script Loader"></a>3.1.4 Script Loader</h3><p>最原始的 JS 加载方法就是在 Html 头文件中通过 Script 标签直接引入，类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"http://remote.tld/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"local/plugin1.jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"local/plugin2.jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"local/init.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script&gt;</div><div class="line">	initMyPage();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>初学者可能会有疑问，全都写在一个文件中看着不是挺方便的吗？<br>首先以上列举的可能只是实际项目中的一小部分，其次不要忽视 <code>&lt;script&gt;</code> 的一个特点：<code>并行加载，顺序执行</code>，这要求开发者需要按照严格的读取顺序，并且很有可能会阻塞阻止文档渲染(<code>async</code> 新特性在 HTML5 中才提出)。文件少的时候写起来会很方便，一旦项目变复杂缺点就会暴露无疑：<strong>难以维护，依赖模糊，请求过多</strong> 。  </p>
<h4 id="labjs"><a href="#LABjs" class="headerlink" title="LABjs"></a>LABjs</h4><p>为了解决依赖模糊，我们迫切需要一个加载器（<code>Loader</code>）最先出现在开发者视野中的 <code>Loader</code> 应该是 <a href="https://github.com/getify/LABjs]" target="_blank" rel="external"><code>LABjs</code></a>(2009)（ HTML5 发布才有了 <code>async</code> 特性）</p>
<blockquote>
<p>LABjs 的核心是 LAB（Loading and Blocking）：Loading 指异步并行加载，Blocking 是指同步等待执行。  </p>
</blockquote>
<p>通过使用 LABjs ,上方代码就可以变成这样：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"LAB.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script&gt;</div><div class="line">  $LAB</div><div class="line">  .script(<span class="string">"http://remote.tld/jquery.js"</span>).wait()<span class="comment">//`.wait` 表示加载后立即运行</span></div><div class="line">  .script(<span class="string">"/local/plugin1.jquery.js"</span>)</div><div class="line">  .script(<span class="string">"/local/plugin2.jquery.js"</span>).wait()</div><div class="line">  .script(<span class="string">"/local/init.js"</span>).wait(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      initMyPage();</div><div class="line">  &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>当然同一时期风靡的还有类库模块化框架 <a href="https://yuilibrary.com/" target="_blank" rel="external">YUI</a>，大家可自行查阅。</p>
<h4 id="commonjs"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>在开发者们拼命为浏览器兼容等问题绞尽脑汁的时候，CommonJS 横空出世！<br>服务器端的 <code>Node.js</code> 遵循 <a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">CommonJS规范</a>，该规范的核心思想是允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</div><div class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">module</span>.exports = someValue;</div></pre></td></tr></table></figure>
<p>这是 JavaScript 第一次真正意义上跳出浏览器，被人们尊称为模块化的第一座里程碑（<code>MODULES/1.0</code>）。给开发者们带来了以下便捷之处：</p>
<p>优点:  </p>
<ul>
<li>服务器端模块便于重用  </li>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">NPM</a> 中已经有将近20万个可以使用模块包  </li>
<li>简单并容易使用  </li>
</ul>
<p>缺点：  </p>
<ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的  </li>
<li>不能非阻塞的并行加载多个模块  </li>
</ul>
<p>实现:  </p>
<ul>
<li>NodeJS</li>
</ul>
<h4 id="双塔奇兵-amdcmd"><a href="#双塔奇兵-AMD-CMD" class="headerlink" title="双塔奇兵 AMD/CMD"></a>双塔奇兵 AMD/CMD</h4><table>
<thead>
<tr>
<th>-</th>
<th style="text-align:left">AMD</th>
<th style="text-align:left">CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念</td>
<td style="text-align:left"><a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="external">Asynchronous Module Definition</a> 规范其实只有一个主要接口 <code>define(id?, dependencies?, factory)</code>，它要在声明模块的时候指定所有的依赖 <code>dependencies</code>，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</td>
<td style="text-align:left"><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="external">Common Module Definition</a> 规范和 AMD 很相似，尽量保持简单，并与 <code>CommonJS</code> 和 <code>Node.js</code> 的 <code>Modules 规范</code> 保持了很大的兼容性。</td>
</tr>
<tr>
<td>优点</td>
<td style="text-align:left">1. 适合在浏览器环境中异步加载模块<br> 2. 可以并行加载多个模块</td>
<td style="text-align:left">1. 依赖就近，延迟执行 <br> 2. 可以很容易在 Node.js 中运行</td>
</tr>
<tr>
<td>缺点</td>
<td style="text-align:left">1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅<br> 2. 不符合通用的模块化思维方式，是一种妥协的实现</td>
<td style="text-align:left">依赖 SPM 打包，模块的加载逻辑偏重</td>
</tr>
<tr>
<td>实现</td>
<td style="text-align:left"><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a></td>
<td style="text-align:left"><a href="http://seajs.org/" target="_blank" rel="external">SeaJS</a></td>
</tr>
</tbody>
</table>
<p>两者最明显的区别可以从以下代码中查看：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</span></div><div class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    a.doSomething();    <span class="comment">// 依赖前置，提前执行</span></div><div class="line">    b.doSomething();</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//CMD 推崇依赖就近，只有在用到某个模块的时候再去require  </span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"a"</span>);</div><div class="line">    a.doSomething();</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"b"</span>);</div><div class="line">    b.doSomething();    <span class="comment">// 依赖就近，延迟执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>概括而言 Commonjs 用在服务器端，加载是同步的。<br>AMD, CMD 用在浏览器端，加载是异步的。  </p>
<p><code>CommonJS</code> (规划并标准化、致力于设计 JavaScript API)的诞生开启了 “JavaScript 模块化” 的时代。<code>CommonJS</code> 的模块提案为在服务器端的 JavaScript 模块化做出了很大的贡献，但是在浏览器下的 JavaScript 模块应用很有限。随之而来又诞生了其它前端领域的模块化方案，像 requireJS、SeaJS 等，然而这些模块化方案并不是十分适用 ，并没有从根本上解决模块化的问题。</p>
<h3 id="32-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h3><p>前面已经为大家回顾了 JavaScript 的模块化发展历史，然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。如果他们都可以视作模块，并且都可以通过 <code>require</code> 的方式来加载，将带来优雅的开发体验，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>那么如何做到让 <code>require</code> 能加载各种资源呢？  </p>
<h4 id="webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack</a> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
</blockquote>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/what-is-webpack.png" alt="webpack">  </p>
<p>Webpack 的优点可以概括为以下几点：  </p>
<ul>
<li><p><strong>代码拆分</strong><br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。  </p>
</li>
<li><p><strong>Loader</strong><br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。  </p>
</li>
<li><p><strong>智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。  </p>
</li>
<li><p><strong>插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。  </p>
</li>
<li><p><strong>快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。    </p>
</li>
</ul>
<p>当然，光有 <code>Webpack</code> 是不够的，目前大家比较推崇的最佳拍档为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">包管理工具</th>
<th style="text-align:center">模块化构建工具</th>
<th style="text-align:center">模块化规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">npm</td>
<td style="text-align:center">Webpack</td>
<td style="text-align:center">ES6模块</td>
</tr>
</tbody>
</table>
<p>当然，目前比较有许多 “自带模块化buff” 的前端框架（组件化）：<code>Vue</code> 、 <code>React</code>等，它们都有以下特点:  </p>
<ul>
<li>使用 Virtual DOM  </li>
<li>提供了响应式（ Reactive ）和组件化（ Composable ）的视图组件。  </li>
<li>保持注意力集中在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。    </li>
</ul>
<p>在 <code>Vue</code> 中，一个组件文件(<code>.Vue</code>)中，拥有<code>&lt;template&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;style&gt;</code>三个部分。每个组件中管理自己的样式、逻辑，这样在大型项目开发与维护时都起到了非常便捷的作用。  </p>
<h2 id="4-未来的模块化"><a href="#4-未来的模块化" class="headerlink" title="4. 未来的模块化"></a>4. 未来的模块化</h2><p>说到模块化未来的发展，值得一提的便是 <a href="http://webassembly.org/" target="_blank" rel="external">WebAssembly</a>。大家都知道 <code>JavaScript</code> 是一种解释性脚本语言，导致其运行时消耗大量的性能做为代价，这也是 <code>JavaScript</code> 的瓶颈之一。<code>WebAssembly</code> 旨在解决这个问题。  </p>
<h3 id="webassembly-是什么"><a href="#WebAssembly-是什么" class="headerlink" title="WebAssembly 是什么"></a>WebAssembly 是什么</h3><blockquote>
<p> Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.<br>定义一个可移植，体积紧凑，加速迅捷的二进制格式为编译目标，而此二进制格式文件将可以在各种平台（包括移动设备和物联网设备）上被编译，然后发挥通用的性能以原生应用的速度运行。</p>
</blockquote>
<h3 id="webassembly-的目标"><a href="#WebAssembly-的目标" class="headerlink" title="WebAssembly 的目标"></a>WebAssembly 的目标</h3><p>某乎上广传 “谷歌、苹果、谋智、微软一起再一次发明了 Silverlight ”。可以看出，大家对 <code>WebAssembly</code> 充满了信心与期待。  </p>
<p>作为 <a href="https://www.w3.org/community/webassembly" target="_blank" rel="external">W3C WebAssembly Community Group</a> 中的一项开放标准，WebAssembly 是为下列目标而生的：</p>
<ul>
<li>快速、高效、可移植——通过利用常见的硬件能力，WebAssembly 代码在不同平台上能够以接近本地速度运行。  </li>
<li>可读、可调试—— WebAssembly 是一门低阶语言，但是它有确实有一种人类可读的文本格式（其标准即将得到最终版本），这允许通过手工来写代码，看代码以及调试代码。   </li>
<li>保持安全—— WebAssembly 被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略。  </li>
<li>不破坏网络—— WebAssembly 的设计原则是与其他网络技术和谐共处并保持向后兼容。  </li>
</ul>
<h3 id="webassembly-的核心"><a href="#WebAssembly-的核心" class="headerlink" title="WebAssembly 的核心"></a>WebAssembly 的核心</h3><p>那么 WebAssembly 是如何在浏览器中运行的呢？我们可以看一下它的几个关键的概念：  </p>
<ul>
<li><strong>模块</strong> : 表示一个已经被浏览器编译为可执行机器码的 WebAssembly 二进制代码。一个模块是无状态的并且像一个二进制大对象（Blob）一样能够被缓存到 IndexedDB 中或者在 windows 和 workers 之间进行共享（通过 <code>postMessage()</code> 函数）。一个模块能够像一个 ES2015的模块一样声明导入和导出。   </li>
<li><strong>内存</strong> : 一个可变大小的 ArrayBuffer 。它包含了一个连续的字节数组并且 WebAssembly 的低级内存存取指令可对其进行读写操作。  </li>
<li><strong>表格</strong> : 一个可变大小的包含引用类型（比如，函数）的带类型数组。它包含了不能作为原始字节存储在内存中的引用（为了安全和可移植性的原因）。  </li>
<li><strong>实例</strong> : 一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。一个实例就像一个已经被加载到一个拥有一组特定导入的特定的全局变量的 ES2015模块。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面重构应该遵循的基本原则和规范</title>
    <link href="http://prefer-tyl.site/2017/04/30/restructure-web-page/"/>
    <id>http://prefer-tyl.site/2017/04/30/restructure-web-page/</id>
    <published>2017-04-30T00:30:13.000Z</published>
    <updated>2017-06-27T13:06:56.455Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是页面重构">1. 什么是页面重构？</a></li>
<li><a href="#2-基本原则和规范">2. 基本原则和规范</a><ul>
<li><a href="#21-常用规范">2.1 常用规范</a></li>
<li><a href="#22-语义化-seo">2.2 语义化 &amp;&amp; SEO</a><ul>
<li><a href="#221-什么是语义化">2.2.1 什么是语义化</a></li>
<li><a href="#222-为什么要让页面语义化">2.2.2 为什么要让页面语义化</a></li>
<li><a href="#223-html-语义化">2.2.3 HTML 语义化</a></li>
<li><a href="#224-css-命名语义化">2.2.4 CSS 命名语义化</a></li>
</ul>
</li>
<li><a href="#23-样式抽离-组件复用">2.3 样式抽离 &amp;&amp; 组件复用</a></li>
</ul>
</li>
<li><a href="#3-总结">3. 总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是页面重构"><a href="#1-什么是页面重构？" class="headerlink" title="1. 什么是页面重构？"></a>1. 什么是页面重构？</h2><p>简单来说，页面重构就是：<strong>将设计稿转换成 WEB 页面</strong>。  </p>
<p>那我们重构时该注意哪些东西呢？  </p>
<h2 id="2-基本原则和规范"><a href="#2-基本原则和规范" class="headerlink" title="2. 基本原则和规范"></a>2. 基本原则和规范</h2><p>在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护。  </p>
<h3 id="21-常用规范"><a href="#2-1-常用规范" class="headerlink" title="2.1 常用规范"></a>2.1 常用规范</h3><p>与使用其他语言开发工程一样，我们需要有着统一的规范，最常见就是 <strong>编码风格</strong>，比如：  </p>
<ol>
<li><p><strong>空格</strong>  </p>
<ul>
<li>等号前后空格、运算符前后使用空格分隔   </li>
<li>在逗号和冒号后添加空格  </li>
</ul>
</li>
<li><p><strong>空行</strong>  </p>
<ul>
<li>为每个逻辑功能块添加空行，这样更易于阅读    </li>
<li>将左花括号与选择器放在同一行  </li>
<li>将右花括号独立放在一行，并以分号作为结束符号  </li>
</ul>
</li>
<li><p><strong>缩进</strong>  </p>
<ul>
<li>缩进使用两个空格(不要使用制表符)    </li>
</ul>
</li>
</ol>
<p>其次是 <strong>命名</strong>，我们建议对 HTML 元素名称，属性，属性值，CSS 选择器，属性和属性值（字符串除外）使用小写字母命名，并且使用 <code>-</code> 进行分隔，举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">id</span>=<span class="string">"href-index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span>  </div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#E5E5E5</span>;  </div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#e5e5e5</span>;</div></pre></td></tr></table></figure>
<p>另外还有书写顺序，比较常见的 CSS 样式书写顺序如下：  </p>
<ol>
<li>位置属性(<code>position</code>, <code>top</code>, <code>right</code>, <code>z-index</code>, <code>display</code>, <code>float</code> 等)  </li>
<li>大小(<code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>)  </li>
<li>文字系列( <code>font</code>, <code>line-height</code>, <code>letter-spacing</code>, <code>color</code>, <code>text-align</code> 等)  </li>
<li>背景(<code>background</code>, <code>border</code> 等)  </li>
<li>其他(<code>animation</code>, <code>transition</code> 等)  </li>
</ol>
<p>以上仅列举了部分规范，更多请参考 <a href="http://eslint.cn/docs/rules/" target="_blank" rel="external">ESLint</a>  </p>
<h3 id="22-语义化-ampamp-seo"><a href="#2-2-语义化-amp-amp-SEO" class="headerlink" title="2.2 语义化 &amp;&amp; SEO"></a>2.2 语义化 &amp;&amp; SEO</h3><h4 id="221-什么是语义化"><a href="#2-2-1-什么是语义化" class="headerlink" title="2.2.1 什么是语义化"></a>2.2.1 什么是语义化</h4><blockquote>
<p>语义化是指使用恰当语义的 HTML 标签、class 类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。  </p>
</blockquote>
<h4 id="222-为什么要让页面语义化"><a href="#2-2-2-为什么要让页面语义化" class="headerlink" title="2.2.2 为什么要让页面语义化"></a>2.2.2 为什么要让页面语义化</h4><p>语义化的好处 ：  </p>
<ul>
<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构  </li>
<li><strong>有利于</strong> <a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="external">SEO</a> ( Search Engine Optimization——搜索引擎优化)：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重    </li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以特殊的方式来渲染网页     </li>
<li>便于团队开发和维护，可以减少很多差异化，减少成员间沟通成本，方便开发和后期维护，利于实现模块化开发</li>
</ul>
<h4 id="223-html-语义化"><a href="#2-2-3-HTML-语义化" class="headerlink" title="2.2.3 HTML 语义化"></a>2.2.3 HTML 语义化</h4><p>假设我们要开发一个页面，在 HTML5 出现之前，页面架构很有可能是下面这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%89%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的架构缺点比较明显：  </p>
<ul>
<li>需要用到很多 <code>div</code> 标签,但实际上 <code>div</code> 标签并没有语义，这不利于爬虫对页面内容进行抓取  </li>
<li>文档结构不明确。也许你认为有 <code>id</code> 就足够了，但是后面会发现在一大堆 <code>&lt;div&gt;</code> 中找出这些 <code>id</code> 并不高效</li>
</ul>
<p>于是，在 HTML5 中，页面架构变成了这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%90%8E%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的结构看起来就清晰多了，我们可以直接从标签名称得知它的作用。  </p>
<p>当然，我们也不是说将所有的 <code>div</code> 全部替换为对应的语义化标签(比如考虑到网页兼容问题)，具体情况应具体分析。  </p>
<p>根据应用场景，一些常用的标签元素有：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">主要语义</th>
<th style="text-align:left">元素名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">本身无语义，组合其他 HTML 元素，常用于页面布局</td>
<td style="text-align:left"><code>div</code></td>
</tr>
<tr>
<td style="text-align:left">设置文本，填充段落</td>
<td style="text-align:left"><code>h1~h6</code>, <code>p</code>, <code>span</code>, <code>strong</code>, <code>em</code>…</td>
</tr>
<tr>
<td style="text-align:left">表现列表</td>
<td style="text-align:left"><code>ul</code>, <code>li</code>, <code>ol</code>, <code>dl</code>, <code>dt</code>, <code>dd</code></td>
</tr>
<tr>
<td style="text-align:left">表单相关</td>
<td style="text-align:left"><code>form</code>,<code>input</code>,<code>select</code>,<code>button</code></td>
</tr>
<tr>
<td style="text-align:left">表格相关</td>
<td style="text-align:left"><code>table</code>,<code>thead</code>,<code>tbody</code>,<code>tfoot</code>,<code>th</code>,<code>tr</code>,<code>td</code></td>
</tr>
<tr>
<td style="text-align:left">图像显示</td>
<td style="text-align:left"><code>img</code>, <code>canvas</code></td>
</tr>
<tr>
<td style="text-align:left">打开链接，发送邮件，段落跳转</td>
<td style="text-align:left"><code>a</code></td>
</tr>
</tbody>
</table>
<h4 id="224-css-命名语义化"><a href="#2-2-4-CSS-命名语义化" class="headerlink" title="2.2.4 CSS 命名语义化"></a>2.2.4 CSS 命名语义化</h4><p>CSS 命名的语义就是 <code>class</code> 和 <code>id</code> 命名的语义。<br><code>class</code> 属性作为 HTML 与 CSS 衔接的纽带，其本意是用来描述元素内容的。指用易于理解的名称对 HTML 标签附加的 <code>class</code> 或 <code>id</code> 命名。如果说 HTML 语义化标签是给机器看的，那么 CSS 命名的语义化就是给人看的。良好的 CSS 命名方式减少沟通调试成本，易于理解。  </p>
<p>CSS 命名首先要满足 W3C 的命名规范和团队的命名规范。其次是高效和可重用性。  </p>
<p>就好像 <code>.main</code> / <code>.sidebar</code> 会比 <code>.left_content</code> / <code>.right_content</code> 的 class 命名灵活性更好。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 以表现为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"lr margin10"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 以信息为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"user-info"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="23-样式抽离-ampamp-组件复用"><a href="#2-3-样式抽离-amp-amp-组件复用" class="headerlink" title="2.3 样式抽离 &amp;&amp; 组件复用"></a>2.3 样式抽离 &amp;&amp; 组件复用</h3><p>在后端开发中，我们常常将一些公共的字符串、函数等抽离出来，在需要的地方便可方便的调用。前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>在 前端模块化 的历史演变中，曾有一段时期我们会这样构造组件：  </p>
<ul>
<li><strong>base</strong> 提供最底层的、功能和粒度最小的的通用类样式，可以被所有页面引用  </li>
<li><strong>common</strong> 出现频率高，功能相对独立的组件，如 <code>Button</code>、<code>Dialog</code>、<code>Tooltip</code> 等  </li>
<li><strong>page</strong> 各页面独有的样式，实际中可划分为 <code>page-index.css</code> 、<code>page-dashboard.css</code> 等  </li>
</ul>
<p>但是随着工程的逐渐壮大，使用及维护起来还是比较困难。我们期望 组件/样式 有着 “按需引入，即插即用” 的特性。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>为了实现这样的引入方式，我们需要使用 Loader 。  </p>
<p>Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 <code>require</code> 来加载任何类型的模块或文件。  </p>
<p>如果我们要在 <code>index.html</code> 引入一个 CSS 文件 <code>style.css</code>，首页将 <code>style.css</code> 也看成是一个模块，然后用 <code>css-loader</code> 来读取它，再用 <code>style-loader</code> 把它插入到页面中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* style.css */</div><div class="line">body &#123; background: yellow; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"!style-loader!css-loader!./style.css"</span>) <span class="comment">// 载入 style.css</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>安装 loader :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://vuefe.cn/v2/guide/index.html" target="_blank" rel="external">Vue.js</a> 中，我们可以将 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 都写于一个 <code>.vue</code> 格式的文件中，一个文件便对应一个组件，并且可以在其他组件中很方便的引入。  </p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>当然，除了以上几点，我们需要遵循的原则和规范还很多。总的来说，页面重构时，在规范编码的基础上我们首先考虑的因素便是语义化：HTML 标签语义化、CSS 命名语义化等等。语义化的最终目的就是使得人与机器对页面识别度更高。其次，为了方便协作与后期维护，我们应该考虑组件复用、样式抽离，或者说模块化等。原则和规范并不总是一成不变的，随着前端技术的快速发展，高效、便于协作与维护的方式便是最佳原则与规范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

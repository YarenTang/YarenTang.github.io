<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prefert</title>
  <subtitle>prefer-tyl</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prefer-tyl.site/"/>
  <updated>2017-06-27T12:10:48.264Z</updated>
  <id>http://prefer-tyl.site/</id>
  
  <author>
    <name>Prefert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端模块化的历史</title>
    <link href="http://prefer-tyl.site/2017/06/26/front-page-modular-history/"/>
    <id>http://prefer-tyl.site/2017/06/26/front-page-modular-history/</id>
    <published>2017-06-25T16:16:58.327Z</published>
    <updated>2017-06-27T12:10:48.264Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]  </p>
<h2 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1. 什么是模块化"></a>1. 什么是模块化</h2><p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
<h2 id="2-为什么要模块化"><a href="#2-为什么要模块化" class="headerlink" title="2. 为什么要模块化"></a>2. 为什么要模块化</h2><p>随着互联网的飞速发展，新的前端框架与技术不断涌现。这些框架在带给开发者便利的同时，也带去了维护困难的隐患———项目逻辑的复杂化与代码库膨胀。我们可以将原因概括为以下三点：  </p>
<ul>
<li>Web 网站正在转变为 Web 应用  </li>
<li>网站规模越大，代码也越来越复杂   </li>
<li>高度解耦的 JS 文件被大家所需求<br>前端开发领域(<code>JavaScript</code>、<code>CSS</code>、<code>Template</code>)并没有为开发者们提供以一种简洁、有条理地的方式来管理模块的方法。为了解决以上问题，我们必须进行合理的模块化管理。  </li>
</ul>
<p>熟悉 Java 语言的同学都知道，在 Java 中有一个重要的概念——<code>package</code> (包)，我们会将相同逻辑的代码放到一个 <code>package</code> 下，在需要的地方 <code>import</code> (引入)即可。    </p>
<p>前端是否有类似 <code>package</code> 的概念呢？  </p>
<h2 id="3-web-前端的模块化如何发展"><a href="#3-Web-前端的模块化如何发展" class="headerlink" title="3. Web 前端的模块化如何发展"></a>3. Web 前端的模块化如何发展</h2><h3 id="31-发展历史"><a href="#3-1-发展历史" class="headerlink" title="3.1 发展历史"></a>3.1 发展历史</h3><p>由于 JavaScript 这门语言设计用时非常短，所以很多方面都没有考虑周全。好在它的生态圈非常强大，广大开发者为了更好的使用它，对它不断优化。</p>
<h3 id="311-函数封装"><a href="#3-1-1-函数封装" class="headerlink" title="3.1.1 函数封装"></a>3.1.1 函数封装</h3><p>  最早期的时候，我们在一个文件里编写相关函数，像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function fn1()&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn2()&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">需要的时候加载文件并调用相关函数即可。  </div><div class="line">**缺点：Global 被污染，代码中很容易出现命名冲突。**  </div><div class="line"></div><div class="line">### 3.1.2 对象  </div><div class="line">为了解决上面的问题，我们又将一个个文件划分为一个个对象，这样在加载的时候就不用加载很多文件。代码如下：</div></pre></td></tr></table></figure></p>
<p> var MYAPP = {<br>   foo: function(){},<br>   bar: function(){}<br> }</p>
<p> MYAPP.foo(); //需要时执行<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样虽然能减少 Global 上的变量数目，避免变量污染。但是**本质是对象，外部对象可以对其他对象进行修改，很不安全**  。  </div><div class="line"></div><div class="line">### 3.1.3 立即执行函数(immediately-invoked function expression )   </div><div class="line"></div><div class="line"> &gt; IIFE (立即调用函数表达式) 是一个 JavaScript 函数 ，它会在定义时立即执行.</div><div class="line">也有人将 IIFE 称为匿名闭包.</div><div class="line"></div><div class="line">举个例子：</div></pre></td></tr></table></figure></p>
<p>var Module = (function(){<br>    var _private = “safe now”;<br>    var foo = function(){<br>        console.log(_private)<br>    }</p>
<pre><code>return {
    foo: foo
}
</code></pre><p>})()</p>
<p>Module.foo();<br>Module._private; // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以调用定义的方法，但是不能调用定义的属性。这样的模式使得变量冲突降到最低，并且能够控制暴露的方法(类似于接口）。这便是现代模块实现的基石！  </div><div class="line"></div><div class="line">### 3.1.4 Script Loader  </div><div class="line"></div><div class="line">最原始的 JS 加载方法就是在 Html 头文件中通过 Script 标签直接引入，类似下面这样：</div></pre></td></tr></table></figure></p>
<p><script src="http://remote.tld/jquery.js"></script></p>
<p><script src="local/plugin1.jquery.js"></script></p>
<p><script src="local/plugin2.jquery.js"></script></p>
<p><script src="local/init.js"></script></p>
<p><script><br>    initMyPage();<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初学者可能会有疑问，全都写在一个文件中看着不是挺方便的吗？  </div><div class="line">首先以上列举的可能只是实际项目中的一小部分，其次不要忽视 `&lt;script&gt;` 的一个特点：`并行加载，顺序执行`，这要求开发者需要按照严格的读取顺序，并且很有可能会阻塞阻止文档渲染(`async` 新特性在 HTML5 中才提出)。文件少的时候写起来会很方便，一旦项目变复杂缺点就会暴露无疑：**难以维护，依赖模糊，请求过多** 。  </div><div class="line"></div><div class="line">#### LABjs  </div><div class="line">为了解决依赖模糊，我们迫切需要一个加载器（`Loader`）最先出现在开发者视野中的 `Loader` 应该是 [`LABjs`](https://github.com/getify/LABjs])(2009)（ HTML5 发布才有了 `async` 特性）</div><div class="line"></div><div class="line">&gt; LABjs 的核心是 LAB（Loading and Blocking）：Loading 指异步并行加载，Blocking 是指同步等待执行。  </div><div class="line"></div><div class="line">通过使用 LABjs ,上方代码就可以变成这样：</div></pre></td></tr></table></figure></p>
<p><script src="LAB.js"></script></p>
<p><script><br>  $LAB<br>  .script(“<a href="http://remote.tld/jquery.js&quot;).wait()//`.wait`">http://remote.tld/jquery.js&quot;).wait()//`.wait`</a> 表示加载后立即运行<br>  .script(“/local/plugin1.jquery.js”)<br>  .script(“/local/plugin2.jquery.js”).wait()<br>  .script(“/local/init.js”).wait(function(){<br>      initMyPage();<br>  });<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当然同一时期风靡的还有类库模块化框架 [YUI](https://yuilibrary.com/)，大家可自行查阅。</div><div class="line"></div><div class="line">#### CommonJS  </div><div class="line"></div><div class="line">服务器端的 `Node.js` 遵循 [CommonJS规范](http://wiki.commonjs.org/wiki/CommonJS)，该规范的核心思想是允许模块通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或 `module.exports` 来导出需要暴露的接口。</div></pre></td></tr></table></figure></p>
<p>require(“module”);<br>require(“../file.js”);<br>exports.doStuff = function() {};<br>module.exports = someValue;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">优点:  </div><div class="line"></div><div class="line">- 服务器端模块便于重用  </div><div class="line">- [NPM](https://www.npmjs.com/) 中已经有将近20万个可以使用模块包  </div><div class="line">- 简单并容易使用  </div><div class="line"></div><div class="line">缺点：  </div><div class="line"></div><div class="line">- 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的  </div><div class="line">- 不能非阻塞的并行加载多个模块  </div><div class="line"></div><div class="line">实现:  </div><div class="line"></div><div class="line">- NodeJS</div><div class="line"></div><div class="line">#### 双塔奇兵 AMD/CMD  </div><div class="line"></div><div class="line">Commonjs用在服务器端，加载是同步的。    </div><div class="line">AMD, CMD用在浏览器端，加载是异步的。  </div><div class="line"></div><div class="line">|       -        | AMD          | CMD  |  </div><div class="line">| ------------- |:-------------|:-----|  </div><div class="line">| 概念      | [Asynchronous Module Definition](https://github.com/amdjs/amdjs-api) 规范其实只有一个主要接口 `define(id?, dependencies?, factory)`，它要在声明模块的时候指定所有的依赖 `dependencies`，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。| [Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md) 规范和 AMD 很相似，尽量保持简单，并与 `CommonJS` 和 `Node.js` 的 `Modules 规范` 保持了很大的兼容性。 |</div><div class="line">| 优点      | 1. 适合在浏览器环境中异步加载模块&lt;/br&gt; 2. 可以并行加载多个模块      |   1. 依赖就近，延迟执行 &lt;/br&gt; 2. 可以很容易在 Node.js 中运行 |  </div><div class="line">| 缺点      | 1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅&lt;/br&gt; 2. 不符合通用的模块化思维方式，是一种妥协的实现      |   依赖 SPM 打包，模块的加载逻辑偏重 |  </div><div class="line">| 实现      |     [RequireJS](http://requirejs.org/)          |  [SeaJS](http://seajs.org/)     |  </div><div class="line"></div><div class="line">两者最明显的区别可以从以下代码中查看：</div></pre></td></tr></table></figure></p>
<p>//AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>define([‘a’, ‘b’], function(a, b){<br>    a.doSomething();    // 依赖前置，提前执行<br>    b.doSomething();<br>})</p>
<p>//CMD 推崇依赖就近，只有在用到某个模块的时候再去require<br>define(function(require, exports, module){<br>    var a = require(“a”);<br>    a.doSomething();<br>    var b = require(“b”);<br>    b.doSomething();    // 依赖就近，延迟执行<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`CommonJS` (规划并标准化、致力于设计 JavaScript API)的诞生开启了 &quot;JavaScript 模块化&quot; 的时代。`CommonJS` 的模块提案为在服务器端的 JavaScript 模块化做出了很大的贡献，但是在浏览器下的 JavaScript 模块应用很有限。随之而来又诞生了其它前端领域的模块化方案，像 requireJS、SeaJS 等，然而这些模块化方案并不是十分适用 ，并没有从根本上解决模块化的问题。</div><div class="line"></div><div class="line">### 3.2 解决方案  </div><div class="line"></div><div class="line">前面已经为大家回顾了 JavaScript 的模块化发展历史，然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。如果他们都可以视作模块，并且都可以通过 `require` 的方式来加载，将带来优雅的开发体验，比如：</div></pre></td></tr></table></figure></p>
<p>require(“./style.css”);<br>require(“./style.less”);<br>require(“./template.jade”);<br>require(“./image.png”);<br>```  </p>
<p>那么如何做到让 <code>require</code> 能加载各种资源呢？  </p>
<h4 id="webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack</a> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
</blockquote>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/what-is-webpack.png" alt="webpack">  </p>
<p>Webpack 的优点可以概括为以下几点：  </p>
<ul>
<li><p><strong>代码拆分</strong><br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。  </p>
</li>
<li><p><strong>Loader</strong><br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。  </p>
</li>
<li><p><strong>智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。  </p>
</li>
<li><p><strong>插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。  </p>
</li>
<li><p><strong>快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。    </p>
</li>
</ul>
<p>当然，光有 <code>Webpack</code> 是不够的，目前大家比较推崇的最佳拍档为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">包管理工具</th>
<th style="text-align:center">模块化构建工具</th>
<th style="text-align:center">模块化规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">npm</td>
<td style="text-align:center">Webpack</td>
<td style="text-align:center">ES6模块</td>
</tr>
</tbody>
</table>
<p>当然，目前比较有许多 “自带模块化buff” 的前端框架（组件化）：<code>Vue</code> 、 <code>React</code>等，它们都有以下特点:  </p>
<ul>
<li>使用 Virtual DOM  </li>
<li>提供了响应式（ Reactive ）和组件化（ Composable ）的视图组件。  </li>
<li>保持注意力集中在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。    </li>
</ul>
<p>在 <code>Vue</code> 中，一个组件文件(<code>.Vue</code>)中，拥有<code>&lt;template&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;style&gt;</code>三个部分。每个组件中管理自己的样式、逻辑，这样在大型项目开发与维护时都起到了非常便捷的作用。  </p>
<h2 id="4-未来的模块化"><a href="#4-未来的模块化" class="headerlink" title="4. 未来的模块化"></a>4. 未来的模块化</h2><p>说到模块化未来的发展，值得一提的便是 <a href="http://webassembly.org/" target="_blank" rel="external">WebAssembly</a>。大家都知道 <code>JavaScript</code> 是一种解释性脚本语言，导致其运行时消耗大量的性能做为代价，这也是 <code>JavaScript</code> 的瓶颈之一。<code>WebAssembly</code> 旨在解决这个问题。  </p>
<h3 id="webassembly-是什么"><a href="#WebAssembly-是什么？" class="headerlink" title="WebAssembly 是什么？"></a>WebAssembly 是什么？</h3><blockquote>
<p>Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.<br>定义一个可移植，体积紧凑，加速迅捷的二进制格式为编译目标，而此二进制格式文件将可以在各种平台（包括移动设备和物联网设备）上被编译，然后发挥通用的性能以原生应用的速度运行。  </p>
</blockquote>
<h3 id="webassembly-的目标"><a href="#WebAssembly-的目标" class="headerlink" title="WebAssembly 的目标"></a>WebAssembly 的目标</h3><p>某乎上广传 “谷歌、苹果、谋智、微软一起再一次发明了 Silverlight ”。可以看出，大家对 <code>WebAssembly</code> 充满了信心与期待。  </p>
<p>作为 <a href="https://www.w3.org/community/webassembly" target="_blank" rel="external">W3C WebAssembly Community Group</a> 中的一项开放标准，WebAssembly 是为下列目标而生的：</p>
<ul>
<li>快速、高效、可移植——通过利用常见的硬件能力，WebAssembly 代码在不同平台上能够以接近本地速度运行。  </li>
<li>可读、可调试—— WebAssembly 是一门低阶语言，但是它有确实有一种人类可读的文本格式（其标准即将得到最终版本），这允许通过手工来写代码，看代码以及调试代码。   </li>
<li>保持安全—— WebAssembly 被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略。  </li>
<li>不破坏网络—— WebAssembly 的设计原则是与其他网络技术和谐共处并保持向后兼容。  </li>
</ul>
<h3 id="webassembly-的核心"><a href="#WebAssembly-的核心" class="headerlink" title="WebAssembly 的核心"></a>WebAssembly 的核心</h3><p>那么 WebAssembly 是如何在浏览器中运行的呢？我们可以看一下它的几个关键的概念：  </p>
<ul>
<li><strong>模块</strong> : 表示一个已经被浏览器编译为可执行机器码的 WebAssembly 二进制代码。一个模块是无状态的并且像一个二进制大对象（Blob）一样能够被缓存到 IndexedDB 中或者在 windows 和 workers 之间进行共享（通过 <code>postMessage()</code> 函数）。一个模块能够像一个 ES2015的模块一样声明导入和导出。   </li>
<li><strong>内存</strong> : 一个可变大小的 ArrayBuffer 。它包含了一个连续的字节数组并且 WebAssembly 的低级内存存取指令可对其进行读写操作。  </li>
<li><strong>表格</strong> : 一个可变大小的包含引用类型（比如，函数）的带类型数组。它包含了不能作为原始字节存储在内存中的引用（为了安全和可移植性的原因）。  </li>
<li><strong>实例</strong> : 一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。一个实例就像一个已经被加载到一个拥有一组特定导入的特定的全局变量的 ES2015模块。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]  &lt;/p&gt;
&lt;h2 id=&quot;1-什么是模块化&quot;&gt;&lt;a href=&quot;#1-什么是模块化&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是模块化&quot;&gt;&lt;/a&gt;1. 什么是模块化&lt;/h2&gt;&lt;p&gt;模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://prefer-tyl.site/2017/04/30/restructure-web-page/"/>
    <id>http://prefer-tyl.site/2017/04/30/restructure-web-page/</id>
    <published>2017-04-30T08:55:13.027Z</published>
    <updated>2017-06-25T08:49:13.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面重构应该遵循的基本原则和规范"><a href="#页面重构应该遵循的基本原则和规范" class="headerlink" title="页面重构应该遵循的基本原则和规范"></a>页面重构应该遵循的基本原则和规范</h1><!-- toc -->
<ul>
<li><a href="#1-什么是页面重构">1. 什么是页面重构？</a></li>
<li><a href="#2-基本原则和规范">2. 基本原则和规范</a><ul>
<li><a href="#21-常用规范">2.1 常用规范</a></li>
<li><a href="#22-语义化-seo">2.2 语义化 &amp;&amp; SEO</a><ul>
<li><a href="#221-什么是语义化">2.2.1 什么是语义化</a></li>
<li><a href="#222-为什么要让页面语义化">2.2.2 为什么要让页面语义化</a></li>
<li><a href="#223-html-语义化">2.2.3 HTML 语义化</a></li>
<li><a href="#224-css-命名语义化">2.2.4 CSS 命名语义化</a></li>
</ul>
</li>
<li><a href="#23-样式抽离-组件复用">2.3 样式抽离 &amp;&amp; 组件复用</a></li>
</ul>
</li>
<li><a href="#3-总结">3. 总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是页面重构"><a href="#1-什么是页面重构？" class="headerlink" title="1. 什么是页面重构？"></a>1. 什么是页面重构？</h2><p>简单来说，页面重构就是：<strong>将设计稿转换成 WEB 页面</strong>。  </p>
<p>那我们重构时该注意哪些东西呢？  </p>
<h2 id="2-基本原则和规范"><a href="#2-基本原则和规范" class="headerlink" title="2. 基本原则和规范"></a>2. 基本原则和规范</h2><p>在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护。  </p>
<h3 id="21-常用规范"><a href="#2-1-常用规范" class="headerlink" title="2.1 常用规范"></a>2.1 常用规范</h3><p>与使用其他语言开发工程一样，我们需要有着统一的规范，最常见就是 <strong>编码风格</strong>，比如：  </p>
<ol>
<li><p><strong>空格</strong>  </p>
<ul>
<li>等号前后空格、运算符前后使用空格分隔   </li>
<li>在逗号和冒号后添加空格  </li>
</ul>
</li>
<li><p><strong>空行</strong>  </p>
<ul>
<li>为每个逻辑功能块添加空行，这样更易于阅读    </li>
<li>将左花括号与选择器放在同一行  </li>
<li>将右花括号独立放在一行，并以分号作为结束符号  </li>
</ul>
</li>
<li><p><strong>缩进</strong>  </p>
<ul>
<li>缩进使用两个空格(不要使用制表符)    </li>
</ul>
</li>
</ol>
<p>其次是 <strong>命名</strong>，我们建议对 HTML 元素名称，属性，属性值，CSS 选择器，属性和属性值（字符串除外）使用小写字母命名，并且使用 <code>-</code> 进行分隔，举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">id</span>=<span class="string">"href-index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span>  </div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#E5E5E5</span>;  </div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#e5e5e5</span>;</div></pre></td></tr></table></figure>
<p>另外还有书写顺序，比较常见的 CSS 样式书写顺序如下：  </p>
<ol>
<li>位置属性(<code>position</code>, <code>top</code>, <code>right</code>, <code>z-index</code>, <code>display</code>, <code>float</code> 等)  </li>
<li>大小(<code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>)  </li>
<li>文字系列( <code>font</code>, <code>line-height</code>, <code>letter-spacing</code>, <code>color</code>, <code>text-align</code> 等)  </li>
<li>背景(<code>background</code>, <code>border</code> 等)  </li>
<li>其他(<code>animation</code>, <code>transition</code> 等)  </li>
</ol>
<p>以上仅列举了部分规范，更多请参考 <a href="http://eslint.cn/docs/rules/" target="_blank" rel="external">ESLint</a>  </p>
<h3 id="22-语义化-ampamp-seo"><a href="#2-2-语义化-amp-amp-SEO" class="headerlink" title="2.2 语义化 &amp;&amp; SEO"></a>2.2 语义化 &amp;&amp; SEO</h3><h4 id="221-什么是语义化"><a href="#2-2-1-什么是语义化" class="headerlink" title="2.2.1 什么是语义化"></a>2.2.1 什么是语义化</h4><blockquote>
<p>语义化是指使用恰当语义的 HTML 标签、class 类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。  </p>
</blockquote>
<h4 id="222-为什么要让页面语义化"><a href="#2-2-2-为什么要让页面语义化" class="headerlink" title="2.2.2 为什么要让页面语义化"></a>2.2.2 为什么要让页面语义化</h4><p>语义化的好处 ：  </p>
<ul>
<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构  </li>
<li><strong>有利于</strong> <a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="external">SEO</a> ( Search Engine Optimization——搜索引擎优化)：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重    </li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以特殊的方式来渲染网页     </li>
<li>便于团队开发和维护，可以减少很多差异化，减少成员间沟通成本，方便开发和后期维护，利于实现模块化开发</li>
</ul>
<h4 id="223-html-语义化"><a href="#2-2-3-HTML-语义化" class="headerlink" title="2.2.3 HTML 语义化"></a>2.2.3 HTML 语义化</h4><p>假设我们要开发一个页面，在 HTML5 出现之前，页面架构很有可能是下面这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%89%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的架构缺点比较明显：  </p>
<ul>
<li>需要用到很多 <code>div</code> 标签,但实际上 <code>div</code> 标签并没有语义，这不利于爬虫对页面内容进行抓取  </li>
<li>文档结构不明确。也许你认为有 <code>id</code> 就足够了，但是后面会发现在一大堆 <code>&lt;div&gt;</code> 中找出这些 <code>id</code> 并不高效</li>
</ul>
<p>于是，在 HTML5 中，页面架构变成了这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%90%8E%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的结构看起来就清晰多了，我们可以直接从标签名称得知它的作用。  </p>
<p>当然，我们也不是说将所有的 <code>div</code> 全部替换为对应的语义化标签(比如考虑到网页兼容问题)，具体情况应具体分析。  </p>
<p>根据应用场景，一些常用的标签元素有：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">主要语义</th>
<th style="text-align:left">元素名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">本身无语义，组合其他 HTML 元素，常用于页面布局</td>
<td style="text-align:left"><code>div</code></td>
</tr>
<tr>
<td style="text-align:left">设置文本，填充段落</td>
<td style="text-align:left"><code>h1~h6</code>, <code>p</code>, <code>span</code>, <code>strong</code>, <code>em</code>…</td>
</tr>
<tr>
<td style="text-align:left">表现列表</td>
<td style="text-align:left"><code>ul</code>, <code>li</code>, <code>ol</code>, <code>dl</code>, <code>dt</code>, <code>dd</code></td>
</tr>
<tr>
<td style="text-align:left">表单相关</td>
<td style="text-align:left"><code>form</code>,<code>input</code>,<code>select</code>,<code>button</code></td>
</tr>
<tr>
<td style="text-align:left">表格相关</td>
<td style="text-align:left"><code>table</code>,<code>thead</code>,<code>tbody</code>,<code>tfoot</code>,<code>th</code>,<code>tr</code>,<code>td</code></td>
</tr>
<tr>
<td style="text-align:left">图像显示</td>
<td style="text-align:left"><code>img</code>, <code>canvas</code></td>
</tr>
<tr>
<td style="text-align:left">打开链接，发送邮件，段落跳转</td>
<td style="text-align:left"><code>a</code></td>
</tr>
</tbody>
</table>
<h4 id="224-css-命名语义化"><a href="#2-2-4-CSS-命名语义化" class="headerlink" title="2.2.4 CSS 命名语义化"></a>2.2.4 CSS 命名语义化</h4><p>CSS 命名的语义就是 <code>class</code> 和 <code>id</code> 命名的语义。<br><code>class</code> 属性作为 HTML 与 CSS 衔接的纽带，其本意是用来描述元素内容的。指用易于理解的名称对 HTML 标签附加的 <code>class</code> 或 <code>id</code> 命名。如果说 HTML 语义化标签是给机器看的，那么 CSS 命名的语义化就是给人看的。良好的 CSS 命名方式减少沟通调试成本，易于理解。  </p>
<p>CSS 命名首先要满足 W3C 的命名规范和团队的命名规范。其次是高效和可重用性。  </p>
<p>就好像 <code>.main</code> / <code>.sidebar</code> 会比 <code>.left_content</code> / <code>.right_content</code> 的 class 命名灵活性更好。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 以表现为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"lr margin10"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 以信息为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"user-info"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="23-样式抽离-ampamp-组件复用"><a href="#2-3-样式抽离-amp-amp-组件复用" class="headerlink" title="2.3 样式抽离 &amp;&amp; 组件复用"></a>2.3 样式抽离 &amp;&amp; 组件复用</h3><p>在后端开发中，我们常常将一些公共的字符串、函数等抽离出来，在需要的地方便可方便的调用。前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>在 前端模块化 的历史演变中，曾有一段时期我们会这样构造组件：  </p>
<ul>
<li><strong>base</strong> 提供最底层的、功能和粒度最小的的通用类样式，可以被所有页面引用  </li>
<li><strong>common</strong> 出现频率高，功能相对独立的组件，如 <code>Button</code>、<code>Dialog</code>、<code>Tooltip</code> 等  </li>
<li><strong>page</strong> 各页面独有的样式，实际中可划分为 <code>page-index.css</code> 、<code>page-dashboard.css</code> 等  </li>
</ul>
<p>但是随着工程的逐渐壮大，使用及维护起来还是比较困难。我们期望 组件/样式 有着 “按需引入，即插即用” 的特性。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>为了实现这样的引入方式，我们需要使用 Loader 。  </p>
<p>Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 <code>require</code> 来加载任何类型的模块或文件。  </p>
<p>如果我们要在 <code>index.html</code> 引入一个 CSS 文件 <code>style.css</code>，首页将 <code>style.css</code> 也看成是一个模块，然后用 <code>css-loader</code> 来读取它，再用 <code>style-loader</code> 把它插入到页面中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* style.css */</div><div class="line">body &#123; background: yellow; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"!style-loader!css-loader!./style.css"</span>) <span class="comment">// 载入 style.css</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>安装 loader :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://vuefe.cn/v2/guide/index.html" target="_blank" rel="external">Vue.js</a> 中，我们可以将 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 都写于一个 <code>.vue</code> 格式的文件中，一个文件便对应一个组件，并且可以在其他组件中很方便的引入。  </p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>当然，除了以上几点，我们需要遵循的原则和规范还很多。总的来说，页面重构时，在规范编码的基础上我们首先考虑的因素便是语义化：HTML 标签语义化、CSS 命名语义化等等。语义化的最终目的就是使得人与机器对页面识别度更高。其次，为了方便协作与后期维护，我们应该考虑组件复用、样式抽离，或者说模块化等。原则和规范并不总是一成不变的，随着前端技术的快速发展，高效、便于协作与维护的方式便是最佳原则与规范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;页面重构应该遵循的基本原则和规范&quot;&gt;&lt;a href=&quot;#页面重构应该遵循的基本原则和规范&quot; class=&quot;headerlink&quot; title=&quot;页面重构应该遵循的基本原则和规范&quot;&gt;&lt;/a&gt;页面重构应该遵循的基本原则和规范&lt;/h1&gt;&lt;!-- toc --&gt;
&lt;ul&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

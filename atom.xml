<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prefert</title>
  <subtitle>prefer-tyl</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prefer-tyl.site/"/>
  <updated>2017-08-02T12:59:09.173Z</updated>
  <id>http://prefer-tyl.site/</id>
  
  <author>
    <name>Prefert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala 与设计模式（三）：Prototype 原型模式</title>
    <link href="http://prefer-tyl.site/2017/07/31/scala-design-patterns-3-prototype/"/>
    <id>http://prefer-tyl.site/2017/07/31/scala-design-patterns-3-prototype/</id>
    <published>2017-07-30T16:00:00.000Z</published>
    <updated>2017-08-02T12:59:09.173Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。</p>
<a id="more"></a>
<p>第一个生物是怎么诞生的？ 从科学角度推测：是由第一个细胞从核糖核酸(RNA)不断的新陈代谢演变而来的。</p>
<p>第一个细胞其实是非常孤独的，但幸好它掌握了「分裂」与「分化」的本领，一定条件下可以一分为二，由此才能快速演变，出现现在的人类。</p>
<p>在开发过程中，我们也常有类似的场景，本文将以细胞分裂为例来介绍原型模式。</p>
<!-- toc -->
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#浅拷贝">浅拷贝</a></li>
<li><a href="#深拷贝">深拷贝</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> 「四人帮」设计模式中提及的 原型模式 定义如下：</p>
<blockquote>
<p>用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>从定义中我们可以知道，原型模式中核心点就是 <strong>原型类</strong> 和 <strong>拷贝</strong> 。</p>
<p>看到拷贝，有些同学脑中可能会浮现下面这张图：</p>
<center><img src="http://om6vvgjw7.bkt.clouddn.com/1473308168_167070.png" width="400px"></center>  

<p>可事实并没有这么简单。</p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>回到开头的例子，假设细胞没有分裂能力，每个细胞产生的过程和时间是一样的，这无疑是费时的。</p>
<p>这也是「原型模式」第一个要解决的问题 — <strong>通过拷贝加速效率</strong>。</p>
<p>在 Java 中所有的 <code>class</code> 都继承自 <code>java.lang.Object</code> 类，<code>Object</code> 提供了一个 <code>clone()</code> 方法，通过它，就能实现对象的拷贝。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>我们利用 <code>Cloneable</code> 接口，来实现细胞的克隆：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String dna;</div><div class="line">    <span class="keyword">private</span> Organelle organelle; <span class="comment">// 细胞器</span></div><div class="line"></div><div class="line">    ... <span class="comment">// 省略 get set 与 构造函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Cell: &#123;"</span> +</div><div class="line">                <span class="string">"DNA = "</span> + dna + <span class="string">'\''</span> +</div><div class="line">                <span class="string">"Organelle = "</span> + organelle.toString() +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cell <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Cell cellCopy = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cellCopy = (Cell) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cellCopy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String cytoplasm; <span class="comment">// 细胞质</span></div><div class="line">    <span class="keyword">private</span> String nucleus; <span class="comment">// 细胞核</span></div><div class="line"></div><div class="line">    ...<span class="comment">// 省略get、set、toString() 与构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上我们便能调用 <code>clone()</code> 方法对复杂对象进行拷贝，以此来实现分裂的功能。</p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Cell cellA, cellB;</div><div class="line"></div><div class="line">cellA = <span class="keyword">new</span> Cell(<span class="string">"AAAGTCTGAC"</span>, <span class="keyword">new</span> Organelle(<span class="string">"细胞质"</span>, <span class="string">"细胞核"</span>));</div><div class="line">System.out.println(cellA);</div><div class="line"></div><div class="line">cellB = cellA.clone();</div><div class="line">System.out.println(cellB);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"cellA == cellB ? "</span> + (cellA == cellB));</div><div class="line">System.out.println(<span class="string">"cellA-class == cellB-class? :"</span> + (cellA.getClass() == cellB.getClass()));</div></pre></td></tr></table></figure></p>
<p>看起来不错！但问题出现了：<strong>这里的 <code>clone</code> 只能拷贝到细胞本身信息，但不拷贝细胞的引用，不同细胞中包含的细胞器是一样的。</strong></p>
<p>这其实是「浅拷贝」和「深拷贝」的问题。看看它们的区别：</p>
<ul>
<li><p><strong>浅拷贝</strong><br>仅仅复制原有对象的值，而不复制它对其他对象的引用。</p>
</li>
<li><p><strong>深拷贝</strong><br>原有对象的值和引用都被复制。</p>
</li>
</ul>
<p>验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"cellA.Organelle == cellB.Organelle ? "</span> + (cellA.getOrganelle() == cellB.getOrganelle()));</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellA.Organelle == cellB.Organelle ? true</div></pre></td></tr></table></figure></p>
<p>可见，当前 <code>clone()</code> 方法执行的是浅拷贝，Java 中所有的对象都保存在全局共享的堆中。</p>
<p>只要能拿到某个对象的引用，引用者就可以随意修改对象，这显然是不好的。</p>
<p>接下来我为大家介绍一下深拷贝如何实现。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>说到深拷贝，一般有两种实现方案：  </p>
<p><strong>1. 改变 <code>clone</code> 方法</strong>  </p>
<p>既然问题出在细胞器（<code>Organelle</code>）的引用没有被复制，为其手动添加上即可。  </p>
<p>首先修改引用类，使其支持 <code>clone</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">  ... <span class="comment">// 省略相同代码</span></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">       Object object = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           object = <span class="keyword">super</span>.clone();</div><div class="line">       &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> object;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>其次在 <code>Cell</code> 类的 <code>clone()</code> 方法中复制细胞器的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Cell <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Cell cellCopy = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cellCopy = (Cell) <span class="keyword">super</span>.clone();</div><div class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cellCopy != <span class="keyword">null</span>) &#123;</div><div class="line">        cellCopy.organelle = (Organelle) organelle.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cellCopy;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellA.organelle == cellB.organelle ? false</div></pre></td></tr></table></figure></p>
<p>虽然功能是实现了，但是每个引用对象都要重写 <code>clone()</code>，太糟糕了！</p>
<p><strong>2. 序列化对象</strong>  </p>
<p> 序列化是一个将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。  </p>
<p> 与 <code>Cloneable</code> 实现类似，需要序列化的类要求实现序列化接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; ... &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  ... <span class="comment">// 省略部分代码</span></div><div class="line"></div><div class="line">  <span class="comment">// 序列化实现深拷贝</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Cell <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</div><div class="line">    <span class="comment">// 序列化（将对象写入流中）</span></div><div class="line">    ByteArrayOutputStream bos=<span class="keyword">new</span>  ByteArrayOutputStream();</div><div class="line">    ObjectOutputStream oos=<span class="keyword">new</span>  ObjectOutputStream(bos);</div><div class="line">    oos.writeObject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 反序列化（将对象从流中取出）</span></div><div class="line">    ByteArrayInputStream bis=<span class="keyword">new</span>  ByteArrayInputStream(bos.toByteArray());</div><div class="line">    ObjectInputStream ois=<span class="keyword">new</span>  ObjectInputStream(bis);</div><div class="line">    <span class="keyword">return</span>  (Cell)ois.readObject();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：Cloneable 与 Serializable 接口都是 「marker Interface」，即它们只是标识接口，没有定义任何方法。</p>
</blockquote>
<p>对比而言，序列化的实现方式不需要重写多个类的 <code>clone()</code> 方法，比第一种更加简便。</p>
<p>接下去看看 Scala 中如何实现原型模式。</p>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中，你用类似 Java 的方式来实现(Scala 提供了调用 Java 中 <code>Cloneable</code> 和 <code>Serializable</code> 的特质)<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cloneable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Cloneable</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Serializable</span> <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure></p>
<p>当然，Scala 中每个 <code>case class</code> 都拥有一个 <code>copy()</code> 方法，它会返回拷贝自原有实例的新实例，并且可以在拷贝的过程中改变一些值。</p>
<p>同样以细胞为例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span>(<span class="params">dna: <span class="type">String</span>, organelle: <span class="type">Organelle</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span>(<span class="params">cytoplasm: <span class="type">String</span>, nucleus: <span class="type">String</span></span>)</span></div></pre></td></tr></table></figure></p>
<p>测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> initialCell = <span class="type">Cell</span>(<span class="string">"AAAGTCTGAC"</span>, <span class="type">Organelle</span>(<span class="string">"细胞质"</span>, <span class="string">"细胞核"</span>))</div><div class="line"><span class="keyword">val</span> cell1 = initialCell.copy()</div><div class="line"><span class="keyword">val</span> cell2 = initialCell.copy()</div><div class="line"><span class="keyword">val</span> cell3 = initialCell.copy(dna = <span class="string">"1234"</span>) <span class="comment">// 可以在拷贝的时候重新赋值</span></div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell1: <span class="subst">$&#123;cell1&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell2: <span class="subst">$&#123;cell2&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell3: <span class="subst">$&#123;cell3&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell1 and cell2 are equal: <span class="subst">$&#123;cell1 == cell2&#125;</span>"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="type">Cell</span> <span class="number">1</span>: <span class="type">Cell</span>(<span class="type">AAAGTCTGAC</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line"><span class="type">Cell</span> <span class="number">2</span>: <span class="type">Cell</span>(<span class="type">AAAGTCTGAC</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line"><span class="type">Cell</span> <span class="number">3</span>: <span class="type">Cell</span>(<span class="number">1234</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line">cell1 and cell2 are equal: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>对比 Scala 和 Java 的实现代码，有没有发现 Scala 是如此的简洁。</p>
<p>诶？ 为什么 <code>cell1</code> 和 <code>cell1</code> 相等？ 这会不会导致上面浅拷贝的问题呢？不存在的。</p>
<p>由于 <code>case class</code> 参数默认为 <code>val</code>，两个 <code>case class</code> 对象持有相同引用，但也<strong>不允许修改</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上内容，我们对原型模式已有一些了解，一般来说原型模式中参与者有以下三类：  </p>
<ul>
<li><strong>抽象原型类</strong>：声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类、接口、甚至具体实现类（对应上面的 <code>Cloneable</code> 和 <code>Serializable</code> 接口）。  </li>
<li><strong>具体原型类</strong>：实现抽象原型类声明的克隆方法，返回自己的一个克隆对象(<code>Cell.class</code> | <code>Cell.class</code>)。  </li>
<li>客户类：创建对象并克隆（<code>Test.class</code>）。  </li>
</ul>
<p>以下为 Java 与 Scala 中的实现方式对比：</p>
<table>
<thead>
<tr>
<th>拷贝方式</th>
<th>Java</th>
<th>Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅拷贝</td>
<td>具体原型类实现 <code>Cloneable</code></td>
<td>具体原型类实现 <code>Cloneable</code> 或  具体原型类为 <code>case class</code></td>
</tr>
<tr>
<td>深拷贝</td>
<td>具体原型类 + 引用类实现 <code>Cloneable</code> 或  <code>Serializable</code></td>
<td>具体原型类 + 引用类实现 <code>Cloneable</code> 或  <code>Serializable</code></td>
</tr>
</tbody>
</table>
<p>当然原型模式通常还可以解决以下问题：</p>
<ul>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的 CPU 资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。  </li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。  </li>
</ul>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Prototype" target="_blank" rel="external">源码链接</a>  </p>
<p>如有错误和讲述不恰当的地方还请指出，不胜感激！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（二）：Builder 创建者模式</title>
    <link href="http://prefer-tyl.site/2017/07/20/scala-design-patterns-2-builder/"/>
    <id>http://prefer-tyl.site/2017/07/20/scala-design-patterns-2-builder/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-07-20T14:47:03.619Z</updated>
    
    <content type="html"><![CDATA[<p>创建者模式（Builder Pattern）支持以类方法而非类构造器的方式来创建实例。当一个类的构造器拥有多个版本以支持不同的用途时，这种模式尤其有用。</p>
<a id="more"></a>
<p>在 Java 开发中，你是否写过这样像蛇一样长的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Robot robot = <span class="keyword">new</span> Robot(<span class="number">1</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>) <span class="comment">// Boolean 类型的参数表示 computer 是否含有对应固件</span></div></pre></td></tr></table></figure></p>
<p>刚写完时回头看发现能看懂，一天后回头看时已经忘记大半了，一个星期后：What The Fu*k？<br>当然有强（lan）迫（duo）症的同学肯定不能忍 ——— 他们会创造各种各样的便捷版！</p>
<p>本文会通过 Builder Pattern 来一步步解决上述以及更复杂的一些情况。</p>
<!-- 本篇文章结构如下： -->
<!-- - builder pattern 的概念 -->
<!-- - 问题分解 -->
<!-- - Java 实例 -->
<!-- - Scala 实例 -->
<!-- - 总结 -->
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#它解决了什么问题">它解决了什么问题</a><ul>
<li><a href="#当大量参数遇上构造函数">当大量参数遇上构造函数</a></li>
<li><a href="#java-变种版">Java —— 变种版</a><ul>
<li><a href="#java-传统版">Java —— 传统版</a></li>
</ul>
<ul>
<li><a href="#builder-模式的构成">Builder 模式的构成</a></li>
<li><a href="#如何让构造的对象有不同表示">如何让构造的对象有不同表示</a></li>
<li><a href="#代码实现">代码实现</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#仿-java-版">仿 Java 版</a></li>
<li><a href="#case-class-版">case class 版</a></li>
<li><a href="#类型安全type-safe-版">类型安全(<code>type-safe</code>) 版</a></li>
<li><a href="#require-版">require 版</a></li>
</ul>
</li>
<li><a href="#总结-1">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>创建者模式与单例模式一样，也是「四人帮」设计模式中的一种，一般也译作「生成器模式」，定义如下：</p>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.<br>   将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。        </p>
</blockquote>
<h2 id="它解决了什么问题"><a href="#它解决了什么问题" class="headerlink" title="它解决了什么问题"></a>它解决了什么问题</h2><h4 id="当大量参数遇上构造函数"><a href="#当大量参数遇上构造函数" class="headerlink" title="当大量参数遇上构造函数"></a>当大量参数遇上构造函数</h4><p>我们都知道在 Java 中，每个类都至少有一个构造函数，如果我们没有明确声明构造函数，编译器会默认帮我们生成一个无参的构造函数。当然我们也可以根据参数写不同的构造函数。</p>
<p>在实际项目开发中，对象中的属性一般都是比较多的。当对象中有大量可选参数或者参数类型一致时（正如文章开头的例子），通常情况下创建前我们需要了解这个类的内部结构，然后我们忽略掉为空的参数或者用所需的参数写一个新的构造函数。</p>
<p>我们以「机器人」类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String code;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> battery;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ability;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</div><div class="line"></div><div class="line">    <span class="comment">// 通常我们会生成一个含有全部参数的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String code, String name, <span class="keyword">int</span> type, <span class="keyword">int</span> battery, <span class="keyword">int</span> ability, <span class="keyword">double</span> weight, <span class="keyword">double</span> height)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.code = code;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.battery = battery;</div><div class="line">        <span class="keyword">this</span>.ability = ability;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Robot &#123;"</span> +</div><div class="line">                <span class="string">"code = "</span> + code + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", name = '"</span> + name + <span class="string">'\''</span> +</div><div class="line">                ... <span class="comment">// 省略部分</span></div><div class="line">                <span class="string">", height = '"</span> + height +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// Test</span></div><div class="line">Robot robot1 = <span class="keyword">new</span> Robot(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>, <span class="number">99</span>, <span class="number">250</span>, <span class="number">180</span>, <span class="number">180</span>);</div><div class="line">System.out.println(robot1);</div></pre></td></tr></table></figure></p>
<p>我们假设 <code>code</code> <code>name</code> <code>type</code> 是必填的参数，其他参数是可选的，我们想要的写法可能是下面这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Robot robot2 = <span class="keyword">new</span> Robot(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>奈何编译器可没那么智能，这样肯定会给出参数不匹配的 error 。我们只能老实的根据参数再去写一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String code, String name, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.code = code;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当用户类型不同时，参数组合情况就会很多，难道还要每种都写一个吗？就算这样写了，也意味着构建时有多种对象状态，扩展起来也不方便，该怎么办呢？ Builder 模式虎躯一震：是时候展现真正的技术了。</p>
<h4 id="java-变种版"><a href="#Java-——-变种版" class="headerlink" title="Java —— 变种版"></a>Java —— 变种版</h4><p>为了应对可选参数过多的情况，我们可以将 <code>Robot.java</code> 改进成下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(RobotBuilder robotBuilder)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.code = robotBuilder.code;</div><div class="line">       <span class="keyword">this</span>.name = robotBuilder.name;</div><div class="line">       ...</div><div class="line">       <span class="keyword">this</span>.height = robotBuilder.height;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> String code;</div><div class="line">       <span class="keyword">private</span> String name;</div><div class="line">       ...</div><div class="line">       <span class="keyword">private</span> <span class="keyword">double</span> height;</div><div class="line"></div><div class="line">       <span class="comment">// 必填参数</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">RobotBuilder</span><span class="params">(String code, String name, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.code = code;</div><div class="line">           <span class="keyword">this</span>.name = name;</div><div class="line">           <span class="keyword">this</span>.type = type;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//选填参数</span></div><div class="line">       <span class="function"><span class="keyword">public</span> RobotBuilder <span class="title">withOptionalBattery</span><span class="params">(<span class="keyword">int</span> battery)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.battery = battery;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ... <span class="comment">// 省略部分选填参数</span></div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> Robot <span class="title">buildRobot</span><span class="params">()</span> </span>&#123;</div><div class="line">           ValidateRobotData();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Robot(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ValidateRobotData</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="comment">// 参数格式检查</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过这种写法，可以减少对象创建过程中引入的多个构造函数、可选参数以及多个 setter 过度使用导致的不必要的复杂性。</p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Robot robot = <span class="keyword">new</span> Robot.RobotBuilder(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>)</div><div class="line">        .withOptionalBattery(<span class="number">99</span>)</div><div class="line">        .withOptionalAbility(<span class="number">250</span>)</div><div class="line">        .withOptionalWeight(<span class="number">180</span>)</div><div class="line">        .withOptionalHeight(<span class="number">180</span>)</div><div class="line">        .buildRobot();</div><div class="line"></div><div class="line">System.out.println(robot);</div></pre></td></tr></table></figure></p>
<p>这样的链式调用看起来比较优雅，同时对于可选参数也有语义化的引入方式。但是实际的情况可能会更糟糕一些：<code>Robot</code> 类中可能还会包含其他复杂对象，并且这些对象之间还存在一些构造顺序，下面将介绍传统的 Buidler 模式是如何解决这个问题的。</p>
<h3 id="java-传统版"><a href="#Java-——-传统版" class="headerlink" title="Java —— 传统版"></a>Java —— 传统版</h3><p>在写实际的例子之前，让我们先看一下 「四人帮」 提出的 Builder 模式的组成（推荐新手先看例子再回过头来看）</p>
<h5 id="builder-模式的构成"><a href="#Builder-模式的构成" class="headerlink" title="Builder 模式的构成"></a>Builder 模式的构成</h5><ol>
<li>建造者(Builder):<ul>
<li>Builder 为创建一个 Product 对象(对应文中 Robot)的各个部件指定抽象接口。</li>
</ul>
</li>
<li>抽象建造者(ConcreteBuilder):<ul>
<li>实现 Builder 的接口以构造和装配该产品的各个部件。</li>
<li>定义并明确它所创建的表示。</li>
<li>提供一个检索产品的接口</li>
</ul>
</li>
<li>导演类(Director)<ul>
<li>构造一个使用 Builder 接口的对象。</li>
</ul>
</li>
<li><p>产品类(Product)  </p>
<ul>
<li>表示被构造的复杂对象，ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
<p>看着是不是会有一点绕？还是先直接进入实际的场景部分吧！</p>
</li>
</ol>
<h5 id="如何让构造的对象有不同表示"><a href="#如何让构造的对象有不同表示" class="headerlink" title="如何让构造的对象有不同表示"></a>如何让构造的对象有不同表示</h5><p>不知道大家有没有看过「西部世界」，这部电影中的机器人展现出了高度智慧（没看过的话多啦A梦也可以吧），相信大家都想拿一个过来研究一下。</p>
<p>如果我们能够购买到这样的机器人，过程应该是这样的：</p>
<ol>
<li>我们（<code>Client</code>）和出厂商（<code>Director</code>）联系，告诉出厂商需要什么类型的机器人（<code>Product</code>)<br>；</li>
<li>出厂商接单后，设计师将我们需要的机器人的部件（<code>Builder</code>）进行分类筛选，发出构造指令；</li>
<li>不同生产人员（<code>ConcreteBuilder</code>）收到对应部件的构造命令；</li>
<li>各个组件被组装起来变成我们需要的机器人（<code>Product</code>）。</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>有了一个过程的概念，让我们看看代码是如何实现的（模拟的侧重点不同所以将 <code>Robot</code> 的参数改变）：</p>
<ol>
<li><p>厂家决定机器人有哪些结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String sensor;</div><div class="line">    <span class="keyword">private</span> String control;</div><div class="line">    <span class="keyword">private</span> String drive;</div><div class="line">    <span class="keyword">private</span> String shell;</div><div class="line"></div><div class="line">    ... <span class="comment">//省略参数的 set 函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Robot &#123;"</span> +</div><div class="line">                <span class="string">"  Sensor = '"</span> + sensor + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Control = '"</span> + control + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Drive = '"</span> + drive + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Shell = '"</span> + shell + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义组装机器人的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildSensor</span><span class="params">()</span></span>;  <span class="comment">// 构建传感器模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildControl</span><span class="params">()</span></span>; <span class="comment">// 构建控制模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildDrive</span><span class="params">()</span></span>;   <span class="comment">// 构建驱动模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildShell</span><span class="params">()</span></span>;   <span class="comment">// 构建外壳</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Robot <span class="title">getRobot</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现生产工创造并组装组件的具体方式，返回拼装好的机器人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">//创建机器人实例</span></div><div class="line">    Robot robot = <span class="keyword">new</span> Robot();</div><div class="line"></div><div class="line">    <span class="comment">// 生产并组装部件</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildSensor</span><span class="params">()</span> </span>&#123;</div><div class="line">      robot.setSensor(<span class="string">"创建并组装传感器"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... <span class="comment">// 省略部分 Build 函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Robot <span class="title">getRobot</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> robot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下达指定给机器人生产与组装人员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(Builder builder)</span></span>&#123;</div><div class="line">        <span class="comment">// 按一定顺序组装机器人</span></div><div class="line">        builder.BuildSensor();</div><div class="line">        builder.BuildControl();</div><div class="line">        builder.BuildDrive();</div><div class="line">        builder.BuildShell();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试机器人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Director director = <span class="keyword">new</span> Director();</div><div class="line">Builder builder = <span class="keyword">new</span> ConcreteBuilder();</div><div class="line"></div><div class="line">director.Construct(builder); <span class="comment">// 发出组装机器人的指令</span></div><div class="line">Robot robot = builder.getRobot(); <span class="comment">// 拿来拼装好的机器人</span></div><div class="line">System.out.println(robot); <span class="comment">// 展示机器人</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从上面的例子中看出我们只关心机器人是否正常运作，但是并不知道机器人拼装的过程。即这种模式的封装性很好。使用该模式可以有效的封装变化，在使用场景中，一般产品类（<code>Product</code>）和建造者(<code>Builder</code>)类是比较稳定的，因此，将主要的业务逻辑封装在导演类（<code>Director</code>）中对整体而言可以取得比较好的稳定性。</p>
<p>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者（<code>ConcreteBuilder</code>)类就可以完成，基本上不用修改之前的代码，因此对原有代码影响很小。</p>
<p>那么，在 Scala 中是否也存在 Java 的问题呢？</p>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><h4 id="仿-java-版"><a href="#仿-Java-版" class="headerlink" title="仿 Java 版"></a>仿 Java 版</h4><p>问题存在是毋庸置疑的，但我们最关心的应该是解决方法，Java 能干的 Scala 肯定也是能做的。在 Scala 中也有类似上文中 「Java —— 变种版」 的实现方式，我们还是采用 <code>Robot</code> 作为例子（因篇幅有限省略参数）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">builder: <span class="type">RobotBuilder</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">val</span> name = builder.name</div><div class="line">    <span class="keyword">val</span> nickname = builder.nickname</div><div class="line">    <span class="keyword">val</span> age = builder.age</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>然后定义一个 <code>Buidler</code> 类:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> code = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> battery = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setName</span></span>(name: <span class="type">String</span>): <span class="type">RobotBuilder</span> = &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span> <span class="comment">// 返回 this 链式调用</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ... <span class="comment">// 省略两个 set 函数</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>() = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="type">Robot</span>(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot: <span class="type">Robot</span> = <span class="keyword">new</span> <span class="type">RobotBuilder</span>()</div><div class="line">  .setCode(<span class="string">"89757"</span>)</div><div class="line">  .setName(<span class="string">"Bat-Man"</span>)</div><div class="line">  .setBattery(<span class="number">88</span>)</div><div class="line">  .build()</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot: <span class="subst">$robot</span> &#125;"</span>)</div></pre></td></tr></table></figure></p>
<p>这个与上方 Java 版本基本无异，当为 <code>Robot</code> 类添加新的字段也不必再创建新的构造器。仅需要通过 <code>RobotBuilder</code> 类进行兼容即可。</p>
<h4 id="case-class-版"><a href="#case-class-版" class="headerlink" title="case class 版"></a>case class 版</h4><p>但是我们可能忽略了一个问题：Scala 作为 「Object-Oriented Meets Functional」 的一门语言，推崇函数式编程和并发，比 Java 更加强调不变性。上文中的 <code>setXXX</code> 已经违背了这个特点，会带来副作用，这并不符合最佳实践。</p>
<p>好在 Scala 拥有样例类，这使得创造者模式的实现变得更加简单：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                   name: <span class="type">String</span> = "",</div><div class="line">                   code:  <span class="type">String</span> = "",</div><div class="line">                   battery :<span class="type">Int</span> = 0</div><div class="line">                  )</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot1 = <span class="type">Robot</span>(</div><div class="line">  code = <span class="string">"89757"</span>,</div><div class="line">  name = <span class="string">"Bat-Man"</span>,</div><div class="line">  battery = <span class="number">99</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">val</span> robot2 = <span class="type">Robot</span>(name = <span class="string">"prefert"</span>)</div><div class="line"></div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot 1: <span class="subst">$robot1</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot 2: <span class="subst">$robot2</span>"</span>)</div></pre></td></tr></table></figure></p>
<p>这种实现要比第一种实现更加简洁并且也更易维护，同时解决了第一种中不够 Pure 的缺点。</p>
<h4 id="类型安全type-safe-版"><a href="#类型安全-type-safe-版" class="headerlink" title="类型安全(type-safe) 版"></a>类型安全(<code>type-safe</code>) 版</h4><p>在创建对象的过程中，参数的初始化顺序可能是严格要求的（比如机器人遵循从里到外，从小到大的构造方式）。回顾前面两种方式，我们并不能完全控制参数的初始化顺序。</p>
<p>这里我们给<code>code</code> <code>name</code> 字段设置非空约束。为了确保这些参数都被设置，我们可以结合 <code>sealed</code> 关键字，利用 ADT 来达到这个目的（对 ADT 不熟悉的同学可以参考一下这篇文章<a href="http://scala.cool/2017/03/how-to-use-algebraic-data-type-in-scala-development/" target="_blank" rel="external">如何在 Scala 中利用 ADT 良好地组织业务</a>），同时对 <code>Robot</code> 类做一些修改：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                  code: <span class="type">String</span>,</div><div class="line">                  name: <span class="type">String</span>,</div><div class="line">                  battery: <span class="type">Int</span></div><div class="line">                )</div><div class="line"></div><div class="line"><span class="comment">//  抽象类型定义了构建过程的不同步骤</span></div><div class="line"><span class="comment">// sealed 关键字要求我们要枚举所有的情况，被sealed 声明的 trait仅能被同一文件的的类继承</span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">BuildStep</span></span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">HasCodeStep</span> <span class="keyword">extends</span> <span class="title">BuildStep</span></span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">HasNameStep</span> <span class="keyword">extends</span> <span class="title">BuildStep</span></span></div></pre></td></tr></table></figure></p>
<p>然后我们改变一下 <code>RobotBuilder</code> 类 ：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;: 为类型上界符号，即 PassedStep 必须是 BuildStep 的子类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span>[<span class="type">PassedStep</span> &lt;: <span class="type">BuildStep</span>] <span class="title">private</span>(<span class="params"></span></span></div><div class="line">                                                     var code: <span class="type">String</span>,</div><div class="line">                                                     var name: <span class="type">String</span>,</div><div class="line">                                                     var battery: <span class="type">Int</span></div><div class="line">                                                   ) &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 按实际需求重载构造器</span></div><div class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">""</span>, <span class="string">""</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(pb: <span class="type">RobotBuilder</span>[_]) = <span class="keyword">this</span>(</div><div class="line">    pb.code,</div><div class="line">    pb.name,</div><div class="line">    pb.battery</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setCode</span></span>(code: <span class="type">String</span>): <span class="type">RobotBuilder</span>[<span class="type">HasCodeStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.code = code</div><div class="line">    <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">HasCodeStep</span>](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setName</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> ev: <span class="type">PassedStep</span> =:= <span class="type">HasCodeStep</span>): <span class="type">RobotBuilder</span>[<span class="type">HasNameStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">HasNameStep</span>](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setBattery</span></span>(battery: <span class="type">Int</span>): <span class="type">RobotBuilder</span>[<span class="type">PassedStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.battery = battery</div><div class="line">    <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// =:= 要求 ev 等于 HasAgeStep 类型</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>()(<span class="keyword">implicit</span> ev: <span class="type">PassedStep</span> =:= <span class="type">HasNameStep</span>): <span class="type">Robot</span> = <span class="type">Robot</span>(code, name, battery)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里将 builder 构造器设为 <code>private</code> 类型，即我们不可再使用 <code>new</code> 来创建 builder 了。并且返回类型变成了 <code>RobotBuilder[PassedStep]</code>。</p>
<p>另外我们给需要的方法添加了泛化类型约束，以 <code>build()</code> 函数为例，它限制 <code>HasNameStep</code> 步骤完成后构造器才能成功调用。</p>
<p>现在已经实现构造器已经对外不可见了，我们还需要提供一个命令入口。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">BuildStep</span>]()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>object</code> 在上一篇单例模式中提到过，单独出现时即单例对象(<code>Singleton Object</code>)，当与同名 <code>Class</code> 同时出现时，被称为 <code>class</code> 的伴生对象(<code>companion object</code>)，其中的 <code>apply()</code> 方法用于实例化伴生类。</p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot = <span class="type">RobotBuilder</span>()</div><div class="line">  .setName(<span class="string">"tyl"</span>)</div><div class="line">  .setCode(<span class="string">"89757"</span>)</div><div class="line">  .setBattery(<span class="number">99</span>)</div><div class="line">  .build()</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot: <span class="subst">$robot</span>"</span>)</div></pre></td></tr></table></figure></p>
<p>如果我们少写了 <code>setName</code> 或 <code>setCode</code> 函数，或者颠倒了顺序，编译器都会给出类似下方的错误：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Error</span>:(<span class="number">8</span>, <span class="number">13</span>) <span class="type">Cannot</span> prove that <span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">BuildStep</span> =:= <span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasCodeStep</span>.</div><div class="line">    .setName(<span class="string">"tyl"</span>)</div><div class="line"></div><div class="line">    <span class="type">Error</span>:(<span class="number">8</span>, <span class="number">13</span>) not enough arguments <span class="keyword">for</span> method setName: (<span class="keyword">implicit</span> ev: =:=[<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">BuildStep</span>,<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasCodeStep</span>])<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">RobotBuilder</span>[<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasNameStep</span>].</div><div class="line">    <span class="type">Unspecified</span> value parameter ev.</div><div class="line">        .setName(<span class="string">"tyl"</span>)</div></pre></td></tr></table></figure></p>
<p>因为能够支持在编译期间检查所编写的代码，所以对于需要检查类型的构造方式来说很可靠。</p>
<p>概括来说，<code>type safe</code> 版有如下的优缺点：</p>
<p>优点：</p>
<ul>
<li>对于严格按照顺序（存在相互依赖）的构造场景十分合适</li>
<li>泛化类型约束使得构造时不易出错</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于不需要构造顺序的构造场景来说画蛇添足</li>
<li>参数可变导致副作用</li>
<li>不够简洁</li>
</ul>
<p>Scala 是一门高可扩展性语言，同样也提供了语法帮助我们缓解上述方法的缺点。</p>
<h4 id="require-版"><a href="#require-版" class="headerlink" title="require 版"></a>require 版</h4><p>在 Scala 中我们可以使用 <code>require</code> 关键字进行函数参数限制，类似 Java 中的 <code>assert</code>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                  code:  <span class="type">String</span> = "",</div><div class="line">                  name: <span class="type">String</span> = "",</div><div class="line">                  battery :<span class="type">Int</span> = 0</div><div class="line">                  )&#123;</div><div class="line">  require(code != <span class="string">""</span>, <span class="string">"不可缺少 code 参数"</span>)</div><div class="line">  require(name != <span class="string">""</span>, <span class="string">"不可缺少 name 参数"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码非常简洁，并且也满足我们的需求，这才像函数式风格啊（另外数据验证我们也可以通过第三方类库 <code>refined</code> 来实现，感兴趣的同学可以看一看<a href="https://github.com/fthomas/refined" target="_blank" rel="external">refined: simple refinement types for Scala</a>！</p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">val</span> robot2 = <span class="type">Robot</span>(name = <span class="string">"Bat-Man"</span>)</div><div class="line">&#125;<span class="keyword">catch</span> &#123;</div><div class="line">  <span class="keyword">case</span> e :<span class="type">Throwable</span> =&gt; e.printStackTrace()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们在创建的时候少写参数，或者任何不符合 <code>require</code> 条件的行为都会导致抛出异常：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.<span class="type">IllegalArgumentException</span>: requirement failed: 不可缺少 code 参数</div><div class="line">	at scala.<span class="type">Predef</span>$.require(<span class="type">Predef</span>.scala:<span class="number">277</span>)</div><div class="line">	at <span class="type">Builder</span>.<span class="type">Scala</span>.require.<span class="type">Robot</span>.&lt;init&gt;(<span class="type">Robot</span>.scala:<span class="number">12</span>)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过以上的例子我们可以得出 Builder 模式使用的场景大致如下：</p>
<ul>
<li>当对象具有大量可选参数时。</li>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>
<p>另外，对比 Scala 和 Java 的实现，因为两者设计的初衷不同，所以也铸就了不同的语言特性。对于 Scala 而言，避免副作用是需要优先考虑的，当然 Scala 也有着很多语法糖来帮助开发者实现。<br>在 Java 和 Scala 中，实现 Buidler 模式的方式都很多，我们可以参考三种场景来选择恰当的方式实现，最大程度的提高开发效率。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Builder" target="_blank" rel="external">源码链接</a><br>如有错误和讲述不恰当的地方还请指出，不胜感激！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建者模式（Builder Pattern）支持以类方法而非类构造器的方式来创建实例。当一个类的构造器拥有多个版本以支持不同的用途时，这种模式尤其有用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（一）：Singleton 单例模式</title>
    <link href="http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/"/>
    <id>http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/</id>
    <published>2017-07-09T08:04:13.000Z</published>
    <updated>2017-07-12T23:14:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（<code>Singleton Pattern</code>）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<a id="more"></a>
<p>二十年前，软件设计领域的四位大师（GoF，“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson &amp; John Vlissides）通过论著《设计模式：可复用面向对象软件的基础》阐述了设计模式领域的开创性成果。设计模式（<code>Design Pattern</code>）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<p>在 2017 年的今天，虽然一些传统的设计模式仍然适用，但部分设计已经发生改变，甚至被全新的语言特征所取代。<br>本系列文章首先会介绍传统的设计模式在 Java 与 Scala 中的实现，之后会介绍 Scala 可以实现的 “新” 的设计模式。</p>
<p>本文将会简单介绍单例模式在 Java 中的实现方式，以及如何将单例模式应用在 Scala 中，通过比较来阐述单例模式。</p>
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#why-singleton">Why Singleton</a></li>
<li><a href="#结构图">结构图</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#饿汉-基础版">饿汉 —— 基础版</a></li>
<li><a href="#懒汉-基础版">懒汉 —— 基础版</a></li>
<li><a href="#懒汉-双重检查锁版double-checked-locking">懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</a></li>
<li><a href="#静态内部类版">静态内部类版</a></li>
<li><a href="#枚举类模式">枚举类模式</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#object">object</a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。  </p>
</blockquote>
<p>通俗一点单例类就是：全局可以访问的唯一实例。</p>
<h2 id="why-singleton"><a href="#Why-Singleton" class="headerlink" title="Why Singleton"></a>Why Singleton</h2><p>什么时候需要使用单例模式呢？ 如果某个类创建时需要消耗很多资源，即创建出这个类的代价很大时我们就需要使用单例模式。通俗的讲，我们可以将单例对象比作地球，因为很难创建出第二颗这样的星球，这时我们就需要共用地球。</p>
<p>在编写程序的时候，很多操作都会占用大量的资源，如：日志类、配置类、共享资源类等等，我们倡导节能减排，高效利用资源。所以，对于这些操作我们需要一个全局的可访问接口的实现（也可能是懒加载）。</p>
<p>但是我们如何才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但是它并不可以防止我们实例化多个对象。一个更有效的方法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求),并且它可以提供一个访问该实例的方法。这就是单例模式。  </p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://om6vvgjw7.bkt.clouddn.com/Singleton-dp.PNG" alt="singleton"></p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>单例模式应该是 Java 中最出名的设计模式，虽然 Java 语言中包含了静态关键词( <code>static</code>)，但是静态成员与任何对象都不存在直接联系，并且静态成员类不能实现接口。因此，静态方法的概念违背了 <a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">OOP</a> 的前提：所有东西都是对象。  </p>
<p>一般来说在 Java 中单例模式有两种形式：<strong>饿汉模式（eager）</strong>、<strong>懒汉模式(lazy)</strong> 。</p>
<h4 id="饿汉-基础版"><a href="#饿汉-——-基础版" class="headerlink" title="饿汉 —— 基础版"></a>饿汉 —— 基础版</h4><p>对于一个初学者来说，写出的第一个单例类应该是类似下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        HungrySingleton.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码中有了全局访问点，同时单例类也是静态的，看着也比较清晰。</p>
<p>运行测试代码后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HungrySingleton is created</div><div class="line">HungrySingleton is running</div></pre></td></tr></table></figure></p>
<p>从以上结果我们可以发现这种模式有一个缺点: 不是惰性初始化(<code>lazy initialization</code>)，即单例会在 JVM 加载单例类后一开始就被初始化，如果此时单例类在系统中还扮演其他角色，不管是否用到都会初始化这个单例变量。因为这种写法下单例会被立即初始化，所以我们称这种单例为 <strong>饿汉 (eager)</strong> 。</p>
<h4 id="懒汉-基础版"><a href="#懒汉-——-基础版" class="headerlink" title="懒汉 —— 基础版"></a>懒汉 —— 基础版</h4><p>为了解决上述的问题，我们就需要引入延迟加载。比较容易想到的做法是：在获取实例的时候判断实例是否存在，不存在则创建。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonOne</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonOne instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingletonOne();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LazySingletonOne.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LazySingletonOne is running</div></pre></td></tr></table></figure></p>
<p>可见这种形式在这样的环境下确实已经能满足我们的需求。但是在多线程环境下，缺点就非常明显：会出现创建出多个实例的情况（由于篇幅限制，测试代码见文末源码）。这时候通常的做法是在方法上加一个同步锁<br>（<code>synchronized</code>），但是仅仅这样就够了吗？</p>
<h4 id="懒汉-双重检查锁版double-checked-locking"><a href="#懒汉-——-双重检查锁版-Double-checked-locking" class="headerlink" title="懒汉 —— 双重检查锁版(Double-checked locking)"></a>懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</h4><p>在 <code>getInstance</code> 整个方法外加同步锁（<code>synchronized</code>），每次访会还是会造成很大的性能开销。我们就只能在方法的临界区做一些文章，<code>Double-checked locking</code> 应声而至。<br>我们先看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingletonTwo instance;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">// 第一次检查</span></div><div class="line">          <span class="keyword">synchronized</span> (LazySingletonTwo.class) &#123;</div><div class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">// 第二次检查</span></div><div class="line">                  instance = <span class="keyword">new</span> LazySingletonTwo();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance ;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>为了避开多次同步锁的开销，我们先判断单例实体是否存在再进行同步锁操作。这样虽然已经能应对大部分的问题，但是依然存在一个问题：其他线程可能会 <code>read</code> 初始化到一半的 <code>instance</code>。只有将 <code>instance</code> 设置为 <code>volatile</code> ，才能保证每次的 <code>write</code> 操作优先于 <code>read</code> 操作，即能确保每次引用到都是最新状态。<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl" target="_blank" rel="external">了解更多</a><br>只用将代码稍加改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// private static LazySingletonTwo instance;           ----old</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingletonTwo instance;  ----<span class="keyword">new</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong> ：我们至少要创建一个 <code>private</code> 构造器，否则编译器默认将为我们生成一个 <code>friendly</code> 的构造器，而非 <code>private</code>；其次，<code>instance</code> 成员变量和 <code>getInstance()</code> 方法必须是 <code>static</code> 的；如果单例类实现了 <code>java.io.Serializable</code> 接口，就可能被反序列化，从而产生新的实例。</p>
<h4 id="静态内部类版"><a href="#静态内部类版" class="headerlink" title="静态内部类版"></a>静态内部类版</h4><p>除了以上几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedSingleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明为 final 能防止其在派生类中被 clone</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticNestedSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">       System.out.println((<span class="string">"StaticNestedSingleton is created"</span>));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticNestedSingleton <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> NestedClass.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在第一次被引用时被加载</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticNestedSingleton instance = <span class="keyword">new</span> StaticNestedSingleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，我们将单例类设置为 <code>final</code> 类型，这样能够禁止克隆的发生。同样静态内部类只有在第一次被引用时才加载，即随着类的加载而产生（而不是随着对象的产生）。</p>
<h4 id="枚举类模式"><a href="#枚举类模式" class="headerlink" title="枚举类模式"></a>枚举类模式</h4><p>上面的几种使我们常见到的单例类形式，可能有的同学会抱怨道：有没有简短一点的？<br>当然我们还可以使用 Java 中的枚举类实现单例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] preference =</div><div class="line">            &#123; <span class="string">"intresting"</span>,<span class="string">"nice"</span>,<span class="string">"just so so"</span> &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Arrays.toString(preference));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 《Effictive Java》 中所推荐的单例模式在 Java 中的最佳实现方式，同时也是 Stack Overflow 中 <a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="external">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a> 最高票回答。</p>
<p>注意：<code>Enum</code> 与 <code>enum</code> 是不同的。后者只是 Java 1.5 后增加的一个语法糖，不是新的类型。 我们可以反编译 <code>EnumSingleton.class</code> 查看一下内部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ javap EnumSingleton.class</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span>&gt;</span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton.Java.EnumSingleton INSTANCE;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.EnumSingleton[]values();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.<span class="function">EnumSingleton <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">static</span> &#123;&#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>简单总结一下，选用 <code>enum</code> 原因如下：</p>
<ul>
<li><code>enum</code> 防止反序列化重新创建新的对象。</li>
<li>类的修饰 <code>abstract</code>，所以没法实例化，反射也无能为力。</li>
<li>关于线程安全的保证，其实是通过类加载机制来保证的，我们看看 <code>INSTANCE</code> 的实例化时机，是在 <code>static</code> 块中，JVM加载类的过程显然是线程安全的。</li>
</ul>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中并没有 <code>static</code> 关键字，你不用纠结太多，我们用 <code>object</code> 便能实现单例，再也不用为你的选择困难症烦恼！</p>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><code>object</code> 在 Scala 中被称作「伴生对象」 (Singleton Objects)。</p>
<p>object 关键字创建一个新的单例类型，就像一个 class 只有一个被命名的实例。如果你熟悉 Java ,在 Scala 中声明一个 object 有些像创建了一个匿名类的实例。     ——引自  Scala 函数式编程 </p>
<p>举个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singleton2Scala</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(l: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = l.sum</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="type">Singleton2Scala</span>.sum(<span class="type">List</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来是不是比 Java 优雅多了！  </p>
<p>你问有没有多线程问题？是否是惰性初始化？这些都不用你来处理。</p>
<p>Scala 被编译后生成 <code>&#39;Singleton2Scala$.class&#39;</code> 和  <code>Singleton2Scala.class</code>，我们可以对其进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ javap  &apos;Singleton2Scala$.class&apos;</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala$ &#123;</div><div class="line">  public static Singleton.Scala.Singleton2Scala$ MODULE$;</div><div class="line">  public static &#123;&#125;;</div><div class="line">  public int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">$ javap  Singleton2Scala.class</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala &#123;</div><div class="line">  public static int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上方代码我们能看到，所有的方法前都带上了 <code>static</code> 关键字。</p>
<p>在实际项目开发的时候，我们还可以继承其他 类 与 特质。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">xxClass</span> <span class="keyword">with</span> <span class="title">xxtrait</span></span>&#123;</div><div class="line">  println(<span class="string">"Registry initialization block called."</span>)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> lazyXX  = ???</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users: scala.collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>] =  scala.collection.mutable.<span class="type">HashMap</span>.empty</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addUser</span></span>(id: <span class="type">String</span>, name: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.put(id, name) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>(id: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.remove(id) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUserRegistered</span></span>(id: <span class="type">String</span>): <span class="type">Boolean</span> = users.contains(id)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAllUserNames</span></span>(): <span class="type">List</span>[<span class="type">String</span>] = users.map(_._2).toList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比 <code>static class</code> 更易于理解  </li>
<li>语法简洁</li>
<li>按需初始化(<code>lazy initialization</code>)</li>
<li>线程安全(Scala 中不用考虑 <code>double-checked locking</code>)  </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>缺乏对初始化行为的控制  </li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是对 Scala 和 Java 是实现单例模式的一个简单比较：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Java</th>
<th style="text-align:center">Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td><code>static</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>多线程</td>
<td><code>synchronized</code> +  <code>volatile</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>延迟加载</td>
<td><code>enum</code> 、 <code>double-checked locking</code></td>
<td style="text-align:center"><code>object</code> + <code>lazy</code>(内部参数延迟加载)</td>
</tr>
</tbody>
</table>
<p>人们对单例模式的看法褒贬不一，甚至被称为是 <code>anti-pattern</code> (反面模式）。如果你是一名 Java 开发者，可能 Spring 框架中 <code>Dependency Injection</code> 是你的更优先的选择。但是单例模式你不能否认的是单例模式在 Android SDK 中得到了广泛的应用。在 Scala 中，伴生对象出现的频率更是非常之高。当你面对的业务场景需要用到单例模式的时候，请务必注意 <strong>多线程</strong> 与 <strong>性能开销</strong> 的问题。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples" target="_blank" rel="external">源码链接</a><br>如有说错的地方还请指出，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（&lt;code&gt;Singleton Pattern&lt;/code&gt;）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web前端模块化发展历程</title>
    <link href="http://prefer-tyl.site/2017/06/27/front-page-modular-history/"/>
    <id>http://prefer-tyl.site/2017/06/27/front-page-modular-history/</id>
    <published>2017-06-27T12:00:13.000Z</published>
    <updated>2017-06-27T15:24:03.892Z</updated>
    
    <content type="html"><![CDATA[<p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是模块化">1. 什么是模块化</a></li>
<li><a href="#2-为什么要模块化">2. 为什么要模块化</a></li>
<li><a href="#3-web-前端的模块化的历史浪潮">3. Web 前端的模块化的历史浪潮</a><ul>
<li><a href="#31-发展历史">3.1 发展历史</a></li>
<li><a href="#311-函数封装">3.1.1 函数封装</a></li>
<li><a href="#312-对象">3.1.2 对象</a></li>
<li><a href="#313-立即执行函数immediately-invoked-function-expression">3.1.3 立即执行函数(immediately-invoked function expression )</a></li>
<li><a href="#314-script-loader">3.1.4 Script Loader</a><ul>
<li><a href="#labjs">LABjs</a></li>
<li><a href="#commonjs">CommonJS</a></li>
<li><a href="#双塔奇兵-amdcmd">双塔奇兵 AMD/CMD</a></li>
</ul>
</li>
<li><a href="#32-解决方案">3.2 解决方案</a><ul>
<li><a href="#webpack">Webpack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-未来的模块化">4. 未来的模块化</a><ul>
<li><a href="#webassembly-是什么">WebAssembly 是什么</a></li>
<li><a href="#webassembly-的目标">WebAssembly 的目标</a></li>
<li><a href="#webassembly-的核心">WebAssembly 的核心</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1. 什么是模块化"></a>1. 什么是模块化</h2><p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
<h2 id="2-为什么要模块化"><a href="#2-为什么要模块化" class="headerlink" title="2. 为什么要模块化"></a>2. 为什么要模块化</h2><p>随着互联网的飞速发展，新的前端框架与技术不断涌现。这些框架在带给开发者便利的同时，也带去了维护困难的隐患———项目逻辑的复杂化与代码库膨胀。我们可以将原因概括为以下三点：  </p>
<ul>
<li>Web 网站正在转变为 Web 应用  </li>
<li>网站规模越大，代码也越来越复杂   </li>
<li>高度解耦的 JS 文件被大家所需求<br>前端开发领域(<code>JavaScript</code>、<code>CSS</code>、<code>Template</code>)并没有为开发者们提供以一种简洁、有条理地的方式来管理模块的方法。为了解决以上问题，我们必须进行合理的模块化管理。  </li>
</ul>
<p>熟悉 Java 语言的同学都知道，在 Java 中有一个重要的概念——<code>package</code> (包)，我们会将相同逻辑的代码放到一个 <code>package</code> 下，在需要的地方 <code>import</code> (引入)即可。    </p>
<p>前端是否有类似 <code>package</code> 的概念呢？  </p>
<h2 id="3-web-前端的模块化的历史浪潮"><a href="#3-Web-前端的模块化的历史浪潮" class="headerlink" title="3. Web 前端的模块化的历史浪潮"></a>3. Web 前端的模块化的历史浪潮</h2><h3 id="31-发展历史"><a href="#3-1-发展历史" class="headerlink" title="3.1 发展历史"></a>3.1 发展历史</h3><p>由于 JavaScript 这门语言设计用时非常短，所以很多方面都没有考虑周全。好在它的生态圈非常强大，广大开发者为了更好的使用它，对它不断优化。</p>
<h3 id="311-函数封装"><a href="#3-1-1-函数封装" class="headerlink" title="3.1.1 函数封装"></a>3.1.1 函数封装</h3><p>  最早期的时候，我们在一个文件里编写相关函数，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要的时候加载文件并调用相关函数即可。<br><strong>缺点：Global 被污染，代码中很容易出现命名冲突。</strong>  </p>
<h3 id="312-对象"><a href="#3-1-2-对象" class="headerlink" title="3.1.2 对象"></a>3.1.2 对象</h3><p>为了解决上面的问题，我们又将一个个文件划分为一个个对象，这样在加载的时候就不用加载很多文件。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MYAPP = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">MYAPP.foo(); <span class="comment">//需要时执行</span></div></pre></td></tr></table></figure></p>
<p>这样虽然能减少 Global 上的变量数目，避免变量污染。但是<strong>本质是对象，外部对象可以对其他对象进行修改，很不安全</strong>。  </p>
<h3 id="313-立即执行函数immediately-invoked-function-expression"><a href="#3-1-3-立即执行函数-immediately-invoked-function-expression" class="headerlink" title="3.1.3 立即执行函数(immediately-invoked function expression )"></a>3.1.3 立即执行函数(immediately-invoked function expression )</h3><blockquote>
<p>IIFE (立即调用函数表达式) 是一个 JavaScript 函数 ，它会在定义时立即执行.<br>也有人将 IIFE 称为匿名闭包.</p>
</blockquote>
<p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _private = <span class="string">"safe now"</span>;</div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_private)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: foo</div><div class="line">    &#125;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">Module.foo();</div><div class="line">Module._private; <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>我们可以调用定义的方法，但是不能调用定义的属性。这样的模式使得变量冲突降到最低，并且能够控制暴露的方法(类似于接口）。这便是现代模块实现的基石！  </p>
<h3 id="314-script-loader"><a href="#3-1-4-Script-Loader" class="headerlink" title="3.1.4 Script Loader"></a>3.1.4 Script Loader</h3><p>最原始的 JS 加载方法就是在 Html 头文件中通过 Script 标签直接引入，类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"http://remote.tld/jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/plugin1.jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/plugin2.jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/init.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	initMyPage();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>初学者可能会有疑问，全都写在一个文件中看着不是挺方便的吗？<br>首先以上列举的可能只是实际项目中的一小部分，其次不要忽视 <code>&lt;script&gt;</code> 的一个特点：<code>并行加载，顺序执行</code>，这要求开发者需要按照严格的读取顺序，并且很有可能会阻塞阻止文档渲染(<code>async</code> 新特性在 HTML5 中才提出)。文件少的时候写起来会很方便，一旦项目变复杂缺点就会暴露无疑：<strong>难以维护，依赖模糊，请求过多</strong> 。  </p>
<h4 id="labjs"><a href="#LABjs" class="headerlink" title="LABjs"></a>LABjs</h4><p>为了解决依赖模糊，我们迫切需要一个加载器（<code>Loader</code>）最先出现在开发者视野中的 <code>Loader</code> 应该是 <a href="https://github.com/getify/LABjs]" target="_blank" rel="external"><code>LABjs</code></a>(2009)（ HTML5 发布才有了 <code>async</code> 特性）</p>
<blockquote>
<p>LABjs 的核心是 LAB（Loading and Blocking）：Loading 指异步并行加载，Blocking 是指同步等待执行。  </p>
</blockquote>
<p>通过使用 LABjs ,上方代码就可以变成这样：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"LAB.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  $LAB</div><div class="line">  .script(<span class="string">"http://remote.tld/jquery.js"</span>).wait()<span class="comment">//`.wait` 表示加载后立即运行</span></div><div class="line">  .script(<span class="string">"/local/plugin1.jquery.js"</span>)</div><div class="line">  .script(<span class="string">"/local/plugin2.jquery.js"</span>).wait()</div><div class="line">  .script(<span class="string">"/local/init.js"</span>).wait(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      initMyPage();</div><div class="line">  &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>当然同一时期风靡的还有类库模块化框架 <a href="https://yuilibrary.com/" target="_blank" rel="external">YUI</a>，大家可自行查阅。</p>
<h4 id="commonjs"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>在开发者们拼命为浏览器兼容等问题绞尽脑汁的时候，CommonJS 横空出世！<br>服务器端的 <code>Node.js</code> 遵循 <a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">CommonJS规范</a>，该规范的核心思想是允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</div><div class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">module</span>.exports = someValue;</div></pre></td></tr></table></figure>
<p>这是 JavaScript 第一次真正意义上跳出浏览器，被人们尊称为模块化的第一座里程碑（<code>MODULES/1.0</code>）。给开发者们带来了以下便捷之处：</p>
<p>优点:  </p>
<ul>
<li>服务器端模块便于重用  </li>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">NPM</a> 中已经有将近20万个可以使用模块包  </li>
<li>简单并容易使用  </li>
</ul>
<p>缺点：  </p>
<ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的  </li>
<li>不能非阻塞的并行加载多个模块  </li>
</ul>
<p>实现:  </p>
<ul>
<li>NodeJS</li>
</ul>
<h4 id="双塔奇兵-amdcmd"><a href="#双塔奇兵-AMD-CMD" class="headerlink" title="双塔奇兵 AMD/CMD"></a>双塔奇兵 AMD/CMD</h4><table>
<thead>
<tr>
<th>-</th>
<th style="text-align:left">AMD</th>
<th style="text-align:left">CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念</td>
<td style="text-align:left"><a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="external">Asynchronous Module Definition</a> 规范其实只有一个主要接口 <code>define(id?, dependencies?, factory)</code>，它要在声明模块的时候指定所有的依赖 <code>dependencies</code>，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</td>
<td style="text-align:left"><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="external">Common Module Definition</a> 规范和 AMD 很相似，尽量保持简单，并与 <code>CommonJS</code> 和 <code>Node.js</code> 的 <code>Modules 规范</code> 保持了很大的兼容性。</td>
</tr>
<tr>
<td>优点</td>
<td style="text-align:left">1. 适合在浏览器环境中异步加载模块<br> 2. 可以并行加载多个模块</td>
<td style="text-align:left">1. 依赖就近，延迟执行 <br> 2. 可以很容易在 Node.js 中运行</td>
</tr>
<tr>
<td>缺点</td>
<td style="text-align:left">1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅<br> 2. 不符合通用的模块化思维方式，是一种妥协的实现</td>
<td style="text-align:left">依赖 SPM 打包，模块的加载逻辑偏重</td>
</tr>
<tr>
<td>实现</td>
<td style="text-align:left"><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a></td>
<td style="text-align:left"><a href="http://seajs.org/" target="_blank" rel="external">SeaJS</a></td>
</tr>
</tbody>
</table>
<p>两者最明显的区别可以从以下代码中查看：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</span></div><div class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    a.doSomething();    <span class="comment">// 依赖前置，提前执行</span></div><div class="line">    b.doSomething();</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//CMD 推崇依赖就近，只有在用到某个模块的时候再去require  </span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"a"</span>);</div><div class="line">    a.doSomething();</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"b"</span>);</div><div class="line">    b.doSomething();    <span class="comment">// 依赖就近，延迟执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>概括而言 Commonjs 用在服务器端，加载是同步的。<br>AMD, CMD 用在浏览器端，加载是异步的。  </p>
<p><code>CommonJS</code> (规划并标准化、致力于设计 JavaScript API)的诞生开启了 “JavaScript 模块化” 的时代。<code>CommonJS</code> 的模块提案为在服务器端的 JavaScript 模块化做出了很大的贡献，但是在浏览器下的 JavaScript 模块应用很有限。随之而来又诞生了其它前端领域的模块化方案，像 requireJS、SeaJS 等，然而这些模块化方案并不是十分适用 ，并没有从根本上解决模块化的问题。</p>
<h3 id="32-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h3><p>前面已经为大家回顾了 JavaScript 的模块化发展历史，然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。如果他们都可以视作模块，并且都可以通过 <code>require</code> 的方式来加载，将带来优雅的开发体验，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>那么如何做到让 <code>require</code> 能加载各种资源呢？  </p>
<h4 id="webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack</a> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
</blockquote>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/what-is-webpack.png" alt="webpack">  </p>
<p>Webpack 的优点可以概括为以下几点：  </p>
<ul>
<li><p><strong>代码拆分</strong><br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。  </p>
</li>
<li><p><strong>Loader</strong><br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。  </p>
</li>
<li><p><strong>智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。  </p>
</li>
<li><p><strong>插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。  </p>
</li>
<li><p><strong>快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。    </p>
</li>
</ul>
<p>当然，光有 <code>Webpack</code> 是不够的，目前大家比较推崇的最佳拍档为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">包管理工具</th>
<th style="text-align:center">模块化构建工具</th>
<th style="text-align:center">模块化规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">npm</td>
<td style="text-align:center">Webpack</td>
<td style="text-align:center">ES6模块</td>
</tr>
</tbody>
</table>
<p>当然，目前比较有许多 “自带模块化buff” 的前端框架（组件化）：<code>Vue</code> 、 <code>React</code>等，它们都有以下特点:  </p>
<ul>
<li>使用 Virtual DOM  </li>
<li>提供了响应式（ Reactive ）和组件化（ Composable ）的视图组件。  </li>
<li>保持注意力集中在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。    </li>
</ul>
<p>在 <code>Vue</code> 中，一个组件文件(<code>.Vue</code>)中，拥有<code>&lt;template&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;style&gt;</code>三个部分。每个组件中管理自己的样式、逻辑，这样在大型项目开发与维护时都起到了非常便捷的作用。  </p>
<h2 id="4-未来的模块化"><a href="#4-未来的模块化" class="headerlink" title="4. 未来的模块化"></a>4. 未来的模块化</h2><p>说到模块化未来的发展，值得一提的便是 <a href="http://webassembly.org/" target="_blank" rel="external">WebAssembly</a>。大家都知道 <code>JavaScript</code> 是一种解释性脚本语言，导致其运行时消耗大量的性能做为代价，这也是 <code>JavaScript</code> 的瓶颈之一。<code>WebAssembly</code> 旨在解决这个问题。  </p>
<h3 id="webassembly-是什么"><a href="#WebAssembly-是什么" class="headerlink" title="WebAssembly 是什么"></a>WebAssembly 是什么</h3><blockquote>
<p> Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.<br>定义一个可移植，体积紧凑，加速迅捷的二进制格式为编译目标，而此二进制格式文件将可以在各种平台（包括移动设备和物联网设备）上被编译，然后发挥通用的性能以原生应用的速度运行。</p>
</blockquote>
<h3 id="webassembly-的目标"><a href="#WebAssembly-的目标" class="headerlink" title="WebAssembly 的目标"></a>WebAssembly 的目标</h3><p>某乎上广传 “谷歌、苹果、谋智、微软一起再一次发明了 Silverlight ”。可以看出，大家对 <code>WebAssembly</code> 充满了信心与期待。  </p>
<p>作为 <a href="https://www.w3.org/community/webassembly" target="_blank" rel="external">W3C WebAssembly Community Group</a> 中的一项开放标准，WebAssembly 是为下列目标而生的：</p>
<ul>
<li>快速、高效、可移植——通过利用常见的硬件能力，WebAssembly 代码在不同平台上能够以接近本地速度运行。  </li>
<li>可读、可调试—— WebAssembly 是一门低阶语言，但是它有确实有一种人类可读的文本格式（其标准即将得到最终版本），这允许通过手工来写代码，看代码以及调试代码。   </li>
<li>保持安全—— WebAssembly 被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略。  </li>
<li>不破坏网络—— WebAssembly 的设计原则是与其他网络技术和谐共处并保持向后兼容。  </li>
</ul>
<h3 id="webassembly-的核心"><a href="#WebAssembly-的核心" class="headerlink" title="WebAssembly 的核心"></a>WebAssembly 的核心</h3><p>那么 WebAssembly 是如何在浏览器中运行的呢？我们可以看一下它的几个关键的概念：  </p>
<ul>
<li><strong>模块</strong> : 表示一个已经被浏览器编译为可执行机器码的 WebAssembly 二进制代码。一个模块是无状态的并且像一个二进制大对象（Blob）一样能够被缓存到 IndexedDB 中或者在 windows 和 workers 之间进行共享（通过 <code>postMessage()</code> 函数）。一个模块能够像一个 ES2015的模块一样声明导入和导出。   </li>
<li><strong>内存</strong> : 一个可变大小的 ArrayBuffer 。它包含了一个连续的字节数组并且 WebAssembly 的低级内存存取指令可对其进行读写操作。  </li>
<li><strong>表格</strong> : 一个可变大小的包含引用类型（比如，函数）的带类型数组。它包含了不能作为原始字节存储在内存中的引用（为了安全和可移植性的原因）。  </li>
<li><strong>实例</strong> : 一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。一个实例就像一个已经被加载到一个拥有一组特定导入的特定的全局变量的 ES2015模块。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面重构应该遵循的基本原则和规范</title>
    <link href="http://prefer-tyl.site/2017/04/30/restructure-web-page/"/>
    <id>http://prefer-tyl.site/2017/04/30/restructure-web-page/</id>
    <published>2017-04-30T00:30:13.000Z</published>
    <updated>2017-06-27T13:06:56.455Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是页面重构">1. 什么是页面重构？</a></li>
<li><a href="#2-基本原则和规范">2. 基本原则和规范</a><ul>
<li><a href="#21-常用规范">2.1 常用规范</a></li>
<li><a href="#22-语义化-seo">2.2 语义化 &amp;&amp; SEO</a><ul>
<li><a href="#221-什么是语义化">2.2.1 什么是语义化</a></li>
<li><a href="#222-为什么要让页面语义化">2.2.2 为什么要让页面语义化</a></li>
<li><a href="#223-html-语义化">2.2.3 HTML 语义化</a></li>
<li><a href="#224-css-命名语义化">2.2.4 CSS 命名语义化</a></li>
</ul>
</li>
<li><a href="#23-样式抽离-组件复用">2.3 样式抽离 &amp;&amp; 组件复用</a></li>
</ul>
</li>
<li><a href="#3-总结">3. 总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是页面重构"><a href="#1-什么是页面重构？" class="headerlink" title="1. 什么是页面重构？"></a>1. 什么是页面重构？</h2><p>简单来说，页面重构就是：<strong>将设计稿转换成 WEB 页面</strong>。  </p>
<p>那我们重构时该注意哪些东西呢？  </p>
<h2 id="2-基本原则和规范"><a href="#2-基本原则和规范" class="headerlink" title="2. 基本原则和规范"></a>2. 基本原则和规范</h2><p>在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护。  </p>
<h3 id="21-常用规范"><a href="#2-1-常用规范" class="headerlink" title="2.1 常用规范"></a>2.1 常用规范</h3><p>与使用其他语言开发工程一样，我们需要有着统一的规范，最常见就是 <strong>编码风格</strong>，比如：  </p>
<ol>
<li><p><strong>空格</strong>  </p>
<ul>
<li>等号前后空格、运算符前后使用空格分隔   </li>
<li>在逗号和冒号后添加空格  </li>
</ul>
</li>
<li><p><strong>空行</strong>  </p>
<ul>
<li>为每个逻辑功能块添加空行，这样更易于阅读    </li>
<li>将左花括号与选择器放在同一行  </li>
<li>将右花括号独立放在一行，并以分号作为结束符号  </li>
</ul>
</li>
<li><p><strong>缩进</strong>  </p>
<ul>
<li>缩进使用两个空格(不要使用制表符)    </li>
</ul>
</li>
</ol>
<p>其次是 <strong>命名</strong>，我们建议对 HTML 元素名称，属性，属性值，CSS 选择器，属性和属性值（字符串除外）使用小写字母命名，并且使用 <code>-</code> 进行分隔，举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">id</span>=<span class="string">"href-index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span>  </div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#E5E5E5</span>;  </div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#e5e5e5</span>;</div></pre></td></tr></table></figure>
<p>另外还有书写顺序，比较常见的 CSS 样式书写顺序如下：  </p>
<ol>
<li>位置属性(<code>position</code>, <code>top</code>, <code>right</code>, <code>z-index</code>, <code>display</code>, <code>float</code> 等)  </li>
<li>大小(<code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>)  </li>
<li>文字系列( <code>font</code>, <code>line-height</code>, <code>letter-spacing</code>, <code>color</code>, <code>text-align</code> 等)  </li>
<li>背景(<code>background</code>, <code>border</code> 等)  </li>
<li>其他(<code>animation</code>, <code>transition</code> 等)  </li>
</ol>
<p>以上仅列举了部分规范，更多请参考 <a href="http://eslint.cn/docs/rules/" target="_blank" rel="external">ESLint</a>  </p>
<h3 id="22-语义化-ampamp-seo"><a href="#2-2-语义化-amp-amp-SEO" class="headerlink" title="2.2 语义化 &amp;&amp; SEO"></a>2.2 语义化 &amp;&amp; SEO</h3><h4 id="221-什么是语义化"><a href="#2-2-1-什么是语义化" class="headerlink" title="2.2.1 什么是语义化"></a>2.2.1 什么是语义化</h4><blockquote>
<p>语义化是指使用恰当语义的 HTML 标签、class 类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。  </p>
</blockquote>
<h4 id="222-为什么要让页面语义化"><a href="#2-2-2-为什么要让页面语义化" class="headerlink" title="2.2.2 为什么要让页面语义化"></a>2.2.2 为什么要让页面语义化</h4><p>语义化的好处 ：  </p>
<ul>
<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构  </li>
<li><strong>有利于</strong> <a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="external">SEO</a> ( Search Engine Optimization——搜索引擎优化)：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重    </li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以特殊的方式来渲染网页     </li>
<li>便于团队开发和维护，可以减少很多差异化，减少成员间沟通成本，方便开发和后期维护，利于实现模块化开发</li>
</ul>
<h4 id="223-html-语义化"><a href="#2-2-3-HTML-语义化" class="headerlink" title="2.2.3 HTML 语义化"></a>2.2.3 HTML 语义化</h4><p>假设我们要开发一个页面，在 HTML5 出现之前，页面架构很有可能是下面这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%89%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的架构缺点比较明显：  </p>
<ul>
<li>需要用到很多 <code>div</code> 标签,但实际上 <code>div</code> 标签并没有语义，这不利于爬虫对页面内容进行抓取  </li>
<li>文档结构不明确。也许你认为有 <code>id</code> 就足够了，但是后面会发现在一大堆 <code>&lt;div&gt;</code> 中找出这些 <code>id</code> 并不高效</li>
</ul>
<p>于是，在 HTML5 中，页面架构变成了这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%90%8E%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的结构看起来就清晰多了，我们可以直接从标签名称得知它的作用。  </p>
<p>当然，我们也不是说将所有的 <code>div</code> 全部替换为对应的语义化标签(比如考虑到网页兼容问题)，具体情况应具体分析。  </p>
<p>根据应用场景，一些常用的标签元素有：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">主要语义</th>
<th style="text-align:left">元素名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">本身无语义，组合其他 HTML 元素，常用于页面布局</td>
<td style="text-align:left"><code>div</code></td>
</tr>
<tr>
<td style="text-align:left">设置文本，填充段落</td>
<td style="text-align:left"><code>h1~h6</code>, <code>p</code>, <code>span</code>, <code>strong</code>, <code>em</code>…</td>
</tr>
<tr>
<td style="text-align:left">表现列表</td>
<td style="text-align:left"><code>ul</code>, <code>li</code>, <code>ol</code>, <code>dl</code>, <code>dt</code>, <code>dd</code></td>
</tr>
<tr>
<td style="text-align:left">表单相关</td>
<td style="text-align:left"><code>form</code>,<code>input</code>,<code>select</code>,<code>button</code></td>
</tr>
<tr>
<td style="text-align:left">表格相关</td>
<td style="text-align:left"><code>table</code>,<code>thead</code>,<code>tbody</code>,<code>tfoot</code>,<code>th</code>,<code>tr</code>,<code>td</code></td>
</tr>
<tr>
<td style="text-align:left">图像显示</td>
<td style="text-align:left"><code>img</code>, <code>canvas</code></td>
</tr>
<tr>
<td style="text-align:left">打开链接，发送邮件，段落跳转</td>
<td style="text-align:left"><code>a</code></td>
</tr>
</tbody>
</table>
<h4 id="224-css-命名语义化"><a href="#2-2-4-CSS-命名语义化" class="headerlink" title="2.2.4 CSS 命名语义化"></a>2.2.4 CSS 命名语义化</h4><p>CSS 命名的语义就是 <code>class</code> 和 <code>id</code> 命名的语义。<br><code>class</code> 属性作为 HTML 与 CSS 衔接的纽带，其本意是用来描述元素内容的。指用易于理解的名称对 HTML 标签附加的 <code>class</code> 或 <code>id</code> 命名。如果说 HTML 语义化标签是给机器看的，那么 CSS 命名的语义化就是给人看的。良好的 CSS 命名方式减少沟通调试成本，易于理解。  </p>
<p>CSS 命名首先要满足 W3C 的命名规范和团队的命名规范。其次是高效和可重用性。  </p>
<p>就好像 <code>.main</code> / <code>.sidebar</code> 会比 <code>.left_content</code> / <code>.right_content</code> 的 class 命名灵活性更好。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 以表现为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"lr margin10"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 以信息为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"user-info"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="23-样式抽离-ampamp-组件复用"><a href="#2-3-样式抽离-amp-amp-组件复用" class="headerlink" title="2.3 样式抽离 &amp;&amp; 组件复用"></a>2.3 样式抽离 &amp;&amp; 组件复用</h3><p>在后端开发中，我们常常将一些公共的字符串、函数等抽离出来，在需要的地方便可方便的调用。前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>在 前端模块化 的历史演变中，曾有一段时期我们会这样构造组件：  </p>
<ul>
<li><strong>base</strong> 提供最底层的、功能和粒度最小的的通用类样式，可以被所有页面引用  </li>
<li><strong>common</strong> 出现频率高，功能相对独立的组件，如 <code>Button</code>、<code>Dialog</code>、<code>Tooltip</code> 等  </li>
<li><strong>page</strong> 各页面独有的样式，实际中可划分为 <code>page-index.css</code> 、<code>page-dashboard.css</code> 等  </li>
</ul>
<p>但是随着工程的逐渐壮大，使用及维护起来还是比较困难。我们期望 组件/样式 有着 “按需引入，即插即用” 的特性。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>为了实现这样的引入方式，我们需要使用 Loader 。  </p>
<p>Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 <code>require</code> 来加载任何类型的模块或文件。  </p>
<p>如果我们要在 <code>index.html</code> 引入一个 CSS 文件 <code>style.css</code>，首页将 <code>style.css</code> 也看成是一个模块，然后用 <code>css-loader</code> 来读取它，再用 <code>style-loader</code> 把它插入到页面中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* style.css */</div><div class="line">body &#123; background: yellow; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"!style-loader!css-loader!./style.css"</span>) <span class="comment">// 载入 style.css</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>安装 loader :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://vuefe.cn/v2/guide/index.html" target="_blank" rel="external">Vue.js</a> 中，我们可以将 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 都写于一个 <code>.vue</code> 格式的文件中，一个文件便对应一个组件，并且可以在其他组件中很方便的引入。  </p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>当然，除了以上几点，我们需要遵循的原则和规范还很多。总的来说，页面重构时，在规范编码的基础上我们首先考虑的因素便是语义化：HTML 标签语义化、CSS 命名语义化等等。语义化的最终目的就是使得人与机器对页面识别度更高。其次，为了方便协作与后期维护，我们应该考虑组件复用、样式抽离，或者说模块化等。原则和规范并不总是一成不变的，随着前端技术的快速发展，高效、便于协作与维护的方式便是最佳原则与规范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

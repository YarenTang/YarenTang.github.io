<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prefert</title>
  <subtitle>prefer-tyl</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prefer-tyl.site/"/>
  <updated>2017-11-29T16:42:12.649Z</updated>
  <id>http://prefer-tyl.site/</id>
  
  <author>
    <name>Prefert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dive Into Kotlin（二）：kotlin 类型结构设计</title>
    <link href="http://prefer-tyl.site/2017/11/30/kotlin-1/"/>
    <id>http://prefer-tyl.site/2017/11/30/kotlin-1/</id>
    <published>2017-11-30T00:04:13.000Z</published>
    <updated>2017-11-29T16:42:12.649Z</updated>
    
    <content type="html"><![CDATA[<p>无论在静态语言还是动态语言中，「类型系统」都起到了至关重要的作用。<br><a id="more"></a></p>
<h4 id="类型系统简介"><a href="#类型系统简介" class="headerlink" title="类型系统简介"></a>类型系统简介</h4><blockquote>
<p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。</p>
<p>类型可以确认一个值或者一组值具有特定的意义和目的（虽然某些类型，如抽象类型和函数类型，在程序运行中，可能不表示为值）。</p>
</blockquote>
<h4 id="类型系统的作用"><a href="#类型系统的作用" class="headerlink" title="类型系统的作用"></a>类型系统的作用</h4><p>类型系统在各种语言之间存在比较大的差异。最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。</p>
<p>但是他们的目的都是一致的：</p>
<p><strong>1. 安全</strong>，有了类型系统以后就可以实现类型安全，这时候程序就变成了一个严格的数学证明过程，编译器可以机械地验证程序某种程度的正确性，从而杜绝很多错误的发生。比如：Scala、Java。但是 JavaScript 等动态语言/弱类型语言就要借助其他插件（如 ESLint）来提示语法等错误。</p>
<p><strong>2. 抽象能力</strong>。在安全的前提下，一个强大的类型系统的标准是抽象能力，能将程序中的很多东西纳入安全的类型系统中进行抽象，这在安全性的前提下又不损耗灵活性，甚至性能也能很优化。动态语言的抽象能力可以很强，但安全性和性能就不行了。泛型、高阶函数（闭包）、类型类、<code>Monad</code>、<code>Lifetime</code>（Rust） 属于这一块。</p>
<p><strong>3. 工程能力</strong>，一个强类型的编程语言比动态类型的语言更适合大规模软件的构建，哪怕不存在性能问题，但是同样取决于前两点。</p>
<blockquote>
<p>Hint: 想深入了解类型系统的朋友可以参考 <a href="http://www.cs.colorado.edu/~bec/courses/csci5535/reading/cardelli-typesystems.pdf" target="_blank" rel="external">《Type Systems》</a>和 <a href="http://www.ling.ohio-state.edu/~pollard.4/type/books/pierce-tpl.pdf" target="_blank" rel="external">《Types and Programming》</a></p>
</blockquote>
<p>Kotlin 作为一门静态类型编程语言，同样拥有着强大的类型系统。</p>
<p><img src="kotlin-types.png" alt="Kotlin types"></p>
<h2 id="kotlin-的类型系统"><a href="#Kotlin-的类型系统" class="headerlink" title="Kotlin 的类型系统"></a>Kotlin 的类型系统</h2><h3 id="11-基本数据类型-intboolean-及其他"><a href="#1-1-基本数据类型-——-Int-Boolean-及其他" class="headerlink" title="1.1 基本数据类型 —— Int,Boolean 及其他"></a>1.1 基本数据类型 —— Int,Boolean 及其他</h3><p>我们都知道，Java 将 <strong>基本数据类型</strong> 和 <strong>引用类型</strong> 做了区分：</p>
<ul>
<li>基本数据类型，例如 int 的变量直接存储了它的值，我们不能对这些值调用方法，或者把它们放到集合中。</li>
<li>引用类型的变量存储的是指向包含该对象的内存地址的引用。</li>
</ul>
<p>在 Kotlin 中，并不区分基本数据类型和包装类型——你使用的永远是同一个类型。  </p>
<h3 id="12-数字转换"><a href="#1-2-数字转换" class="headerlink" title="1.2 数字转换"></a>1.2 数字转换</h3><p>Kotlin 中我们必须使用 <strong>显示转换</strong> 来对数字进行转换,例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> z = <span class="number">13</span></div><div class="line">  println(z.toLong() <span class="keyword">in</span> list(<span class="number">2</span>L, <span class="number">0</span>L, <span class="number">3</span>L))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果觉得这种方式不够简便，你也可以尝试使用 Kotlin 中的字面量：</p>
<ul>
<li>使用后缀 <code>L</code> 表示 <code>Long</code>: <code>123L</code></li>
<li>使用后缀 <code>F</code> 表示 <code>Float</code>: <code>.123f</code>、<code>1e3f</code></li>
<li>使用前缀 <code>0x</code> / <code>0X</code> 表示十六进制：<code>0xadcL</code>  </li>
<li>…</li>
</ul>
<p><strong>当你使用数字字面值去初始化一个类型已知的变量时，又或是把字面值作为实参传给函数时</strong> ，会发生隐式转换，并且算数运算符会被重载。<br>例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">long</span><span class="params">(l: <span class="type">Long</span>)</span></span> = println(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// Int -&gt; Byte</span></div><div class="line">  <span class="keyword">val</span> l = b + <span class="number">1</span>L</div><div class="line">  foo(<span class="number">234</span>) <span class="comment">// Int 隐式转换 为 Long</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-通用类型系统-any-any"><a href="#1-3-通用类型系统-——-Any-Any" class="headerlink" title="1.3 通用类型系统 —— Any, Any?"></a>1.3 通用类型系统 —— Any, Any?</h3><p>和 <code>Object</code> 作为 Java 类层级结构的顶层类似，<code>Any</code> 类型是 Kotlin <strong>所有非空类型</strong> 的超类（ex: String, Int)。</p>
<center><img src="top-1.png" alt="Kotlin types"></center>

<p>与 Java 不同的是： Kotlin 不区分「原始类型」（primitive type）和其它的类型。它们都是同一类型层级结构的一部分。</p>
<p>如果定义了一个没有指定父类型的类型，则该类型将是 <code>Any</code> 的直接子类型:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>(<span class="keyword">val</span> ripeness: <span class="built_in">Double</span>)</div></pre></td></tr></table></figure></p>
<center><img src="top-2.png" alt="Kotlin types"></center>  

<p>如果你为定义的类型指定了父类型，则该父类型将是新类型的直接父类型，并且新类型的最终祖先为 <code>Any</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>(<span class="keyword">val</span> ripeness: <span class="built_in">Double</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span></span>(ripeness: <span class="built_in">Double</span>, <span class="keyword">val</span> bendiness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peach</span></span>(ripeness: <span class="built_in">Double</span>, <span class="keyword">val</span> fuzziness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness)</div></pre></td></tr></table></figure>
<center><img src="top-3.png" alt="Kotlin types"></center>  

<p>如果你的类型实现了多个接口，那么它将具有多个直接的父类型，而 <code>Any</code> 同样是最终的祖先。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICanGoInASalad</span></span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICanBeSunDried</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tomato</span></span>(ripeness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness),</div><div class="line">    ICanGoInASalad,</div><div class="line">    ICanBeSunDried</div></pre></td></tr></table></figure>
<center><img src="top-4.png" alt="Kotlin types"></center>

<p>Kotlin 的类型检查器实施父类型/子类型关系。</p>
<p>例如你可以将子类型值存储到父类型变量中：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f: Fruit = Banana(bendiness=<span class="number">0.5</span>)</div><div class="line">f = Peach(fuzziness=<span class="number">0.8</span>)</div></pre></td></tr></table></figure></p>
<p>但是你不能将父类型值存储到子类型变量中：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b = Banana(bendiness=<span class="number">0.5</span>)</div><div class="line"><span class="keyword">val</span> f: Fruit = b</div><div class="line"><span class="keyword">val</span> b2: Banana = f</div><div class="line"><span class="comment">// Error: Type mismatch: inferred type is Fruit but Banana was expected</span></div></pre></td></tr></table></figure></p>
<p>另外，Kotlin 把 Java 方法参数和返回类型中用到的 <code>Object</code> 类型看作 <code>Any</code>(更确切地是当做「平台类型」)。当 Kotlin 函数函数中使用 <code>Any</code> 时，它会被编译成 Java 字节码中的 <code>Object</code>。</p>
<blockquote>
<p>Hint: 平台类型本质上就是 Kotlin 不知道可控性信息的类型。</p>
</blockquote>
<p>上面提到：在 Kotlin 中， <strong><code>Any</code> 是所有 非空类型 的超类</strong>。<br>你可能会有疑问： <code>null</code> 类型的父类是什么呢？</p>
<h3 id="14-可空类型nullable-types-intboolean-及其他"><a href="#1-4-可空类型-Nullable-Types-——-Int？-Boolean？-及其他" class="headerlink" title="1.4 可空类型(Nullable Types) —— Int？,Boolean？ 及其他"></a>1.4 可空类型(Nullable Types) —— Int？,Boolean？ 及其他</h3><p>与 Java 不同，Kotlin 区分非空（non-null）和可空（nullable）类型。到目前为止，我们看到的类型都是非空类型，Kotlin 不允许 null 作为这些类型的值。访问非空类型的变量将永远不会抛出空指针异常。</p>
<p>由于 <code>null</code> 只能被存储在 Java 的引用类型的变量中，所以在 Kotlin 中基本数据的可空版本都会使用该类型的包装形式。</p>
<p>同样的，如果你用基本数据类型作为泛型类的类型参数，Kotlin 同样会使用该类型的包装形式。</p>
<p>我们可以在任何类型后面加上<code>？</code>，比如<code>Int?</code>，实际上等同于<code>Int? = Int or null</code>，通过合理的使用，我们能够简化很多判空代码。并且我们能够有效规避 <code>NullPointerException</code>导致的崩溃。基于可空类型，Kotlin 才拥有很多促使安全的运算符：</p>
<h4 id="安全调用"><a href="#——-安全调用" class="headerlink" title="?. —— 安全调用"></a>?. —— 安全调用</h4><p><code>?.</code>允许我们把一次 <code>null</code> 检查和一次方法的调用合并成一个操作，比如：</p>
<p><code>str?.toUpperCase()</code> 等同于 <code>if (str != null) str.toUpperCase() else null</code></p>
<p>当然，<code>?.</code> 同样可以处理属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String, <span class="keyword">val</span> master: User?)</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">masterInfo</span><span class="params">(user: <span class="type">User</span>)</span></span>: String? = user.master?.nickname</div><div class="line"></div><div class="line"><span class="comment">// test</span></div><div class="line"><span class="keyword">val</span> ceo = User(<span class="string">"boss"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">val</span> employee = User(<span class="string">"employee-1"</span>, ceo)</div><div class="line">println(masterInfo(employee)) <span class="comment">// boss</span></div><div class="line">println(masterInfo(ceo)) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<h4 id="elvis-运算符"><a href="#——-Elvis-运算符" class="headerlink" title="?: —— Elvis 运算符"></a>?: —— Elvis 运算符</h4><p>刚开始我也不知道为什么称之为「Elvis 」运算符——直到我看到了这张图…</p>
<p><img src="elvis.png" alt="elvis"></p>
<p>如果你不喜欢这个名字，我们也可以叫它——「null 合并运算符」。如果你学习过 Scala，这类似于 <code>getOrElse</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun getOrElse(str: String?) &#123;</div><div class="line">  val result: String = str ?: &quot;&quot; // 等价于 str == null ? &quot;&quot; : str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外还有<code>as?</code>（安全转换）、<code>!!</code>（非空断言）、<code>let</code>、<code>lateinit</code>（延迟初始化属性）等此处就不详细介绍。</p>
<h3 id="15-unit-kotlin-里的-void"><a href="#1-5-Unit-——-Kotlin-里的-void" class="headerlink" title="1.5 Unit —— Kotlin 里的 void"></a>1.5 Unit —— Kotlin 里的 void</h3><p>Kotlin 是一种表达式导向的语言，所有流程控制语句都是表达式。它没有 Java 和 C 中的 <code>void</code> 函数，函数总是会返回一个值。有时候函数并没有计算任何东西 —— 这被我们称作他们的副作用（side effect），这时将会返回 <code>Unit</code>——具有单一值的类型。</p>
<p>大多数情况下，你不需要明确指定 <code>Unit</code> 作为返回类型或从函数返回<code>Unit</code>。如果编写的函数具有块代码体，并且不指定返回类型，则编译器会将其视为返回 <code>Unit</code> 类型，否则编译器会使用推断的类型。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"block body and no explicit return type, so returns Unit"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> u: <span class="built_in">Unit</span> = example()</div></pre></td></tr></table></figure></p>
<p><code>Unit</code> 并没什么特别之处。就像任何其他类型一样，它是 <code>Any</code> 的子类型，而 <code>Unit?</code> 是 <code>Any?</code> 的子类型。</p>
<center><img src="unit-1.png" alt="Kotlin types"></center>

<p>然而 <code>Unit?</code> 类型却是一个奇怪的特殊例子，这是 Kotlin 的类型系统一致性的结果。<code>Unit?</code> 类型只有两个值：<code>Unit</code> 单例和 <code>null</code>。我从来没有发现需要明确使用 <code>Unit?</code> 类型的地方，但是在类型系统中没有特殊的 void 这一事实，使得处理各种函数泛型变得更加容易。  </p>
<h3 id="16-nothing"><a href="#1-6-Nothing" class="headerlink" title="1.6 Nothing"></a>1.6 Nothing</h3><p>在 Kotlin 类型层级结构的最底层是 <code>Nothing</code> 类型。  </p>
<center><img src="nothing-1.png" alt="Kotlin types"></center>  

<p>顾名思义，<code>Nothing</code> 是没有实例的类型。<code>Nothing</code> 类型的表达式不会产生任何值。</p>
<p>注意 <code>Unit</code> 和 <code>Nothing</code> 之间的区别，对 <code>Unit</code> 类型的表达式求值将返回 <code>Unit</code> 的单例，而对 <code>Nothing</code> 类型的表达式求值则永远都不会返回。</p>
<p>这意味着任何类型为 <code>Nothing</code> 的表达式之后的所有代码都是无法得到执行的（unreachable code），编译器和 IDE 会向你发出警告。</p>
<p>什么样的表达式类型为 <code>Nothing</code> 呢？<a href="https://kotlinlang.org/docs/reference/grammar.html#jump" target="_blank" rel="external">流程控制中与跳转相关的表达式。</a></p>
<p>例如 <code>throw</code> 关键字会中断表达式的计算，并从函数中抛出异常。因此 <code>throw</code> 就是 <code>Nothing</code> 类型的表达式。</p>
<p>通过将 <code>Nothing</code> 作为所有类型的子类型，类型系统允许程序中的任何表达求值失败。这是真实世界的模型，例如 JVM 在计算表达式时内存不足，或者是有人拔掉了计算机的电源插头。这也意味着我们可以从任何表达式中抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">formatCell</span><span class="params">(value: <span class="type">Double</span>)</span></span>: String =</div><div class="line">    <span class="keyword">if</span> (value.isNaN())</div><div class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="subst">$value</span> is not a number"</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        value.toString()</div></pre></td></tr></table></figure>
<p>你可能会惊奇地发现，<code>return</code> 语句的类型也为 <code>Nothing</code>。<code>return</code> 是一个流程控制语句，它立即从函数中返回一个值，打断其所在表达式的求值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">formatCellRounded</span><span class="params">(value: <span class="type">Double</span>)</span></span>: String =</div><div class="line">    <span class="keyword">val</span> rounded: <span class="built_in">Long</span> = <span class="keyword">if</span> (value.isNaN()) <span class="keyword">return</span> <span class="string">"#ERROR"</span> <span class="keyword">else</span> Math.round(value)</div><div class="line">    rounded.toString()</div></pre></td></tr></table></figure>
<p>进入无限循环或杀死当前进程的函数返回类型也为 Nothing。例如 Kotlin 标准库将 <code>exitProcess</code> 函数声明为：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exitProcess</span><span class="params">(status: <span class="type">Int</span>)</span></span>: <span class="built_in">Nothing</span></div></pre></td></tr></table></figure></p>
<p>如果你编写返回 <code>Nothing</code> 的自定义函数，编译器同样能检查出调用函数后无法得到执行的代码，就像使用语言本身的流程控制语句一样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">forever</span><span class="params">(action: ()</span></span>-&gt;<span class="built_in">Unit</span>): <span class="built_in">Nothing</span> &#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) action()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">()</span></span> &#123;</div><div class="line">    forever &#123;</div><div class="line">        println(<span class="string">"doing..."</span>)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"done"</span>) <span class="comment">// Warning: Unreachable code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与空安全一样，不可达代码分析是类型系统的一个特性。无需像 Java 一样在编译器和 IDE 中使用一些手段进行特殊处理。</p>
<h3 id="17-可空的-nothing"><a href="#1-7-可空的-Nothing" class="headerlink" title="1.7 可空的 Nothing?"></a>1.7 可空的 Nothing?</h3><p><code>Nothing</code> 像任何其他类型一样，如果允许其为空则可以得到对应的类型 <code>Nothing?</code>。<code>Nothing?</code> 只能包含一个值：<code>null</code>。事实上 <code>Nothing?</code> 就是 <code>null</code> 的类型。</p>
<p><code>Nothing?</code> 是所有可空类型的最终子类型，所以我们可以使用 null 作为任何可空类型的值。</p>
<center><img src="nullable-nothing.png" alt="Kotlin types"></center>  





<hr>
<p>参考：</p>
<ul>
<li><a href="http://natpryce.com/articles/000818.html" target="_blank" rel="external">A Whirlwind Tour of the Kotlin Type Hierarchy</a></li>
<li><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="external"> 《Kotlin in Action》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论在静态语言还是动态语言中，「类型系统」都起到了至关重要的作用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（五）：Adapter 适配器模式</title>
    <link href="http://prefer-tyl.site/2017/11/20/scala-design-patterns-5-adapter/"/>
    <id>http://prefer-tyl.site/2017/11/20/scala-design-patterns-5-adapter/</id>
    <published>2017-11-20T01:00:13.000Z</published>
    <updated>2017-11-19T17:28:48.898Z</updated>
    
    <content type="html"><![CDATA[<p>在编程中，我们也会遇上类似的问题：</p>
<ol>
<li>当你想使用一个已经存在的类，而它的接口不符合你的需求；  </li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；  </li>
<li>…  <a id="more"></a>
</li>
</ol>
<p>不管你是不是果粉，肯定对 iphone X 都有所耳闻。最近的「掉漆门」和「人脸识别被破解」更是将其推到了风口浪尖上。</p>
<image src="http://om6vvgjw7.bkt.clouddn.com/iphone%20x2.jpg" width="300" height="400"></image>

<p>但是对于我而言，最难以忍受的还是耳机接口被取消这一改变（自 Iphone 7 开始)，你可以想象这样一幅画面：当你开开心心地和小伙伴开着语音吃（song）着（kuai）鸡（di）或者是多人一起上（song）分时——你的电量见底，为了不影响队友（shou）的游戏体验，肯定得充电玩下去。</p>
<p>这时你得面对一个难题：<strong>只有一个洞，插耳机还是插电源！？</strong>（在没有蓝牙耳机的前提下）  </p>
<p><img src="http://oznwqhlo5.bkt.clouddn.com/iPhone-X-Home-Button-Audio-Jack-960x540.jpg" alt="">(侵删)</p>
<p>由于生活经常会欺骗我们，以及各种环境因素，所以不是每个人都选择蓝牙耳机（贫穷使我理智）。</p>
<p>是否存在别的解决方法呢？还好有转接线这样的好东西</p>
<p><img src="http://oznwqhlo5.bkt.clouddn.com/%E8%BD%AC%E6%8E%A5%E7%BA%BF.jpg" alt="">(侵删)</p>
<p>在编程中，我们也会遇上类似的问题：</p>
<ol>
<li>当你想使用一个已经存在的类，而它的接口不符合你的需求；  </li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；  </li>
<li>…<br>本文会通过 Adapter Pattern 来一步步解决上述问题。</li>
</ol>
<!-- 本篇文章结构如下：
- adapter pattern 的概念
- 问题分解
- Java 实例
- Scala 实例
- 总结 -->
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#它解决了什么问题">它解决了什么问题</a><ul>
<li><a href="#java-版本">Java 版本</a></li>
<li><a href="#类适配器">类适配器</a></li>
<li><a href="#对象适配器">对象适配器</a></li>
<li><a href="#对象适配器-vs-类适配器">对象适配器 vs 类适配器</a></li>
<li><a href="#优点">优点</a></li>
</ul>
</li>
<li><a href="#小结">小结</a><ul>
<li><a href="#scala-版本">Scala 版本</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>适配器模式（Adapter Pattern）有时候也称包装样式或者包装（Wrapper）。定义如下：  </p>
<blockquote>
<p>将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p>
</blockquote>
<h2 id="它解决了什么问题"><a href="#它解决了什么问题" class="headerlink" title="它解决了什么问题"></a>它解决了什么问题</h2><h3 id="java-版本"><a href="#Java-版本" class="headerlink" title="Java 版本"></a>Java 版本</h3><p>小 A 是个苹果控 + 耳机控，之前买了一款很贵的耳机，对其爱不释手。我们都知道一般耳机接口都是 3.5mm 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneJackInterface</span> </span>&#123;</div><div class="line">    <span class="comment">// 传统的播放音频</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">audioTraditionally</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneJackConnector</span> <span class="keyword">implements</span> <span class="title">PhoneJackInterface</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audioTraditionally</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"通过 PhoneJack 播放声音"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iphone 7 之前的 iphone 支持 3.5mm 接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> PhoneJackInterface phoneJack;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Iphone</span><span class="params">(PhoneJackInterface phoneJack)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.phoneJack = phoneJack;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Iphone 具备播放声音的功能</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 通过 3.5mm 接口耳机播放</span></div><div class="line">        phoneJack.audioTraditionally();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的情况下，小 A 还可以愉快地听歌：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// test</span></div><div class="line">PhoneJackInterface phoneJack = <span class="keyword">new</span> PhoneJackConnector();</div><div class="line">Iphone iphone6 = <span class="keyword">new</span> Iphone(phoneJack);</div><div class="line">iphone6.play();</div><div class="line"><span class="comment">// 控制台输出 “通过 PhoneJack 播放声音”</span></div></pre></td></tr></table></figure></p>
<p>在 iphone 7 问世后，问题出现了：小 A 发现其<strong>不支持 3.5mm 接口 —— 将有线耳机的插口改为了 lightning</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LightningInterface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">audioWithLightning</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightningConnector</span> <span class="keyword">implements</span> <span class="title">LightningInterface</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audioWithLightning</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"通过 Lightning 播放声音"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一边是耳机，一边是手机，这太难以抉择了。但苹果怎么可能没考虑到这点了，可以<strong>通过赠送的耳机转接器 —— 将传统的耳机头转为 lightning</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadsetAdapter</span> <span class="keyword">implements</span> <span class="title">PhoneJackInterface</span> </span>&#123; <span class="comment">// 基于传统耳机接口</span></div><div class="line"></div><div class="line">   LightningInterface lightning; <span class="comment">// 兼容新接口</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传入 lightning 接口</div><div class="line">     * <span class="doctag">@param</span> lightning</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeadsetAdapter</span><span class="params">(LightningInterface lightning)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lightning = lightning;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对传统接口兼容</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audioTraditionally</span><span class="params">()</span> </span>&#123;</div><div class="line">        lightning.audioWithLightning();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>这样不够简洁，我们可以改一改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadsetAdapter</span> <span class="keyword">extends</span> <span class="title">LightningConnector</span> <span class="keyword">implements</span> <span class="title">PhoneJackInterface</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audioTraditionally</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 传统接口兼容 lightning</span></div><div class="line">        <span class="keyword">super</span>.audioWithLightning();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// test</span></div><div class="line">HeadsetAdapter headsetAdapter = <span class="keyword">new</span> HeadsetAdapter();</div><div class="line">Iphone iphone7 = <span class="keyword">new</span> Iphone(headsetAdapter);</div><div class="line">iphone7.play();</div><div class="line"><span class="comment">// 控制台输出 “通过 Lightning 播放声音”</span></div></pre></td></tr></table></figure></p>
<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>我们一般将上面的适配器称作「类适配器」，除此之外还有一种 「对象适配器」，我们可以对适配器类进行如下修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHeadsetAdapter</span> <span class="keyword">implements</span> <span class="title">PhoneJackInterface</span> </span>&#123; <span class="comment">// 基于传统耳机接口</span></div><div class="line"></div><div class="line">   LightningConnector lightning; <span class="comment">// 兼容新接口</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传入 lightning 接口</div><div class="line">     * <span class="doctag">@param</span> lightning</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectHeadsetAdapter</span><span class="params">(LightningConnector lightning)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lightning = lightning;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对传统接口兼容</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audioTraditionally</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 使用委托实现兼容</span></div><div class="line">        <span class="keyword">this</span>.lightning.audioWithLightning();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectHeadsetAdapter objectHeadsetAdapter = <span class="keyword">new</span> ObjectHeadsetAdapter(<span class="keyword">new</span> LightningConnector());</div><div class="line">Iphone iphoneX = <span class="keyword">new</span> Iphone(objectHeadsetAdapter);</div><div class="line">iphoneX.play();</div></pre></td></tr></table></figure></p>
<h3 id="对象适配器-vs-类适配器"><a href="#对象适配器-vs-类适配器" class="headerlink" title="对象适配器 vs 类适配器"></a>对象适配器 vs 类适配器</h3><p>通过以上简单的例子，相信你对适配器模式有一个大致了解了。「类适配器」与「对象适配器」的区别概括如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:center">类适配器</th>
<th style="text-align:center">对象适配器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">创建方式</td>
<td style="text-align:center">需要通过创建自身创建出一个新的 Adapter</td>
<td style="text-align:center">可以通过已有的 Adapter 对象来转换接口</td>
</tr>
<tr>
<td style="text-align:left">扩展性</td>
<td style="text-align:center">通过 Override 来扩展新需求</td>
<td style="text-align:center">因为包含关系所以不能扩展</td>
</tr>
<tr>
<td style="text-align:left">其他</td>
<td style="text-align:center">继承被适配类，所以相对静态</td>
<td style="text-align:center">包含被适配类，所以相对灵活</td>
</tr>
</tbody>
</table>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>适配器模式主要有以下几个优点：  </p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。  </li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合「开闭原则」。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在 <code>Spring</code> 等框架、驱动程序设计（如 <code>JDBC</code> 中的数据库驱动程序）中也使用了适配器模式。</p>
<p>看完 Java 的实现方式，我们再来看看 Scala 是如何实现的。</p>
<h3 id="scala-版本"><a href="#Scala-版本" class="headerlink" title="Scala 版本"></a>Scala 版本</h3><p>在 Scala 中，由于方便的语法糖，我们并不需要像 Java 那样麻烦，已知传统接口类（此处省略一些接口）<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneJackConnector</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span>  <span class="title">audioTraditionally</span> </span>= println(<span class="string">"通过 PhoneJack 播放声音"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们有需要适配的，为其创建一个 <code>trait</code> 即可:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Lightning</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">audioWithLightning</span></span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其次再新建一个类，继承传统类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeadsetAdapter</span> <span class="keyword">extends</span> <span class="title">PhoneJackConnector</span> <span class="keyword">with</span> <span class="title">Lightning</span> </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">audioTraditionally</span></span>: <span class="type">Unit</span> = println(<span class="string">"通过 Lightning 播放声音"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">audioWithLightning</span></span>: <span class="type">Unit</span> = <span class="keyword">super</span>.audioWithLightning</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时，你应该发现一个惊喜：在这个新的类里，我们可以对新老方法一起扩展——在 Java 中这是 「对象适配器」 和 「类适配器」 的一个差异。<br>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> headsetAdapter = <span class="keyword">new</span> <span class="type">HeadsetAdapter</span></div><div class="line">headsetAdapter.audioTraditionally</div></pre></td></tr></table></figure></p>
<p>当然，除了这种方式，Scala 里还可以通过隐式转换来实现适配 Final 类的适配器<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalPhoneJackConector</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">audioTraditionally</span> </span>= println(<span class="string">"通过 PhoneJack 播放声音"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FinalPhoneJackConector</span> </span>&#123;</div><div class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplictHeadsetAdapter</span>(<span class="params">phoneJackConnector: <span class="type">FinalPhoneJackConector</span></span>) <span class="keyword">extends</span> <span class="title">Lightning</span> </span>&#123;</div><div class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">audioWithLightning</span></span>: <span class="type">Unit</span> =  println(<span class="string">"通过 Lightning 播放声音"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> headsetAdapter = <span class="keyword">new</span> <span class="type">HeadsetAdapter</span></div><div class="line">headsetAdapter.audioTraditionally</div><div class="line"></div><div class="line"><span class="comment">//隐式</span></div><div class="line"><span class="keyword">val</span> light: <span class="type">Lightning</span> = <span class="keyword">new</span> <span class="type">FinalPhoneJackConector</span></div><div class="line">light.audioWithLightning()</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>光从代码量来说，Scala 简洁比 Java 表现的好太多。</p>
<p>其次，Scala 结合了「类适配器」和「对象适配器」所有的优点，并消除了自身问题。与 Java 相比，Scala 有如下特点：</p>
<ol>
<li>与对象适配器一样灵活</li>
<li>与「类适配器相比」，没有对特定被适配类的依赖</li>
<li>只适用于不需要动态改变被适配类的情况</li>
</ol>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Adapter" target="_blank" rel="external">源码链接</a><br>如有错误和讲述不恰当的地方还请指出，不胜感激！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程中，我们也会遇上类似的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当你想使用一个已经存在的类，而它的接口不符合你的需求；  &lt;/li&gt;
&lt;li&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；  &lt;/li&gt;
&lt;li&gt;…
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dive Into Kotlin（一）：初探 Kotlin</title>
    <link href="http://prefer-tyl.site/2017/11/05/kotlin-0/"/>
    <id>http://prefer-tyl.site/2017/11/05/kotlin-0/</id>
    <published>2017-11-05T00:04:13.000Z</published>
    <updated>2017-11-05T16:39:02.129Z</updated>
    
    <content type="html"><![CDATA[<p>在今年的 <a href="https://www.youtube.com/watch?v=Y2VF8tmLFHw" target="_blank" rel="external">Google I/O</a> 大会上，Google 宣布在 Android 上为 Kotlin 提供一等支持（转为正房）。  </p>
<p>在 Andorid 开发的圈子中，这无疑掀起了轩然大浪。对部分人来说，也许这是第一次听到 「Kotlin 」。事实上，在2011年7月，JetBrains 就推出 Kotlin 项目，直到去年2月份 Kotlin v1.0 才正式发布。    </p>
<a id="more"></a>
<p>本文将简单介绍 Kotlin 的生态系统和部分语言功能。</p>
<!-- toc -->
<ul>
<li><a href="#kotlin-是一门怎么样的语言">Kotlin 是一门怎么样的语言？</a><ul>
<li><a href="#kotlin-核心的目标">Kotlin 核心的目标</a></li>
</ul>
</li>
<li><a href="#强大的生态圈">强大的生态圈</a></li>
<li><a href="#特征">特征</a><ul>
<li><a href="#属性前置">属性前置</a></li>
<li><a href="#函数式编程是变革的关键">函数式编程是变革的关键</a></li>
<li><a href="#kotlin-重新定义了函数的写法">Kotlin 重新定义了函数的写法</a></li>
<li><a href="#函数可读性">函数可读性</a></li>
<li><a href="#类型安全">类型安全</a></li>
<li><a href="#lambda-优化">Lambda 优化</a></li>
<li><a href="#条件判断更优雅">条件判断更优雅</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="kotlin-是一门怎么样的语言"><a href="#Kotlin-是一门怎么样的语言？" class="headerlink" title="Kotlin 是一门怎么样的语言？"></a>Kotlin 是一门怎么样的语言？</h2><p>Kotlin 是一种在 JVM 上运行的静态类型编程语言，可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。  </p>
<h3 id="kotlin-核心的目标"><a href="#Kotlin-核心的目标" class="headerlink" title="Kotlin 核心的目标"></a>Kotlin 核心的目标</h3><ul>
<li><p><strong>简约</strong>：帮你减少实现同一个功能的代码量。  </p>
</li>
<li><p><strong>易懂</strong>：让你的代码更容易阅读，同时易于理解。  </p>
</li>
<li><p><strong>安全</strong>：移除了你可能会犯错误的功能。  </p>
</li>
<li><p><strong>通用</strong>：基于 JVM 和 Javascript，你可以在很多地方运行。  </p>
</li>
<li><p><strong>互操作性</strong>：这就意味着 Kotlin 和 Java 可以相互调用，同时 Jetbrains 的目标是让他们 100% 兼容。  </p>
</li>
</ul>
<p>对比 Java，Kotlin 或许显得有点年轻，但这并不代表它的生态系统不够稳定。</p>
<h2 id="强大的生态圈"><a href="#强大的生态圈" class="headerlink" title="强大的生态圈"></a>强大的生态圈</h2><p><strong>Kotlin 编译为 JVM 字节码或 JavaScript</strong><br>它可以吸引所有使用垃圾回收机制语言的程序员，包括 Java，Scala，Go，Python， Ruby 和 JavaScript。</p>
<p><strong>kotlin 产自工业，而不是学术界。</strong><br>它解决了程序员目前所面临的一些问题。举个例子：类型系统可以帮助你避免空指针异常。当我们在使用一些 API 或者大型库时判断是否为 null，往往没有什么实际作用。</p>
<p><strong>Kotlin 完美兼容 Java</strong><br>在 Idea 中，你可以一键实现 Java 与 Kotlin 的转换。也就是说， Kotlin 写的项目中可以使用所有现有的 Java 框架和库，甚至是依赖于注解的高级框架，并且它整合了 Maven，Gradle 和其他构建工具——帮助我们实现无缝的互操作。  </p>
<p><strong>Kotlin 相对入门简单</strong><br>所以正如大家所说的那样，Kotlin 是一门十分友好的语言，你甚至可以花几个小时阅读下相关书籍就能入门。它的语法简洁直观，也许大多时候看起来比较像 Scala，实际上简单了很多。这种语言很好地平衡了简洁和可读性。</p>
<p><strong>不施加运行时间的开销</strong><br>标准库是比较小的：主要是对 Java 标准库的重点扩展。大量使用编译时内联（compile-time inlining）就意味着像 <code>map</code>、 <code>filter</code>、 <code>reduce</code> 这样的语法编译起来与命令式的相似。</p>
<p><strong>Android扩展库</strong><br><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a> 与 <a href="http://kovenant.komponents.nl/android/features/" target="_blank" rel="external">kovenant</a> 让 Kotlin 在 Android 的开发中更加方便，如果你看过这两个库，一定也为之青睐。</p>
<p>除 Android 外，其实企业级别的 Java 项目也可以考虑使用 Kotlin：  </p>
<ol>
<li><p><strong>它有一个成熟的公司强大的商业支持</strong>，JetBrains 致力于该项目的房展，拥有一支高效的团队和稳定的商业模式。在较长的时间内，你都不用担心 Kotlin 被抛弃。  </p>
</li>
<li><p><strong>Kotlin 的风险很低</strong>：可以由一两个成员尝试在某个功能块使用，但并不会影响其他模块：Kotlin 类可以导出一个与常规 Java 代码看起来相同的 Java API。</p>
</li>
<li><p><strong>Java 6 废土中的一线希望</strong>：如果升级 JVM 对于你们的成本很高，你可以使用 Kotlin，它是「加强版的 Java 6」。</p>
</li>
</ol>
<p>看完生态系统，来看看最吸引我们的语言功能。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img src="http://ovib8fj5v.bkt.clouddn.com/kotlin&amp;&amp;android.png" alt="kotlin&amp;&amp;Android">  </p>
<h4 id="属性前置"><a href="#属性前置" class="headerlink" title="属性前置"></a>属性前置</h4><p>Java Bean 中总是出现一些重复工作量的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.name=name;</div><div class="line"><span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 Java 对象中，构造函数和属性的 <code>Getter</code>、<code>Setter</code> 函数在每个Bean类中都会出现，看起来非常冗余。  </p>
<p>但是使用 Kotlin，代码是这样的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age:<span class="built_in">Int</span>)</div></pre></td></tr></table></figure></p>
<p>Kotlin 将<code>Getter</code>、<code>Setter</code> 等函数省略，让我们更加关注属性。</p>
<h4 id="函数式编程是变革的关键"><a href="#函数式编程是变革的关键" class="headerlink" title="函数式编程是变革的关键"></a>函数式编程是变革的关键</h4><p>如果你是一名 「FP」 （Functional Programming） 爱好者，你肯定知道 <a href="https://zh.wikipedia.org/wiki/Scala" target="_blank" rel="external">Scala</a>  这门语言。而 Kotlin 的设计初衷就是提供 Scala 里的很多特性，但不被编译时间束缚。  </p>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/FP.jpg" alt="FP">  </p>
<p>网上对函数式编程的介绍，大多数对初学者都是不够友好的，下面是一种比较简洁的概括：</p>
<blockquote>
<p>函数编程以基于数学的函数构成，实现一个功能时倾向于实现的目标，而不是实现目标的方式。  </p>
</blockquote>
<p>也就是说，函数式编程处理的是不可变的数据，即不会改变变量的值。它所做的只是 Receive（接收）-&gt; Compute（计算）-&gt; Return（返回） ，而不改变它接收到的值，或者引起<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="external">「副作用」</a>。  </p>
<h4 id="kotlin-重新定义了函数的写法"><a href="#Kotlin-重新定义了函数的写法" class="headerlink" title="Kotlin 重新定义了函数的写法"></a>Kotlin 重新定义了函数的写法</h4><ul>
<li>简化函数重载。</li>
<li>命名参数不遵循顺序：命名参数允许完全控制什么值被传递给变量，并在与布尔处理，举个例子：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">boolean</span> isAlpha, <span class="keyword">boolean</span> isNum)</span></span>&#123;<span class="comment">//函数定义</span></div><div class="line">&#125;</div><div class="line">check(<span class="keyword">true</span>，<span class="keyword">false</span>); <span class="comment">//函数调用</span></div><div class="line"></div><div class="line"><span class="comment">// Kotlin</span></div><div class="line"><span class="function">fun <span class="title">check</span><span class="params">(isAlpha:Boolean, isNum：Boolean = <span class="keyword">false</span>)</span> </span>&#123;</div><div class="line">   <span class="comment">// do something</span></div><div class="line">&#125;</div><div class="line">check(<span class="keyword">true</span>)<span class="comment">// 1</span></div><div class="line">check(<span class="keyword">true</span>,<span class="keyword">true</span>)<span class="comment">// 2</span></div><div class="line">check(isAlpha = <span class="keyword">true</span>, isNum = <span class="keyword">false</span>) <span class="comment">// 3</span></div><div class="line">check(isNum = <span class="keyword">false</span>, isAlpha = <span class="keyword">true</span>) <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>其中1、3、4实际效果一致。</p>
<h4 id="函数可读性"><a href="#函数可读性" class="headerlink" title="函数可读性"></a>函数可读性</h4><ul>
<li>单行表达式是提高代码可读性的第一步。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// 返回类型必须声明。</span></div><div class="line">X = X + Y; <span class="comment">// x的值被改变，是一个副作用。</span></div><div class="line"><span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// kotlin</span></div><div class="line"><span class="function">fun <span class="title">sum</span><span class="params">(x：Int, y：Int)</span></span>= x + y <span class="comment">//完美。</span></div></pre></td></tr></table></figure>
<p>在 Android 开发时，我们应该都会对视图的 <code>onClick</code> 事件感到烦躁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">view.setOnClickListener(<span class="keyword">new</span> View.OnClickKistener() &#123;</div><div class="line">@ <span class="function">Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span>&#123;</div><div class="line">System.out.println(<span class="string">"sad"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在 kotlin 中，这也得到简化：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">view.onClick &#123;</div><div class="line">println（<span class="string">"nice !!"</span>）</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><p>在 Android 开发中，出现 <code>NullPointerExceptio</code> 已经可以说是家常便饭了，在运行的时候才出现这个异常，对用户体验造成的损失是巨大的。  </p>
<p>Kotlin 能很好的避免这个问题：  </p>
<ul>
<li>指定 null  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">String text1 = <span class="keyword">null</span> <span class="comment">// NE</span></div><div class="line"><span class="comment">// Kotlin</span></div><div class="line">var text1：String = <span class="string">"Kotlin"</span><span class="comment">// 正常</span></div><div class="line">var text2：String = <span class="keyword">null</span> <span class="comment">// NE</span></div><div class="line">var text3：String?= <span class="keyword">null</span> <span class="comment">// 正常</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Kotlin 中只有加了 <code>?</code> 才允许为null。</strong>  </p>
<ul>
<li><p>检查 null<br>Kotlin 可以通过 <code>?</code>确保安全调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="keyword">if</span>（a != <span class="keyword">null</span>）&#123;</div><div class="line"><span class="keyword">int</span> x = a.length（）;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Kotlin</span></div><div class="line">val x = a？.length <span class="comment">//仅当a不为null时才编译</span></div></pre></td></tr></table></figure>
</li>
<li><p>为 null 时默认值  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val x = b?.length ?: <span class="number">0</span> <span class="comment">// 如果b为 null，那他的 length 就为0</span></div><div class="line">val x = b?.length ?: <span class="keyword">throw</span> NullPointerException()</div><div class="line">val x = b!!.length</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lambda-优化"><a href="#Lambda-优化" class="headerlink" title="Lambda 优化"></a>Lambda 优化</h4><p>Lambda 表达式增加了 Kotlin 的简洁功能，从而也带来了易理解的代码。(Java 6 不支持 lambda )<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sum = &#123;x：<span class="built_in">Int</span>，y：<span class="built_in">Int</span>  - &gt; x + y&#125; <span class="comment">//类型：（Int，Int） - &gt; Int</span></div><div class="line"><span class="keyword">val</span> result = sum（<span class="number">2</span>,<span class="number">7</span>）<span class="comment">// result == 9</span></div></pre></td></tr></table></figure></p>
<h4 id="条件判断更优雅"><a href="#条件判断更优雅" class="headerlink" title="条件判断更优雅"></a>条件判断更优雅</h4><p>在 kotlin 中 <code>when</code> 也能给你惊喜：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java</span></div><div class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)</div><div class="line">println(<span class="string">"x is 1"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</div><div class="line">println(<span class="string">"x is 2"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>||x==<span class="number">4</span>)</div><div class="line">println(<span class="string">"x is 3 or 4"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">5</span>||x&lt;=<span class="number">10</span>)</div><div class="line">println(<span class="string">"x is 5, 6, 7, 8, 9, or 10"</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">println(<span class="string">"x is out of range"</span>);</div><div class="line"><span class="comment">//Kotlin</span></div><div class="line">when (x) &#123;</div><div class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x is 1"</span>)</div><div class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x is 2"</span>)</div><div class="line">    <span class="number">3</span>, <span class="number">4</span> -&gt; print(<span class="string">"x is 3 or 4"</span>)</div><div class="line">    in <span class="number">5</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is 5, 6, 7, 8, 9, or 10"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is out of range"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然除了以上这些，Kotlin 还有许多令人惊喜的特性，将会在后续的文章中详细介绍，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在今年的 &lt;a href=&quot;https://www.youtube.com/watch?v=Y2VF8tmLFHw&quot;&gt;Google I/O&lt;/a&gt; 大会上，Google 宣布在 Android 上为 Kotlin 提供一等支持（转为正房）。  &lt;/p&gt;
&lt;p&gt;在 Andorid 开发的圈子中，这无疑掀起了轩然大浪。对部分人来说，也许这是第一次听到 「Kotlin 」。事实上，在2011年7月，JetBrains 就推出 Kotlin 项目，直到去年2月份 Kotlin v1.0 才正式发布。    &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（四）：Factory 工厂模式</title>
    <link href="http://prefer-tyl.site/2017/08/19/scala-design-patterns-4-factory/"/>
    <id>http://prefer-tyl.site/2017/08/19/scala-design-patterns-4-factory/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2017-08-20T03:35:29.373Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式（Factory Pattern）是一种实现了「工厂」概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。<br><a id="more"></a></p>
<!-- toc -->
<ul>
<li><a href="#简单工厂模式">简单工厂模式</a><ul>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
<li><a href="#工厂方法模式">工厂方法模式</a><ul>
<li><a href="#定义">定义</a></li>
<li><a href="#优点-1">优点</a></li>
<li><a href="#缺点-1">缺点</a></li>
</ul>
</li>
<li><a href="#抽象工厂模式">抽象工厂模式</a><ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#简单工厂模式-1">简单工厂模式</a></li>
</ul>
</li>
<li><a href="#总结-1">总结</a><ul>
<li><a href="#内部组成">内部组成</a></li>
<li><a href="#适用场景">适用场景</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>在中国历史上，房子常常与当下一样稀缺，住房问题同样是一个让百姓苦恼的社会热点。</p>
<p>在拆违章建筑还不盛行的年代，我们可以选择在深山老林里自己修建住所。在 Java 中可能是这样实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingA</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildingA</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" is building"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingB</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildingB</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" is building"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">  BuildingA buildingA = <span class="keyword">new</span> BuildingA(<span class="string">"bedroom"</span>);</div><div class="line">  BuildingB buildingB = <span class="keyword">new</span> BuildingB(<span class="string">"kitchen"</span>);</div><div class="line">  buildingA.build();</div><div class="line">  buildingB.build();</div></pre></td></tr></table></figure></p>
<p>村里的牛大哥在建完两间房子之后，后知后觉：自己想要的房间格局不同，但是风格得相同，可以把公共的部分抽离出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBuilding</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBuilding</span> <span class="keyword">implements</span> <span class="title">IBuilding</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildCommon</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Europe style"</span>); <span class="comment">// 公共的部分</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BuildingAs</span> <span class="keyword">extends</span> <span class="title">AbstractBuilding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildingAs</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buildCommon();</div><div class="line">        System.out.println(name + <span class="string">" is building"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BuildingBs</span> <span class="keyword">extends</span> <span class="title">AbstractBuilding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildingBs</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buildCommon();</div><div class="line">        System.out.println(name + <span class="string">" is building"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">BuildingAs buildingA = <span class="keyword">new</span> BuildingAs(<span class="string">"bedroom"</span>);</div><div class="line">BuildingBs buildingB = <span class="keyword">new</span> BuildingBs(<span class="string">"kitchen"</span>);</div><div class="line">buildingA.build();</div><div class="line">buildingB.build();</div></pre></td></tr></table></figure></p>
<p>但是这么做之后，牛大哥发现在建造的时候并没有省力，他向村口的王师傅请教，为什么我考虑了很多反而没什么作用呢？</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>王师傅告诉他：虽然你找出了一些公共的流程，但在实际建造过程中，你还是完整的过了所有的流程（构造方法不同，每次都要 <code>new</code> 对象）。另外，</p>
<p>另外，你对房屋的需求并不多，所以优势不够明显。</p>
<p>说着掏出一个宝盒，盒子里有很多设计图：下次你可以委托我来造一些组件（不再需要自己 <code>new</code>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBuilding <span class="title">getProduct</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="string">"bedroom"</span>.equals(name))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BuildingA(name);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"kitchen"</span>.equals(name))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BuildingB(name);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">IBuilding buildingA =  SimpleFactory.getProduct(<span class="string">"bedroom"</span>);</div><div class="line">IBuilding buildingB =  SimpleFactory.getProduct(<span class="string">"kitchen"</span>);</div><div class="line">buildingA.build();</div><div class="line">buildingB.build();</div></pre></td></tr></table></figure></p>
<p>王师傅帮助下的牛大哥在后面的建造中感觉轻松多了。</p>
<p>这就是「简单工厂模式」，也称作「静态工厂方法模式」。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>它有以下几个优点：</p>
<ul>
<li>简化对象创建的 API</li>
<li>减少 new 关键字对代码的干扰</li>
<li>代码更精简优雅</li>
</ul>
<p>而牛二哥明显没有那么幸运，他的妻子追求个性，并且很善变，总是在建造过程中更改需求。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然牛二哥也去王师傅那获取组件，每次王师傅都要拿出他的宝盒，在里面翻一遍，再告诉牛二哥 —— 这个我不会造。站在 OCP（开放封闭原则）的角度讲，该模式的扩展不够良好，每次有新的模型后都要修改工厂。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>老王师傅也经不起折腾，想着不能闭关锁国，就把自己会建造的组件贴在显眼的地方，有新的组件直接加在上面就好：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> IBuilding <span class="title">createBuilding</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBuilding <span class="title">createBuilding</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// 可以进行复杂的处理，每一种方法对应一种模型</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BuildingA(<span class="string">"bedroom"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBuilding <span class="title">createBuilding</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BuildingA(<span class="string">"kitchen"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryC</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBuilding <span class="title">createBuilding</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BuildingA(<span class="string">"restroom"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">FactoryA factoryA = <span class="keyword">new</span> FactoryA();</div><div class="line">FactoryB factoryB = <span class="keyword">new</span> FactoryB();</div><div class="line">FactoryC factoryC = <span class="keyword">new</span> FactoryC();</div><div class="line">factoryA.createBuilding();</div><div class="line">factoryB.createBuilding();</div><div class="line">factoryC.createBuilding();</div></pre></td></tr></table></figure></p>
<p>这样大家的沟通是方便了很多，而且老王也不用每次都搜一遍传家宝盒。</p>
<p>这种模式被 GOF 称作「工厂方法模式」。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>工厂方法模式（Factory Method Pattern）是一种实现了「工厂」概念的面向对象设计模式。就像其他创建型模式一样，它也是 <strong>处理在不指定对象具体类型的情况</strong> 下创建对象的问题。定义如下：</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。  — 《设计模式》 GOF</p>
</blockquote>
<p>从以上也可看出：<strong>工厂做的事很简单 —— 封装内部的实现细节</strong>。</p>
<h4 id="优点"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>它可以带来以下好处：</p>
<ol>
<li><strong>降低耦合度</strong>。在工厂方法模式中，工厂方法用来创建用户所需要的产品，同时还向用户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li><strong>良好扩展性</strong>。需要新的产品类型时，只需要新增一个工厂类，不需要更改产品以及产品的接口以及用户的使用方式。</li>
<li><strong>代码结构清晰</strong>。用户使用时不需要构造内部结构，直接调用工厂方法即可。</li>
</ol>
<h4 id="缺点"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>我们可能会遇上以下问题：</p>
<ol>
<li>增加使用成本。使用工厂模式的时候一般都会采用接口或者抽象类，有时还会涉及到反射、DOM 等方式。</li>
<li>增加系统复杂度（影响不显著）。一个工厂类对应一个产品，所以增加产品类的时候就需要增加工厂类。</li>
</ol>
<p>工厂方法模式针对的是一个产品等级结构，当要处理多个产品等级结构时（ex. 建立不同小区，小区里有不同楼宇，楼里还有不同户型），我们不希望对每个模型都建立一个工厂，这太糟糕了，来看看「抽象工厂模式」是如何解决的。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h4 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
</blockquote>
<p>我们也可把「一组相关或相互依赖的对象」称作「产品族」。</p>
<p>利用抽象工厂，我们可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBuildingA</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBuildingB</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> IBuildingA <span class="title">createBuildingA</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> IBuildingB <span class="title">createBuildingB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingA</span> <span class="keyword">implements</span> <span class="title">IBuildingA</span> </span>&#123;</div><div class="line">    ... <span class="comment">// 省略构造函数</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((name + <span class="string">"is building"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingB</span> <span class="keyword">implements</span> <span class="title">IBuildingB</span> </span>&#123;</div><div class="line">    ... <span class="comment">// 省略构造函数</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" is building"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBuildingA <span class="title">createBuildingA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BuildingA(<span class="string">"big bedroom"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBuildingB <span class="title">createBuildingB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BuildingB(<span class="string">"small bedroom"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line">Factory factory = <span class="keyword">new</span> Factory();</div><div class="line">factory.createBuildingA();</div><div class="line">factory.createBuildingB();</div></pre></td></tr></table></figure></p>
<p>我们可以直接在一个工厂类中实现多个方法，这样不用管理多个工厂，使用和管理起来都更方便。</p>
<p>如果说工厂方法解决问题的方式是「广搜」，那抽象工厂亦可看作「深搜」。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上，我们使用到了三种设计模式：<strong>简单工厂(静态工厂方法)</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。<br>在三种模式中，我们要做的都是<strong>将工厂的初始化与构造分离</strong>。</p>
<p>虽然比起直接 <code>new</code> 要增加不少代码，但在后期维护的时候，能给我们提供很多的便利。</p>
<p>看完 Java 版本，我们再来看看 Scala 是如何实现的。</p>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中，依旧可以用类似 Java 的方式来实现，只用把 Java 中的关键字 <code>interface</code> 换成 <code>trait</code> 即可，直接看代码吧。</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IBuilding</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBuilding</span>(<span class="params">name: <span class="type">String</span></span>)<span class="keyword">extends</span> <span class="title">IBuilding</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span> </span>= println(<span class="string">"SimpleBuilding "</span> + name + <span class="string">" is building"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxuryBuilding</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">IBuilding</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span> </span>= println(<span class="string">"LuxuryBuilding "</span> + name + <span class="string">" is building"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConstructionFactory</span>  </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createBuilding</span></span>(kind: <span class="type">String</span>): <span class="type">IBuilding</span> =  kind <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"Simple"</span> =&gt;   <span class="type">SimpleBuilding</span>(<span class="string">"Simple"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="string">"Luxury"</span> =&gt;   <span class="type">LuxuryBuilding</span>(<span class="string">"Luxury"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> simpleBuilding: <span class="type">IBuilding</span> = <span class="type">ConstructionFactory</span>.createBuilding(<span class="string">"Simple"</span>)</div><div class="line">  <span class="keyword">val</span> luxuryBuilding: <span class="type">IBuilding</span> = <span class="type">ConstructionFactory</span>.createBuilding(<span class="string">"Luxury"</span>)</div><div class="line">  simpleBuilding.show()</div><div class="line">  luxuryBuilding.show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这种方式，Scala 还为我们提供了一种类似构造器的语法 —— <code>apply</code>，通过这种方式，我们可以省略工厂类，只需增加产品类接口的伴生对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">IBuilding</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(kind: <span class="type">String</span>): <span class="type">IBuilding</span> = kind <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"Simple"</span> =&gt;   <span class="type">SimpleBuilding</span>(<span class="string">"Simple"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="string">"Luxury"</span> =&gt;   <span class="type">LuxuryBuilding</span>(<span class="string">"Luxury"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用者有更好的体验：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> simpleBuilding: <span class="type">IBuilding</span> = <span class="type">IBuilding</span>(<span class="string">"Simple"</span>)</div><div class="line"><span class="keyword">val</span> luxuryBuilding: <span class="type">IBuilding</span> = <span class="type">IBuilding</span>(<span class="string">"Luxury"</span>)</div><div class="line">simpleBuilding.show()</div><div class="line">luxuryBuilding.show()</div></pre></td></tr></table></figure></p>
<p>严格意义讲，这种方法并不属于 GOF 提到的工厂方法，它缺少了工厂模块，我们可以称之为「静态工厂模式」。  </p>
<p>工厂方法与抽象工厂的实现与 Java 类似，代码就不贴出来了。不了解 Scala 的同学可以参考<a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Factory" target="_blank" rel="external">源码</a>  </p>
<h2 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><p>以上，不难总结出工厂模式中的四种角色（简单工厂模式中没有抽象工厂）：  </p>
<ul>
<li><strong>抽象产品</strong>：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。（ex. 文中 <code>IBuiiding</code>)。</li>
<li><strong>具体产品</strong>：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。（ex. 文中 <code>Buiiding</code>)</li>
<li><strong>抽象工厂</strong>: 在抽象工厂类中，声明了工厂方法(<code>Factory Method</code>)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。（ex. 文中 <code>IFactory</code>)</li>
<li><strong>具体工厂</strong>: 它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。（ex. 文中 <code>ConstructionFactory</code>)</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>当然，我们不能为了设计而设计，当类结构简单的时候，我们可以直接使用 <code>new</code> 来创造，否则会增加不必要的代码，反而使结构复杂化。</p>
<p>所有工厂模式适用场景类似：<strong>调用者无需知道他所使用的对象的类</strong>（实际上内部结构对调用者是透明的 ex. 简单工厂）。</p>
<p>但还是有所差异，以下为个人理解：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单工厂</td>
<td style="text-align:left">1. 工厂类负责创建的对象比较少 <br> 2. 客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心</td>
</tr>
<tr>
<td style="text-align:left">工厂方法</td>
<td style="text-align:left">工厂类负责创建的对象复杂, 且内部对象层级关系比较简单</td>
</tr>
<tr>
<td style="text-align:left">抽象工厂</td>
<td style="text-align:left">工厂类负责创建的对象复杂, 且内部对象层级关系比较复杂</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Factory" target="_blank" rel="external">源码链接</a>  </p>
<p>如有错误和讲述不恰当的地方还请指出，不胜感激！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式（Factory Pattern）是一种实现了「工厂」概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://prefer-tyl.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://prefer-tyl.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（三）：Prototype 原型模式</title>
    <link href="http://prefer-tyl.site/2017/07/27/scala-design-patterns-3-prototype/"/>
    <id>http://prefer-tyl.site/2017/07/27/scala-design-patterns-3-prototype/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-08-10T12:18:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。<br><a id="more"></a></p>
<p>第一个细胞是怎么形成的？  第一个生物又是怎么诞生的？ 抛开宗教信仰，我们从科学角度进行推测：第一个细胞应该是由核糖核酸(RNA)不断的新陈代谢演变而来的。<br>说的轻松，但事实并不那么简单，据说第一个生物是 36 亿年前诞生的，而人类三千多万年前才出现…</p>
<p>如果每个细胞都需要从无机物开始演变，估计在地球毁灭的时候人类也还没出现。幸好在第一个细胞非常孤独的时候，掌握了「分裂」与「分化」的本领：一定条件下可以一分为二，新生细胞还能出现新的特征。</p>
<p>在开发过程中，我们也常有需要大量创造相似对象的场景，本文将以细胞分裂为例来介绍原型模式。</p>
<!-- toc -->
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#浅拷贝">浅拷贝</a></li>
<li><a href="#深拷贝">深拷贝</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a></li>
<li><a href="#总结">总结</a><ul>
<li><a href="#优缺点">优缺点</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<ul>
<li>问题<br>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。<br>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> 「四人帮」设计模式中提及的 原型模式 定义如下：</p>
<blockquote>
<p>用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>从定义中我们可以知道，原型模式中核心点就是 <strong>原型类</strong> 和 <strong>拷贝</strong> 。</p>
<p>看到拷贝，有些同学脑中可能会浮现下面这张图：</p>
<p><center><img src="http://om6vvgjw7.bkt.clouddn.com/1473308168_167070.png" width="400px"></center></p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>看完一些概念我们回过头来看文章开始的例子，假设细胞没有分裂能力，如果想再获得一个类似的细胞，只能模拟第一个细胞的环境，并且还要经历相同的时间才能得到，这无疑是费时费力的。克隆解决这个问题，那 Java 是否有类似的能力呢？<br>学过 Java 的同学都知道，所有的 <code>class</code> 都继承自 <code>java.lang.Object</code> 类。事实上，<code>Object</code> 类提供一个 <code>clone()</code> 方法，我们通过该方法，就能实现对象的拷贝。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>通过实现 <code>Cloneable</code> 接口，我们来实现细胞的克隆：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String dna;</div><div class="line">    <span class="keyword">private</span> Organelle organelle; <span class="comment">// 细胞器</span></div><div class="line"></div><div class="line">    ... <span class="comment">// 省略 get set 与 构造函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Cell: &#123;"</span> +</div><div class="line">                <span class="string">"DNA = "</span> + dna + <span class="string">'\''</span> +</div><div class="line">                <span class="string">"Organelle = "</span> + organelle.toString() +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cell <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Cell cellCopy = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cellCopy = (Cell) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cellCopy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String cytoplasm; <span class="comment">// 细胞质</span></div><div class="line">    <span class="keyword">private</span> String nucleus; <span class="comment">// 细胞核</span></div><div class="line"></div><div class="line">    ...<span class="comment">// 省略get、set、toString() 与构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过实现 <code>Cloneable</code> 接口我们便能调用 <code>clone()</code> 方法轻松实现分裂的功能。在开发的时候我们就能够轻松实现复杂对象的拷贝。</p>
<p>测试代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Cell cellA, cellB;</div><div class="line"></div><div class="line">cellA = <span class="keyword">new</span> Cell(<span class="string">"AAAGTCTGAC"</span>, <span class="keyword">new</span> Organelle(<span class="string">"细胞质"</span>, <span class="string">"细胞核"</span>));</div><div class="line">System.out.println(cellA);</div><div class="line"></div><div class="line">cellB = cellA.clone();</div><div class="line">System.out.println(cellB);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"cellA == cellB ? "</span> + (cellA == cellB));</div><div class="line">System.out.println(<span class="string">"cellA-class == cellB-class? :"</span> + (cellA.getClass() == cellB.getClass()));</div></pre></td></tr></table></figure></p>
<p>但是这样并不能应对所有情况：当细胞之前存在某种联系时，我们通过上面的 <code>clone</code> 方式只能拷贝到细胞本身的信息，但是不拷贝细胞中的引用，导致不同细胞中包含的细胞器是一样的。既然讲到拷贝，顺势我们回顾一下 Java 中「深拷贝」 和 「浅拷贝」 的基本概念：</p>
<ul>
<li><p>浅拷贝<br>仅仅复制原有对象的值，而不复制它对其他对象的引用。</p>
</li>
<li><p>深拷贝<br>原有对象的值和引用都被复制。</p>
</li>
</ul>
<p>我们可以测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"cellA.Organelle == cellB.Organelle ? "</span> + (cellA.getOrganelle() == cellB.getOrganelle()));</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellA.Organelle == cellB.Organelle ? true</div></pre></td></tr></table></figure></p>
<p>可见，当前 <code>clone()</code> 方法执行的是浅拷贝，Java 中所有的对象都是保存在堆中，而堆是供全局共享的。也就是说，只要能拿到某个对象的引用，引用者就可以随意的修改对象的内部数据，这显然是不好的。接下来我为大家介绍一下深拷贝如何实现。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>说到深拷贝的实现，一般有两种实现方案：  </p>
<p><strong>1. 改变 <code>clone</code> 方法实现深拷贝</strong>  </p>
<p>既然细胞内部的细胞器（<code>Organelle</code>）的引用没有被复制，我们可以手动添加上。  </p>
<p>首先给 <code>Organelle</code> 实现 <code>Cloneable</code> 接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">  ... <span class="comment">// 省略相同代码</span></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">       Object object = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           object = <span class="keyword">super</span>.clone();</div><div class="line">       &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> object;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>然后我们就可以在 <code>Cell</code> 类的 <code>clone()</code> 方法中复制细胞器的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Cell <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Cell cellCopy = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cellCopy = (Cell) <span class="keyword">super</span>.clone();</div><div class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cellCopy != <span class="keyword">null</span>) &#123;</div><div class="line">        cellCopy.organelle = (Organelle) organelle.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cellCopy;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellA.organelle == cellB.organelle ? false</div></pre></td></tr></table></figure></p>
<p>虽然能实现，但是想想每一个引用的对象都重写 <code>clone()</code> ，太糟糕了！</p>
<p><strong>2. 通过将对象序列化实现深拷贝</strong><br> 序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。<br> 与 <code>Cloneable</code> 实现类似，我们要给需要序列化的类实现序列化接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; ... &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  ... <span class="comment">// 省略部分代码</span></div><div class="line"></div><div class="line">  <span class="comment">// 序列化实现深拷贝</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Cell <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</div><div class="line">    <span class="comment">// 序列化（将对象写入流中）</span></div><div class="line">    ByteArrayOutputStream bos=<span class="keyword">new</span>  ByteArrayOutputStream();</div><div class="line">    ObjectOutputStream oos=<span class="keyword">new</span>  ObjectOutputStream(bos);</div><div class="line">    oos.writeObject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 反序列化（将对象从流中取出）</span></div><div class="line">    ByteArrayInputStream bis=<span class="keyword">new</span>  ByteArrayInputStream(bos.toByteArray());</div><div class="line">    ObjectInputStream ois=<span class="keyword">new</span>  ObjectInputStream(bis);</div><div class="line">    <span class="keyword">return</span>  (Cell)ois.readObject();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：Cloneable 与 Serializable 接口都是 「marker Interface」，即它们只是标识接口，没有定义任何方法。</p>
</blockquote>
<p>序列化的实现方式不需要重写多个类的 <code>clone()</code> 方法，比之前一种方法更加简便。接下去让我们看看 Scala 中是如何实现原型模式的。</p>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中，你用类似 Java 的方式来实现( Scala 提供了调用 Java 中 Cloneable 和 Serializable 的特质)<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cloneable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Cloneable</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Serializable</span> <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure></p>
<p>当然，Scala 还提供了一个便捷的方法：每个 <code>case class</code> 都拥有一个 <code>copy()</code> 方法，它会返回一个克隆自原有实例的新实例，并且可以在复制的过程中改变一些值。同样的我们还是以细胞为例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span>(<span class="params">dna: <span class="type">String</span>, organelle: <span class="type">Organelle</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Organelle</span>(<span class="params">cytoplasm: <span class="type">String</span>, nucleus: <span class="type">String</span></span>)</span></div></pre></td></tr></table></figure></p>
<p>然后，可以测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> initialCell = <span class="type">Cell</span>(<span class="string">"AAAGTCTGAC"</span>, <span class="type">Organelle</span>(<span class="string">"细胞质"</span>, <span class="string">"细胞核"</span>))</div><div class="line"><span class="keyword">val</span> cell1 = initialCell.copy()</div><div class="line"><span class="keyword">val</span> cell2 = initialCell.copy()</div><div class="line"><span class="keyword">val</span> cell3 = initialCell.copy(dna = <span class="string">"1234"</span>) <span class="comment">// 可以在拷贝的时候重新赋值</span></div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell1: <span class="subst">$&#123;cell1&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell2: <span class="subst">$&#123;cell2&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell3: <span class="subst">$&#123;cell3&#125;</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"cell1 and cell2 are equal: <span class="subst">$&#123;cell1 == cell2&#125;</span>"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="type">Cell</span> <span class="number">1</span>: <span class="type">Cell</span>(<span class="type">AAAGTCTGAC</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line"><span class="type">Cell</span> <span class="number">2</span>: <span class="type">Cell</span>(<span class="type">AAAGTCTGAC</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line"><span class="type">Cell</span> <span class="number">3</span>: <span class="type">Cell</span>(<span class="number">1234</span>,<span class="type">Organelle</span>(细胞质,细胞核))</div><div class="line">cell1 and cell2 are equal: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>对比 Scala 和 Java 的实现代码，有没有发现 Scala 是如此的简洁。<br>这里你可能会奇怪为什么 cell1 等于 cell2 ，<code>copy</code>方法到底是深拷贝还是浅拷贝？<br>因为 Scala 对副作用特别敏感的特点，我们将类型设为 <code>val</code>，就不用担心过多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上例子，相信你应该对原型模式有一定的了解。当然原型模式通常还可以解决以下问题：</p>
<ul>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
</ul>
<p>一般来说原型模式中参与者有以下三类：</p>
<ul>
<li>抽象原型类：声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类（对应上面的 <code>Cloneable</code> 和 <code>Serializable</code> 接口）。</li>
<li>具体原型类：实现抽象原型类声明的克隆方法，返回自己的一个克隆对象(<code>Cell.class</code> | <code>Cell.class</code>)。</li>
<li>客户类：创建对象并克隆（<code>Test.class</code>）。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>下面表格简单对比 Java 与 Scala 实现的优缺点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拷贝方式</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">具体原型类实现 <code>Cloneable</code></td>
<td style="text-align:center">具体原型类实现 <code>Cloneable</code>  或    具体原型类为 <code>case class</code></td>
</tr>
<tr>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">具体原型类 + 引用类实现 <code>Cloneable</code> 或  <code>Serializable</code></td>
<td style="text-align:center">具体原型类 + 引用类实现 <code>Cloneable</code> 或  <code>Serializable</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（二）：Builder 创建者模式</title>
    <link href="http://prefer-tyl.site/2017/07/20/scala-design-patterns-2-builder/"/>
    <id>http://prefer-tyl.site/2017/07/20/scala-design-patterns-2-builder/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-07-20T14:47:03.619Z</updated>
    
    <content type="html"><![CDATA[<p>创建者模式（Builder Pattern）支持以类方法而非类构造器的方式来创建实例。当一个类的构造器拥有多个版本以支持不同的用途时，这种模式尤其有用。</p>
<a id="more"></a>
<p>在 Java 开发中，你是否写过这样像蛇一样长的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Robot robot = <span class="keyword">new</span> Robot(<span class="number">1</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>) <span class="comment">// Boolean 类型的参数表示 computer 是否含有对应固件</span></div></pre></td></tr></table></figure></p>
<p>刚写完时回头看发现能看懂，一天后回头看时已经忘记大半了，一个星期后：What The Fu*k？<br>当然有强（lan）迫（duo）症的同学肯定不能忍 ——— 他们会创造各种各样的便捷版！</p>
<p>本文会通过 Builder Pattern 来一步步解决上述以及更复杂的一些情况。</p>
<!-- 本篇文章结构如下： -->
<!-- - builder pattern 的概念 -->
<!-- - 问题分解 -->
<!-- - Java 实例 -->
<!-- - Scala 实例 -->
<!-- - 总结 -->
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#它解决了什么问题">它解决了什么问题</a><ul>
<li><a href="#当大量参数遇上构造函数">当大量参数遇上构造函数</a></li>
<li><a href="#java-变种版">Java —— 变种版</a><ul>
<li><a href="#java-传统版">Java —— 传统版</a></li>
</ul>
<ul>
<li><a href="#builder-模式的构成">Builder 模式的构成</a></li>
<li><a href="#如何让构造的对象有不同表示">如何让构造的对象有不同表示</a></li>
<li><a href="#代码实现">代码实现</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#仿-java-版">仿 Java 版</a></li>
<li><a href="#case-class-版">case class 版</a></li>
<li><a href="#类型安全type-safe-版">类型安全(<code>type-safe</code>) 版</a></li>
<li><a href="#require-版">require 版</a></li>
</ul>
</li>
<li><a href="#总结-1">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>创建者模式与单例模式一样，也是「四人帮」设计模式中的一种，一般也译作「生成器模式」，定义如下：</p>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.<br>   将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。        </p>
</blockquote>
<h2 id="它解决了什么问题"><a href="#它解决了什么问题" class="headerlink" title="它解决了什么问题"></a>它解决了什么问题</h2><h4 id="当大量参数遇上构造函数"><a href="#当大量参数遇上构造函数" class="headerlink" title="当大量参数遇上构造函数"></a>当大量参数遇上构造函数</h4><p>我们都知道在 Java 中，每个类都至少有一个构造函数，如果我们没有明确声明构造函数，编译器会默认帮我们生成一个无参的构造函数。当然我们也可以根据参数写不同的构造函数。</p>
<p>在实际项目开发中，对象中的属性一般都是比较多的。当对象中有大量可选参数或者参数类型一致时（正如文章开头的例子），通常情况下创建前我们需要了解这个类的内部结构，然后我们忽略掉为空的参数或者用所需的参数写一个新的构造函数。</p>
<p>我们以「机器人」类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String code;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> battery;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ability;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</div><div class="line"></div><div class="line">    <span class="comment">// 通常我们会生成一个含有全部参数的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String code, String name, <span class="keyword">int</span> type, <span class="keyword">int</span> battery, <span class="keyword">int</span> ability, <span class="keyword">double</span> weight, <span class="keyword">double</span> height)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.code = code;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.battery = battery;</div><div class="line">        <span class="keyword">this</span>.ability = ability;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Robot &#123;"</span> +</div><div class="line">                <span class="string">"code = "</span> + code + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", name = '"</span> + name + <span class="string">'\''</span> +</div><div class="line">                ... <span class="comment">// 省略部分</span></div><div class="line">                <span class="string">", height = '"</span> + height +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// Test</span></div><div class="line">Robot robot1 = <span class="keyword">new</span> Robot(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>, <span class="number">99</span>, <span class="number">250</span>, <span class="number">180</span>, <span class="number">180</span>);</div><div class="line">System.out.println(robot1);</div></pre></td></tr></table></figure></p>
<p>我们假设 <code>code</code> <code>name</code> <code>type</code> 是必填的参数，其他参数是可选的，我们想要的写法可能是下面这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Robot robot2 = <span class="keyword">new</span> Robot(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>奈何编译器可没那么智能，这样肯定会给出参数不匹配的 error 。我们只能老实的根据参数再去写一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String code, String name, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.code = code;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当用户类型不同时，参数组合情况就会很多，难道还要每种都写一个吗？就算这样写了，也意味着构建时有多种对象状态，扩展起来也不方便，该怎么办呢？ Builder 模式虎躯一震：是时候展现真正的技术了。</p>
<h4 id="java-变种版"><a href="#Java-——-变种版" class="headerlink" title="Java —— 变种版"></a>Java —— 变种版</h4><p>为了应对可选参数过多的情况，我们可以将 <code>Robot.java</code> 改进成下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(RobotBuilder robotBuilder)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.code = robotBuilder.code;</div><div class="line">       <span class="keyword">this</span>.name = robotBuilder.name;</div><div class="line">       ...</div><div class="line">       <span class="keyword">this</span>.height = robotBuilder.height;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> String code;</div><div class="line">       <span class="keyword">private</span> String name;</div><div class="line">       ...</div><div class="line">       <span class="keyword">private</span> <span class="keyword">double</span> height;</div><div class="line"></div><div class="line">       <span class="comment">// 必填参数</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">RobotBuilder</span><span class="params">(String code, String name, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.code = code;</div><div class="line">           <span class="keyword">this</span>.name = name;</div><div class="line">           <span class="keyword">this</span>.type = type;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//选填参数</span></div><div class="line">       <span class="function"><span class="keyword">public</span> RobotBuilder <span class="title">withOptionalBattery</span><span class="params">(<span class="keyword">int</span> battery)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.battery = battery;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ... <span class="comment">// 省略部分选填参数</span></div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> Robot <span class="title">buildRobot</span><span class="params">()</span> </span>&#123;</div><div class="line">           ValidateRobotData();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Robot(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ValidateRobotData</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="comment">// 参数格式检查</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过这种写法，可以减少对象创建过程中引入的多个构造函数、可选参数以及多个 setter 过度使用导致的不必要的复杂性。</p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Robot robot = <span class="keyword">new</span> Robot.RobotBuilder(<span class="string">"89757"</span>, <span class="string">"火星一号"</span>, <span class="number">1</span>)</div><div class="line">        .withOptionalBattery(<span class="number">99</span>)</div><div class="line">        .withOptionalAbility(<span class="number">250</span>)</div><div class="line">        .withOptionalWeight(<span class="number">180</span>)</div><div class="line">        .withOptionalHeight(<span class="number">180</span>)</div><div class="line">        .buildRobot();</div><div class="line"></div><div class="line">System.out.println(robot);</div></pre></td></tr></table></figure></p>
<p>这样的链式调用看起来比较优雅，同时对于可选参数也有语义化的引入方式。但是实际的情况可能会更糟糕一些：<code>Robot</code> 类中可能还会包含其他复杂对象，并且这些对象之间还存在一些构造顺序，下面将介绍传统的 Buidler 模式是如何解决这个问题的。</p>
<h3 id="java-传统版"><a href="#Java-——-传统版" class="headerlink" title="Java —— 传统版"></a>Java —— 传统版</h3><p>在写实际的例子之前，让我们先看一下 「四人帮」 提出的 Builder 模式的组成（推荐新手先看例子再回过头来看）</p>
<h5 id="builder-模式的构成"><a href="#Builder-模式的构成" class="headerlink" title="Builder 模式的构成"></a>Builder 模式的构成</h5><ol>
<li>建造者(Builder):<ul>
<li>Builder 为创建一个 Product 对象(对应文中 Robot)的各个部件指定抽象接口。</li>
</ul>
</li>
<li>抽象建造者(ConcreteBuilder):<ul>
<li>实现 Builder 的接口以构造和装配该产品的各个部件。</li>
<li>定义并明确它所创建的表示。</li>
<li>提供一个检索产品的接口</li>
</ul>
</li>
<li>导演类(Director)<ul>
<li>构造一个使用 Builder 接口的对象。</li>
</ul>
</li>
<li><p>产品类(Product)  </p>
<ul>
<li>表示被构造的复杂对象，ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
<p>看着是不是会有一点绕？还是先直接进入实际的场景部分吧！</p>
</li>
</ol>
<h5 id="如何让构造的对象有不同表示"><a href="#如何让构造的对象有不同表示" class="headerlink" title="如何让构造的对象有不同表示"></a>如何让构造的对象有不同表示</h5><p>不知道大家有没有看过「西部世界」，这部电影中的机器人展现出了高度智慧（没看过的话多啦A梦也可以吧），相信大家都想拿一个过来研究一下。</p>
<p>如果我们能够购买到这样的机器人，过程应该是这样的：</p>
<ol>
<li>我们（<code>Client</code>）和出厂商（<code>Director</code>）联系，告诉出厂商需要什么类型的机器人（<code>Product</code>)<br>；</li>
<li>出厂商接单后，设计师将我们需要的机器人的部件（<code>Builder</code>）进行分类筛选，发出构造指令；</li>
<li>不同生产人员（<code>ConcreteBuilder</code>）收到对应部件的构造命令；</li>
<li>各个组件被组装起来变成我们需要的机器人（<code>Product</code>）。</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>有了一个过程的概念，让我们看看代码是如何实现的（模拟的侧重点不同所以将 <code>Robot</code> 的参数改变）：</p>
<ol>
<li><p>厂家决定机器人有哪些结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String sensor;</div><div class="line">    <span class="keyword">private</span> String control;</div><div class="line">    <span class="keyword">private</span> String drive;</div><div class="line">    <span class="keyword">private</span> String shell;</div><div class="line"></div><div class="line">    ... <span class="comment">//省略参数的 set 函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Robot &#123;"</span> +</div><div class="line">                <span class="string">"  Sensor = '"</span> + sensor + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Control = '"</span> + control + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Drive = '"</span> + drive + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", Shell = '"</span> + shell + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义组装机器人的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildSensor</span><span class="params">()</span></span>;  <span class="comment">// 构建传感器模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildControl</span><span class="params">()</span></span>; <span class="comment">// 构建控制模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildDrive</span><span class="params">()</span></span>;   <span class="comment">// 构建驱动模块</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildShell</span><span class="params">()</span></span>;   <span class="comment">// 构建外壳</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Robot <span class="title">getRobot</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现生产工创造并组装组件的具体方式，返回拼装好的机器人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">//创建机器人实例</span></div><div class="line">    Robot robot = <span class="keyword">new</span> Robot();</div><div class="line"></div><div class="line">    <span class="comment">// 生产并组装部件</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildSensor</span><span class="params">()</span> </span>&#123;</div><div class="line">      robot.setSensor(<span class="string">"创建并组装传感器"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... <span class="comment">// 省略部分 Build 函数</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Robot <span class="title">getRobot</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> robot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下达指定给机器人生产与组装人员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(Builder builder)</span></span>&#123;</div><div class="line">        <span class="comment">// 按一定顺序组装机器人</span></div><div class="line">        builder.BuildSensor();</div><div class="line">        builder.BuildControl();</div><div class="line">        builder.BuildDrive();</div><div class="line">        builder.BuildShell();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试机器人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Director director = <span class="keyword">new</span> Director();</div><div class="line">Builder builder = <span class="keyword">new</span> ConcreteBuilder();</div><div class="line"></div><div class="line">director.Construct(builder); <span class="comment">// 发出组装机器人的指令</span></div><div class="line">Robot robot = builder.getRobot(); <span class="comment">// 拿来拼装好的机器人</span></div><div class="line">System.out.println(robot); <span class="comment">// 展示机器人</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从上面的例子中看出我们只关心机器人是否正常运作，但是并不知道机器人拼装的过程。即这种模式的封装性很好。使用该模式可以有效的封装变化，在使用场景中，一般产品类（<code>Product</code>）和建造者(<code>Builder</code>)类是比较稳定的，因此，将主要的业务逻辑封装在导演类（<code>Director</code>）中对整体而言可以取得比较好的稳定性。</p>
<p>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者（<code>ConcreteBuilder</code>)类就可以完成，基本上不用修改之前的代码，因此对原有代码影响很小。</p>
<p>那么，在 Scala 中是否也存在 Java 的问题呢？</p>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><h4 id="仿-java-版"><a href="#仿-Java-版" class="headerlink" title="仿 Java 版"></a>仿 Java 版</h4><p>问题存在是毋庸置疑的，但我们最关心的应该是解决方法，Java 能干的 Scala 肯定也是能做的。在 Scala 中也有类似上文中 「Java —— 变种版」 的实现方式，我们还是采用 <code>Robot</code> 作为例子（因篇幅有限省略参数）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">builder: <span class="type">RobotBuilder</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">val</span> name = builder.name</div><div class="line">    <span class="keyword">val</span> nickname = builder.nickname</div><div class="line">    <span class="keyword">val</span> age = builder.age</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>然后定义一个 <code>Buidler</code> 类:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> code = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> battery = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setName</span></span>(name: <span class="type">String</span>): <span class="type">RobotBuilder</span> = &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span> <span class="comment">// 返回 this 链式调用</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ... <span class="comment">// 省略两个 set 函数</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>() = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="type">Robot</span>(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot: <span class="type">Robot</span> = <span class="keyword">new</span> <span class="type">RobotBuilder</span>()</div><div class="line">  .setCode(<span class="string">"89757"</span>)</div><div class="line">  .setName(<span class="string">"Bat-Man"</span>)</div><div class="line">  .setBattery(<span class="number">88</span>)</div><div class="line">  .build()</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot: <span class="subst">$robot</span> &#125;"</span>)</div></pre></td></tr></table></figure></p>
<p>这个与上方 Java 版本基本无异，当为 <code>Robot</code> 类添加新的字段也不必再创建新的构造器。仅需要通过 <code>RobotBuilder</code> 类进行兼容即可。</p>
<h4 id="case-class-版"><a href="#case-class-版" class="headerlink" title="case class 版"></a>case class 版</h4><p>但是我们可能忽略了一个问题：Scala 作为 「Object-Oriented Meets Functional」 的一门语言，推崇函数式编程和并发，比 Java 更加强调不变性。上文中的 <code>setXXX</code> 已经违背了这个特点，会带来副作用，这并不符合最佳实践。</p>
<p>好在 Scala 拥有样例类，这使得创造者模式的实现变得更加简单：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                   name: <span class="type">String</span> = "",</div><div class="line">                   code:  <span class="type">String</span> = "",</div><div class="line">                   battery :<span class="type">Int</span> = 0</div><div class="line">                  )</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot1 = <span class="type">Robot</span>(</div><div class="line">  code = <span class="string">"89757"</span>,</div><div class="line">  name = <span class="string">"Bat-Man"</span>,</div><div class="line">  battery = <span class="number">99</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">val</span> robot2 = <span class="type">Robot</span>(name = <span class="string">"prefert"</span>)</div><div class="line"></div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot 1: <span class="subst">$robot1</span>"</span>)</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot 2: <span class="subst">$robot2</span>"</span>)</div></pre></td></tr></table></figure></p>
<p>这种实现要比第一种实现更加简洁并且也更易维护，同时解决了第一种中不够 Pure 的缺点。</p>
<h4 id="类型安全type-safe-版"><a href="#类型安全-type-safe-版" class="headerlink" title="类型安全(type-safe) 版"></a>类型安全(<code>type-safe</code>) 版</h4><p>在创建对象的过程中，参数的初始化顺序可能是严格要求的（比如机器人遵循从里到外，从小到大的构造方式）。回顾前面两种方式，我们并不能完全控制参数的初始化顺序。</p>
<p>这里我们给<code>code</code> <code>name</code> 字段设置非空约束。为了确保这些参数都被设置，我们可以结合 <code>sealed</code> 关键字，利用 ADT 来达到这个目的（对 ADT 不熟悉的同学可以参考一下这篇文章<a href="http://scala.cool/2017/03/how-to-use-algebraic-data-type-in-scala-development/" target="_blank" rel="external">如何在 Scala 中利用 ADT 良好地组织业务</a>），同时对 <code>Robot</code> 类做一些修改：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                  code: <span class="type">String</span>,</div><div class="line">                  name: <span class="type">String</span>,</div><div class="line">                  battery: <span class="type">Int</span></div><div class="line">                )</div><div class="line"></div><div class="line"><span class="comment">//  抽象类型定义了构建过程的不同步骤</span></div><div class="line"><span class="comment">// sealed 关键字要求我们要枚举所有的情况，被sealed 声明的 trait仅能被同一文件的的类继承</span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">BuildStep</span></span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">HasCodeStep</span> <span class="keyword">extends</span> <span class="title">BuildStep</span></span></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">HasNameStep</span> <span class="keyword">extends</span> <span class="title">BuildStep</span></span></div></pre></td></tr></table></figure></p>
<p>然后我们改变一下 <code>RobotBuilder</code> 类 ：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;: 为类型上界符号，即 PassedStep 必须是 BuildStep 的子类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBuilder</span>[<span class="type">PassedStep</span> &lt;: <span class="type">BuildStep</span>] <span class="title">private</span>(<span class="params"></span></span></div><div class="line">                                                     var code: <span class="type">String</span>,</div><div class="line">                                                     var name: <span class="type">String</span>,</div><div class="line">                                                     var battery: <span class="type">Int</span></div><div class="line">                                                   ) &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 按实际需求重载构造器</span></div><div class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">""</span>, <span class="string">""</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(pb: <span class="type">RobotBuilder</span>[_]) = <span class="keyword">this</span>(</div><div class="line">    pb.code,</div><div class="line">    pb.name,</div><div class="line">    pb.battery</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setCode</span></span>(code: <span class="type">String</span>): <span class="type">RobotBuilder</span>[<span class="type">HasCodeStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.code = code</div><div class="line">    <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">HasCodeStep</span>](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setName</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> ev: <span class="type">PassedStep</span> =:= <span class="type">HasCodeStep</span>): <span class="type">RobotBuilder</span>[<span class="type">HasNameStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">HasNameStep</span>](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setBattery</span></span>(battery: <span class="type">Int</span>): <span class="type">RobotBuilder</span>[<span class="type">PassedStep</span>] = &#123;</div><div class="line">    <span class="keyword">this</span>.battery = battery</div><div class="line">    <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// =:= 要求 ev 等于 HasAgeStep 类型</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>()(<span class="keyword">implicit</span> ev: <span class="type">PassedStep</span> =:= <span class="type">HasNameStep</span>): <span class="type">Robot</span> = <span class="type">Robot</span>(code, name, battery)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里将 builder 构造器设为 <code>private</code> 类型，即我们不可再使用 <code>new</code> 来创建 builder 了。并且返回类型变成了 <code>RobotBuilder[PassedStep]</code>。</p>
<p>另外我们给需要的方法添加了泛化类型约束，以 <code>build()</code> 函数为例，它限制 <code>HasNameStep</code> 步骤完成后构造器才能成功调用。</p>
<p>现在已经实现构造器已经对外不可见了，我们还需要提供一个命令入口。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RobotBuilder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="keyword">new</span> <span class="type">RobotBuilder</span>[<span class="type">BuildStep</span>]()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>object</code> 在上一篇单例模式中提到过，单独出现时即单例对象(<code>Singleton Object</code>)，当与同名 <code>Class</code> 同时出现时，被称为 <code>class</code> 的伴生对象(<code>companion object</code>)，其中的 <code>apply()</code> 方法用于实例化伴生类。</p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> robot = <span class="type">RobotBuilder</span>()</div><div class="line">  .setName(<span class="string">"tyl"</span>)</div><div class="line">  .setCode(<span class="string">"89757"</span>)</div><div class="line">  .setBattery(<span class="number">99</span>)</div><div class="line">  .build()</div><div class="line"><span class="type">System</span>.out.println(<span class="string">s"Robot: <span class="subst">$robot</span>"</span>)</div></pre></td></tr></table></figure></p>
<p>如果我们少写了 <code>setName</code> 或 <code>setCode</code> 函数，或者颠倒了顺序，编译器都会给出类似下方的错误：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Error</span>:(<span class="number">8</span>, <span class="number">13</span>) <span class="type">Cannot</span> prove that <span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">BuildStep</span> =:= <span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasCodeStep</span>.</div><div class="line">    .setName(<span class="string">"tyl"</span>)</div><div class="line"></div><div class="line">    <span class="type">Error</span>:(<span class="number">8</span>, <span class="number">13</span>) not enough arguments <span class="keyword">for</span> method setName: (<span class="keyword">implicit</span> ev: =:=[<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">BuildStep</span>,<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasCodeStep</span>])<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">RobotBuilder</span>[<span class="type">Builder</span>.<span class="type">Scala</span>.typesafe.<span class="type">HasNameStep</span>].</div><div class="line">    <span class="type">Unspecified</span> value parameter ev.</div><div class="line">        .setName(<span class="string">"tyl"</span>)</div></pre></td></tr></table></figure></p>
<p>因为能够支持在编译期间检查所编写的代码，所以对于需要检查类型的构造方式来说很可靠。</p>
<p>概括来说，<code>type safe</code> 版有如下的优缺点：</p>
<p>优点：</p>
<ul>
<li>对于严格按照顺序（存在相互依赖）的构造场景十分合适</li>
<li>泛化类型约束使得构造时不易出错</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于不需要构造顺序的构造场景来说画蛇添足</li>
<li>参数可变导致副作用</li>
<li>不够简洁</li>
</ul>
<p>Scala 是一门高可扩展性语言，同样也提供了语法帮助我们缓解上述方法的缺点。</p>
<h4 id="require-版"><a href="#require-版" class="headerlink" title="require 版"></a>require 版</h4><p>在 Scala 中我们可以使用 <code>require</code> 关键字进行函数参数限制，类似 Java 中的 <code>assert</code>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params"></span></span></div><div class="line">                  code:  <span class="type">String</span> = "",</div><div class="line">                  name: <span class="type">String</span> = "",</div><div class="line">                  battery :<span class="type">Int</span> = 0</div><div class="line">                  )&#123;</div><div class="line">  require(code != <span class="string">""</span>, <span class="string">"不可缺少 code 参数"</span>)</div><div class="line">  require(name != <span class="string">""</span>, <span class="string">"不可缺少 name 参数"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码非常简洁，并且也满足我们的需求，这才像函数式风格啊（另外数据验证我们也可以通过第三方类库 <code>refined</code> 来实现，感兴趣的同学可以看一看<a href="https://github.com/fthomas/refined" target="_blank" rel="external">refined: simple refinement types for Scala</a>！</p>
<p>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">val</span> robot2 = <span class="type">Robot</span>(name = <span class="string">"Bat-Man"</span>)</div><div class="line">&#125;<span class="keyword">catch</span> &#123;</div><div class="line">  <span class="keyword">case</span> e :<span class="type">Throwable</span> =&gt; e.printStackTrace()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们在创建的时候少写参数，或者任何不符合 <code>require</code> 条件的行为都会导致抛出异常：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.<span class="type">IllegalArgumentException</span>: requirement failed: 不可缺少 code 参数</div><div class="line">	at scala.<span class="type">Predef</span>$.require(<span class="type">Predef</span>.scala:<span class="number">277</span>)</div><div class="line">	at <span class="type">Builder</span>.<span class="type">Scala</span>.require.<span class="type">Robot</span>.&lt;init&gt;(<span class="type">Robot</span>.scala:<span class="number">12</span>)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过以上的例子我们可以得出 Builder 模式使用的场景大致如下：</p>
<ul>
<li>当对象具有大量可选参数时。</li>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>
<p>另外，对比 Scala 和 Java 的实现，因为两者设计的初衷不同，所以也铸就了不同的语言特性。对于 Scala 而言，避免副作用是需要优先考虑的，当然 Scala 也有着很多语法糖来帮助开发者实现。<br>在 Java 和 Scala 中，实现 Buidler 模式的方式都很多，我们可以参考三种场景来选择恰当的方式实现，最大程度的提高开发效率。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples/tree/master/src/Builder" target="_blank" rel="external">源码链接</a><br>如有错误和讲述不恰当的地方还请指出，不胜感激！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建者模式（Builder Pattern）支持以类方法而非类构造器的方式来创建实例。当一个类的构造器拥有多个版本以支持不同的用途时，这种模式尤其有用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 与设计模式（一）：Singleton 单例模式</title>
    <link href="http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/"/>
    <id>http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/</id>
    <published>2017-07-09T08:04:13.000Z</published>
    <updated>2017-07-12T23:14:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（<code>Singleton Pattern</code>）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<a id="more"></a>
<p>二十年前，软件设计领域的四位大师（GoF，“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson &amp; John Vlissides）通过论著《设计模式：可复用面向对象软件的基础》阐述了设计模式领域的开创性成果。设计模式（<code>Design Pattern</code>）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<p>在 2017 年的今天，虽然一些传统的设计模式仍然适用，但部分设计已经发生改变，甚至被全新的语言特征所取代。<br>本系列文章首先会介绍传统的设计模式在 Java 与 Scala 中的实现，之后会介绍 Scala 可以实现的 “新” 的设计模式。</p>
<p>本文将会简单介绍单例模式在 Java 中的实现方式，以及如何将单例模式应用在 Scala 中，通过比较来阐述单例模式。</p>
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#why-singleton">Why Singleton</a></li>
<li><a href="#结构图">结构图</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#饿汉-基础版">饿汉 —— 基础版</a></li>
<li><a href="#懒汉-基础版">懒汉 —— 基础版</a></li>
<li><a href="#懒汉-双重检查锁版double-checked-locking">懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</a></li>
<li><a href="#静态内部类版">静态内部类版</a></li>
<li><a href="#枚举类模式">枚举类模式</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#object">object</a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。  </p>
</blockquote>
<p>通俗一点单例类就是：全局可以访问的唯一实例。</p>
<h2 id="why-singleton"><a href="#Why-Singleton" class="headerlink" title="Why Singleton"></a>Why Singleton</h2><p>什么时候需要使用单例模式呢？ 如果某个类创建时需要消耗很多资源，即创建出这个类的代价很大时我们就需要使用单例模式。通俗的讲，我们可以将单例对象比作地球，因为很难创建出第二颗这样的星球，这时我们就需要共用地球。</p>
<p>在编写程序的时候，很多操作都会占用大量的资源，如：日志类、配置类、共享资源类等等，我们倡导节能减排，高效利用资源。所以，对于这些操作我们需要一个全局的可访问接口的实现（也可能是懒加载）。</p>
<p>但是我们如何才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但是它并不可以防止我们实例化多个对象。一个更有效的方法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求),并且它可以提供一个访问该实例的方法。这就是单例模式。  </p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://om6vvgjw7.bkt.clouddn.com/Singleton-dp.PNG" alt="singleton"></p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>单例模式应该是 Java 中最出名的设计模式，虽然 Java 语言中包含了静态关键词( <code>static</code>)，但是静态成员与任何对象都不存在直接联系，并且静态成员类不能实现接口。因此，静态方法的概念违背了 <a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">OOP</a> 的前提：所有东西都是对象。  </p>
<p>一般来说在 Java 中单例模式有两种形式：<strong>饿汉模式（eager）</strong>、<strong>懒汉模式(lazy)</strong> 。</p>
<h4 id="饿汉-基础版"><a href="#饿汉-——-基础版" class="headerlink" title="饿汉 —— 基础版"></a>饿汉 —— 基础版</h4><p>对于一个初学者来说，写出的第一个单例类应该是类似下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingleton is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        HungrySingleton.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码中有了全局访问点，同时单例类也是静态的，看着也比较清晰。</p>
<p>运行测试代码后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HungrySingleton is created</div><div class="line">HungrySingleton is running</div></pre></td></tr></table></figure></p>
<p>从以上结果我们可以发现这种模式有一个缺点: 不是惰性初始化(<code>lazy initialization</code>)，即单例会在 JVM 加载单例类后一开始就被初始化，如果此时单例类在系统中还扮演其他角色，不管是否用到都会初始化这个单例变量。因为这种写法下单例会被立即初始化，所以我们称这种单例为 <strong>饿汉 (eager)</strong> 。</p>
<h4 id="懒汉-基础版"><a href="#懒汉-——-基础版" class="headerlink" title="懒汉 —— 基础版"></a>懒汉 —— 基础版</h4><p>为了解决上述的问题，我们就需要引入延迟加载。比较容易想到的做法是：在获取实例的时候判断实例是否存在，不存在则创建。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonOne</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonOne instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is created"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingletonOne();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LazySingletonOne.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LazySingletonOne is running</div></pre></td></tr></table></figure></p>
<p>可见这种形式在这样的环境下确实已经能满足我们的需求。但是在多线程环境下，缺点就非常明显：会出现创建出多个实例的情况（由于篇幅限制，测试代码见文末源码）。这时候通常的做法是在方法上加一个同步锁<br>（<code>synchronized</code>），但是仅仅这样就够了吗？</p>
<h4 id="懒汉-双重检查锁版double-checked-locking"><a href="#懒汉-——-双重检查锁版-Double-checked-locking" class="headerlink" title="懒汉 —— 双重检查锁版(Double-checked locking)"></a>懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</h4><p>在 <code>getInstance</code> 整个方法外加同步锁（<code>synchronized</code>），每次访会还是会造成很大的性能开销。我们就只能在方法的临界区做一些文章，<code>Double-checked locking</code> 应声而至。<br>我们先看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingletonTwo instance;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">// 第一次检查</span></div><div class="line">          <span class="keyword">synchronized</span> (LazySingletonTwo.class) &#123;</div><div class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">// 第二次检查</span></div><div class="line">                  instance = <span class="keyword">new</span> LazySingletonTwo();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance ;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>为了避开多次同步锁的开销，我们先判断单例实体是否存在再进行同步锁操作。这样虽然已经能应对大部分的问题，但是依然存在一个问题：其他线程可能会 <code>read</code> 初始化到一半的 <code>instance</code>。只有将 <code>instance</code> 设置为 <code>volatile</code> ，才能保证每次的 <code>write</code> 操作优先于 <code>read</code> 操作，即能确保每次引用到都是最新状态。<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl" target="_blank" rel="external">了解更多</a><br>只用将代码稍加改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// private static LazySingletonTwo instance;           ----old</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingletonTwo instance;  ----<span class="keyword">new</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong> ：我们至少要创建一个 <code>private</code> 构造器，否则编译器默认将为我们生成一个 <code>friendly</code> 的构造器，而非 <code>private</code>；其次，<code>instance</code> 成员变量和 <code>getInstance()</code> 方法必须是 <code>static</code> 的；如果单例类实现了 <code>java.io.Serializable</code> 接口，就可能被反序列化，从而产生新的实例。</p>
<h4 id="静态内部类版"><a href="#静态内部类版" class="headerlink" title="静态内部类版"></a>静态内部类版</h4><p>除了以上几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedSingleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明为 final 能防止其在派生类中被 clone</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticNestedSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">       System.out.println((<span class="string">"StaticNestedSingleton is created"</span>));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticNestedSingleton <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> NestedClass.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在第一次被引用时被加载</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticNestedSingleton instance = <span class="keyword">new</span> StaticNestedSingleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，我们将单例类设置为 <code>final</code> 类型，这样能够禁止克隆的发生。同样静态内部类只有在第一次被引用时才加载，即随着类的加载而产生（而不是随着对象的产生）。</p>
<h4 id="枚举类模式"><a href="#枚举类模式" class="headerlink" title="枚举类模式"></a>枚举类模式</h4><p>上面的几种使我们常见到的单例类形式，可能有的同学会抱怨道：有没有简短一点的？<br>当然我们还可以使用 Java 中的枚举类实现单例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] preference =</div><div class="line">            &#123; <span class="string">"intresting"</span>,<span class="string">"nice"</span>,<span class="string">"just so so"</span> &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Arrays.toString(preference));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 《Effictive Java》 中所推荐的单例模式在 Java 中的最佳实现方式，同时也是 Stack Overflow 中 <a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="external">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a> 最高票回答。</p>
<p>注意：<code>Enum</code> 与 <code>enum</code> 是不同的。后者只是 Java 1.5 后增加的一个语法糖，不是新的类型。 我们可以反编译 <code>EnumSingleton.class</code> 查看一下内部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ javap EnumSingleton.class</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span>&gt;</span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton.Java.EnumSingleton INSTANCE;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.EnumSingleton[]values();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.<span class="function">EnumSingleton <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">static</span> &#123;&#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>简单总结一下，选用 <code>enum</code> 原因如下：</p>
<ul>
<li><code>enum</code> 防止反序列化重新创建新的对象。</li>
<li>类的修饰 <code>abstract</code>，所以没法实例化，反射也无能为力。</li>
<li>关于线程安全的保证，其实是通过类加载机制来保证的，我们看看 <code>INSTANCE</code> 的实例化时机，是在 <code>static</code> 块中，JVM加载类的过程显然是线程安全的。</li>
</ul>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中并没有 <code>static</code> 关键字，你不用纠结太多，我们用 <code>object</code> 便能实现单例，再也不用为你的选择困难症烦恼！</p>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><code>object</code> 在 Scala 中被称作「伴生对象」 (Singleton Objects)。</p>
<p>object 关键字创建一个新的单例类型，就像一个 class 只有一个被命名的实例。如果你熟悉 Java ,在 Scala 中声明一个 object 有些像创建了一个匿名类的实例。     ——引自  Scala 函数式编程 </p>
<p>举个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singleton2Scala</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(l: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = l.sum</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="type">Singleton2Scala</span>.sum(<span class="type">List</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来是不是比 Java 优雅多了！  </p>
<p>你问有没有多线程问题？是否是惰性初始化？这些都不用你来处理。</p>
<p>Scala 被编译后生成 <code>&#39;Singleton2Scala$.class&#39;</code> 和  <code>Singleton2Scala.class</code>，我们可以对其进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ javap  &apos;Singleton2Scala$.class&apos;</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala$ &#123;</div><div class="line">  public static Singleton.Scala.Singleton2Scala$ MODULE$;</div><div class="line">  public static &#123;&#125;;</div><div class="line">  public int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">$ javap  Singleton2Scala.class</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala &#123;</div><div class="line">  public static int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上方代码我们能看到，所有的方法前都带上了 <code>static</code> 关键字。</p>
<p>在实际项目开发的时候，我们还可以继承其他 类 与 特质。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">xxClass</span> <span class="keyword">with</span> <span class="title">xxtrait</span></span>&#123;</div><div class="line">  println(<span class="string">"Registry initialization block called."</span>)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> lazyXX  = ???</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users: scala.collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>] =  scala.collection.mutable.<span class="type">HashMap</span>.empty</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addUser</span></span>(id: <span class="type">String</span>, name: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.put(id, name) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>(id: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.remove(id) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUserRegistered</span></span>(id: <span class="type">String</span>): <span class="type">Boolean</span> = users.contains(id)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAllUserNames</span></span>(): <span class="type">List</span>[<span class="type">String</span>] = users.map(_._2).toList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比 <code>static class</code> 更易于理解  </li>
<li>语法简洁</li>
<li>按需初始化(<code>lazy initialization</code>)</li>
<li>线程安全(Scala 中不用考虑 <code>double-checked locking</code>)  </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>缺乏对初始化行为的控制  </li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是对 Scala 和 Java 是实现单例模式的一个简单比较：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Java</th>
<th style="text-align:center">Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td><code>static</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>多线程</td>
<td><code>synchronized</code> +  <code>volatile</code></td>
<td style="text-align:center"><code>object</code></td>
</tr>
<tr>
<td>延迟加载</td>
<td><code>enum</code> 、 <code>double-checked locking</code></td>
<td style="text-align:center"><code>object</code> + <code>lazy</code>(内部参数延迟加载)</td>
</tr>
</tbody>
</table>
<p>人们对单例模式的看法褒贬不一，甚至被称为是 <code>anti-pattern</code> (反面模式）。如果你是一名 Java 开发者，可能 Spring 框架中 <code>Dependency Injection</code> 是你的更优先的选择。但是单例模式你不能否认的是单例模式在 Android SDK 中得到了广泛的应用。在 Scala 中，伴生对象出现的频率更是非常之高。当你面对的业务场景需要用到单例模式的时候，请务必注意 <strong>多线程</strong> 与 <strong>性能开销</strong> 的问题。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples" target="_blank" rel="external">源码链接</a><br>如有说错的地方还请指出，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（&lt;code&gt;Singleton Pattern&lt;/code&gt;）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web前端模块化发展历程</title>
    <link href="http://prefer-tyl.site/2017/06/27/front-page-modular-history/"/>
    <id>http://prefer-tyl.site/2017/06/27/front-page-modular-history/</id>
    <published>2017-06-27T12:00:13.000Z</published>
    <updated>2017-06-27T15:24:03.892Z</updated>
    
    <content type="html"><![CDATA[<p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是模块化">1. 什么是模块化</a></li>
<li><a href="#2-为什么要模块化">2. 为什么要模块化</a></li>
<li><a href="#3-web-前端的模块化的历史浪潮">3. Web 前端的模块化的历史浪潮</a><ul>
<li><a href="#31-发展历史">3.1 发展历史</a></li>
<li><a href="#311-函数封装">3.1.1 函数封装</a></li>
<li><a href="#312-对象">3.1.2 对象</a></li>
<li><a href="#313-立即执行函数immediately-invoked-function-expression">3.1.3 立即执行函数(immediately-invoked function expression )</a></li>
<li><a href="#314-script-loader">3.1.4 Script Loader</a><ul>
<li><a href="#labjs">LABjs</a></li>
<li><a href="#commonjs">CommonJS</a></li>
<li><a href="#双塔奇兵-amdcmd">双塔奇兵 AMD/CMD</a></li>
</ul>
</li>
<li><a href="#32-解决方案">3.2 解决方案</a><ul>
<li><a href="#webpack">Webpack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-未来的模块化">4. 未来的模块化</a><ul>
<li><a href="#webassembly-是什么">WebAssembly 是什么</a></li>
<li><a href="#webassembly-的目标">WebAssembly 的目标</a></li>
<li><a href="#webassembly-的核心">WebAssembly 的核心</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1. 什么是模块化"></a>1. 什么是模块化</h2><p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
<h2 id="2-为什么要模块化"><a href="#2-为什么要模块化" class="headerlink" title="2. 为什么要模块化"></a>2. 为什么要模块化</h2><p>随着互联网的飞速发展，新的前端框架与技术不断涌现。这些框架在带给开发者便利的同时，也带去了维护困难的隐患———项目逻辑的复杂化与代码库膨胀。我们可以将原因概括为以下三点：  </p>
<ul>
<li>Web 网站正在转变为 Web 应用  </li>
<li>网站规模越大，代码也越来越复杂   </li>
<li>高度解耦的 JS 文件被大家所需求<br>前端开发领域(<code>JavaScript</code>、<code>CSS</code>、<code>Template</code>)并没有为开发者们提供以一种简洁、有条理地的方式来管理模块的方法。为了解决以上问题，我们必须进行合理的模块化管理。  </li>
</ul>
<p>熟悉 Java 语言的同学都知道，在 Java 中有一个重要的概念——<code>package</code> (包)，我们会将相同逻辑的代码放到一个 <code>package</code> 下，在需要的地方 <code>import</code> (引入)即可。    </p>
<p>前端是否有类似 <code>package</code> 的概念呢？  </p>
<h2 id="3-web-前端的模块化的历史浪潮"><a href="#3-Web-前端的模块化的历史浪潮" class="headerlink" title="3. Web 前端的模块化的历史浪潮"></a>3. Web 前端的模块化的历史浪潮</h2><h3 id="31-发展历史"><a href="#3-1-发展历史" class="headerlink" title="3.1 发展历史"></a>3.1 发展历史</h3><p>由于 JavaScript 这门语言设计用时非常短，所以很多方面都没有考虑周全。好在它的生态圈非常强大，广大开发者为了更好的使用它，对它不断优化。</p>
<h3 id="311-函数封装"><a href="#3-1-1-函数封装" class="headerlink" title="3.1.1 函数封装"></a>3.1.1 函数封装</h3><p>  最早期的时候，我们在一个文件里编写相关函数，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要的时候加载文件并调用相关函数即可。<br><strong>缺点：Global 被污染，代码中很容易出现命名冲突。</strong>  </p>
<h3 id="312-对象"><a href="#3-1-2-对象" class="headerlink" title="3.1.2 对象"></a>3.1.2 对象</h3><p>为了解决上面的问题，我们又将一个个文件划分为一个个对象，这样在加载的时候就不用加载很多文件。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MYAPP = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">MYAPP.foo(); <span class="comment">//需要时执行</span></div></pre></td></tr></table></figure></p>
<p>这样虽然能减少 Global 上的变量数目，避免变量污染。但是<strong>本质是对象，外部对象可以对其他对象进行修改，很不安全</strong>。  </p>
<h3 id="313-立即执行函数immediately-invoked-function-expression"><a href="#3-1-3-立即执行函数-immediately-invoked-function-expression" class="headerlink" title="3.1.3 立即执行函数(immediately-invoked function expression )"></a>3.1.3 立即执行函数(immediately-invoked function expression )</h3><blockquote>
<p>IIFE (立即调用函数表达式) 是一个 JavaScript 函数 ，它会在定义时立即执行.<br>也有人将 IIFE 称为匿名闭包.</p>
</blockquote>
<p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _private = <span class="string">"safe now"</span>;</div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_private)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: foo</div><div class="line">    &#125;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">Module.foo();</div><div class="line">Module._private; <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>我们可以调用定义的方法，但是不能调用定义的属性。这样的模式使得变量冲突降到最低，并且能够控制暴露的方法(类似于接口）。这便是现代模块实现的基石！  </p>
<h3 id="314-script-loader"><a href="#3-1-4-Script-Loader" class="headerlink" title="3.1.4 Script Loader"></a>3.1.4 Script Loader</h3><p>最原始的 JS 加载方法就是在 Html 头文件中通过 Script 标签直接引入，类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"http://remote.tld/jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/plugin1.jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/plugin2.jquery.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"local/init.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	initMyPage();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>初学者可能会有疑问，全都写在一个文件中看着不是挺方便的吗？<br>首先以上列举的可能只是实际项目中的一小部分，其次不要忽视 <code>&lt;script&gt;</code> 的一个特点：<code>并行加载，顺序执行</code>，这要求开发者需要按照严格的读取顺序，并且很有可能会阻塞阻止文档渲染(<code>async</code> 新特性在 HTML5 中才提出)。文件少的时候写起来会很方便，一旦项目变复杂缺点就会暴露无疑：<strong>难以维护，依赖模糊，请求过多</strong> 。  </p>
<h4 id="labjs"><a href="#LABjs" class="headerlink" title="LABjs"></a>LABjs</h4><p>为了解决依赖模糊，我们迫切需要一个加载器（<code>Loader</code>）最先出现在开发者视野中的 <code>Loader</code> 应该是 <a href="https://github.com/getify/LABjs]" target="_blank" rel="external"><code>LABjs</code></a>(2009)（ HTML5 发布才有了 <code>async</code> 特性）</p>
<blockquote>
<p>LABjs 的核心是 LAB（Loading and Blocking）：Loading 指异步并行加载，Blocking 是指同步等待执行。  </p>
</blockquote>
<p>通过使用 LABjs ,上方代码就可以变成这样：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"LAB.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  $LAB</div><div class="line">  .script(<span class="string">"http://remote.tld/jquery.js"</span>).wait()<span class="comment">//`.wait` 表示加载后立即运行</span></div><div class="line">  .script(<span class="string">"/local/plugin1.jquery.js"</span>)</div><div class="line">  .script(<span class="string">"/local/plugin2.jquery.js"</span>).wait()</div><div class="line">  .script(<span class="string">"/local/init.js"</span>).wait(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      initMyPage();</div><div class="line">  &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>当然同一时期风靡的还有类库模块化框架 <a href="https://yuilibrary.com/" target="_blank" rel="external">YUI</a>，大家可自行查阅。</p>
<h4 id="commonjs"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>在开发者们拼命为浏览器兼容等问题绞尽脑汁的时候，CommonJS 横空出世！<br>服务器端的 <code>Node.js</code> 遵循 <a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">CommonJS规范</a>，该规范的核心思想是允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</div><div class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">module</span>.exports = someValue;</div></pre></td></tr></table></figure>
<p>这是 JavaScript 第一次真正意义上跳出浏览器，被人们尊称为模块化的第一座里程碑（<code>MODULES/1.0</code>）。给开发者们带来了以下便捷之处：</p>
<p>优点:  </p>
<ul>
<li>服务器端模块便于重用  </li>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">NPM</a> 中已经有将近20万个可以使用模块包  </li>
<li>简单并容易使用  </li>
</ul>
<p>缺点：  </p>
<ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的  </li>
<li>不能非阻塞的并行加载多个模块  </li>
</ul>
<p>实现:  </p>
<ul>
<li>NodeJS</li>
</ul>
<h4 id="双塔奇兵-amdcmd"><a href="#双塔奇兵-AMD-CMD" class="headerlink" title="双塔奇兵 AMD/CMD"></a>双塔奇兵 AMD/CMD</h4><table>
<thead>
<tr>
<th>-</th>
<th style="text-align:left">AMD</th>
<th style="text-align:left">CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念</td>
<td style="text-align:left"><a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="external">Asynchronous Module Definition</a> 规范其实只有一个主要接口 <code>define(id?, dependencies?, factory)</code>，它要在声明模块的时候指定所有的依赖 <code>dependencies</code>，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</td>
<td style="text-align:left"><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="external">Common Module Definition</a> 规范和 AMD 很相似，尽量保持简单，并与 <code>CommonJS</code> 和 <code>Node.js</code> 的 <code>Modules 规范</code> 保持了很大的兼容性。</td>
</tr>
<tr>
<td>优点</td>
<td style="text-align:left">1. 适合在浏览器环境中异步加载模块<br> 2. 可以并行加载多个模块</td>
<td style="text-align:left">1. 依赖就近，延迟执行 <br> 2. 可以很容易在 Node.js 中运行</td>
</tr>
<tr>
<td>缺点</td>
<td style="text-align:left">1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅<br> 2. 不符合通用的模块化思维方式，是一种妥协的实现</td>
<td style="text-align:left">依赖 SPM 打包，模块的加载逻辑偏重</td>
</tr>
<tr>
<td>实现</td>
<td style="text-align:left"><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a></td>
<td style="text-align:left"><a href="http://seajs.org/" target="_blank" rel="external">SeaJS</a></td>
</tr>
</tbody>
</table>
<p>两者最明显的区别可以从以下代码中查看：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</span></div><div class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    a.doSomething();    <span class="comment">// 依赖前置，提前执行</span></div><div class="line">    b.doSomething();</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//CMD 推崇依赖就近，只有在用到某个模块的时候再去require  </span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"a"</span>);</div><div class="line">    a.doSomething();</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"b"</span>);</div><div class="line">    b.doSomething();    <span class="comment">// 依赖就近，延迟执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>概括而言 Commonjs 用在服务器端，加载是同步的。<br>AMD, CMD 用在浏览器端，加载是异步的。  </p>
<p><code>CommonJS</code> (规划并标准化、致力于设计 JavaScript API)的诞生开启了 “JavaScript 模块化” 的时代。<code>CommonJS</code> 的模块提案为在服务器端的 JavaScript 模块化做出了很大的贡献，但是在浏览器下的 JavaScript 模块应用很有限。随之而来又诞生了其它前端领域的模块化方案，像 requireJS、SeaJS 等，然而这些模块化方案并不是十分适用 ，并没有从根本上解决模块化的问题。</p>
<h3 id="32-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h3><p>前面已经为大家回顾了 JavaScript 的模块化发展历史，然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。如果他们都可以视作模块，并且都可以通过 <code>require</code> 的方式来加载，将带来优雅的开发体验，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>那么如何做到让 <code>require</code> 能加载各种资源呢？  </p>
<h4 id="webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack</a> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
</blockquote>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/what-is-webpack.png" alt="webpack">  </p>
<p>Webpack 的优点可以概括为以下几点：  </p>
<ul>
<li><p><strong>代码拆分</strong><br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。  </p>
</li>
<li><p><strong>Loader</strong><br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。  </p>
</li>
<li><p><strong>智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。  </p>
</li>
<li><p><strong>插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。  </p>
</li>
<li><p><strong>快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。    </p>
</li>
</ul>
<p>当然，光有 <code>Webpack</code> 是不够的，目前大家比较推崇的最佳拍档为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">包管理工具</th>
<th style="text-align:center">模块化构建工具</th>
<th style="text-align:center">模块化规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">npm</td>
<td style="text-align:center">Webpack</td>
<td style="text-align:center">ES6模块</td>
</tr>
</tbody>
</table>
<p>当然，目前比较有许多 “自带模块化buff” 的前端框架（组件化）：<code>Vue</code> 、 <code>React</code>等，它们都有以下特点:  </p>
<ul>
<li>使用 Virtual DOM  </li>
<li>提供了响应式（ Reactive ）和组件化（ Composable ）的视图组件。  </li>
<li>保持注意力集中在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。    </li>
</ul>
<p>在 <code>Vue</code> 中，一个组件文件(<code>.Vue</code>)中，拥有<code>&lt;template&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;style&gt;</code>三个部分。每个组件中管理自己的样式、逻辑，这样在大型项目开发与维护时都起到了非常便捷的作用。  </p>
<h2 id="4-未来的模块化"><a href="#4-未来的模块化" class="headerlink" title="4. 未来的模块化"></a>4. 未来的模块化</h2><p>说到模块化未来的发展，值得一提的便是 <a href="http://webassembly.org/" target="_blank" rel="external">WebAssembly</a>。大家都知道 <code>JavaScript</code> 是一种解释性脚本语言，导致其运行时消耗大量的性能做为代价，这也是 <code>JavaScript</code> 的瓶颈之一。<code>WebAssembly</code> 旨在解决这个问题。  </p>
<h3 id="webassembly-是什么"><a href="#WebAssembly-是什么" class="headerlink" title="WebAssembly 是什么"></a>WebAssembly 是什么</h3><blockquote>
<p> Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.<br>定义一个可移植，体积紧凑，加速迅捷的二进制格式为编译目标，而此二进制格式文件将可以在各种平台（包括移动设备和物联网设备）上被编译，然后发挥通用的性能以原生应用的速度运行。</p>
</blockquote>
<h3 id="webassembly-的目标"><a href="#WebAssembly-的目标" class="headerlink" title="WebAssembly 的目标"></a>WebAssembly 的目标</h3><p>某乎上广传 “谷歌、苹果、谋智、微软一起再一次发明了 Silverlight ”。可以看出，大家对 <code>WebAssembly</code> 充满了信心与期待。  </p>
<p>作为 <a href="https://www.w3.org/community/webassembly" target="_blank" rel="external">W3C WebAssembly Community Group</a> 中的一项开放标准，WebAssembly 是为下列目标而生的：</p>
<ul>
<li>快速、高效、可移植——通过利用常见的硬件能力，WebAssembly 代码在不同平台上能够以接近本地速度运行。  </li>
<li>可读、可调试—— WebAssembly 是一门低阶语言，但是它有确实有一种人类可读的文本格式（其标准即将得到最终版本），这允许通过手工来写代码，看代码以及调试代码。   </li>
<li>保持安全—— WebAssembly 被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略。  </li>
<li>不破坏网络—— WebAssembly 的设计原则是与其他网络技术和谐共处并保持向后兼容。  </li>
</ul>
<h3 id="webassembly-的核心"><a href="#WebAssembly-的核心" class="headerlink" title="WebAssembly 的核心"></a>WebAssembly 的核心</h3><p>那么 WebAssembly 是如何在浏览器中运行的呢？我们可以看一下它的几个关键的概念：  </p>
<ul>
<li><strong>模块</strong> : 表示一个已经被浏览器编译为可执行机器码的 WebAssembly 二进制代码。一个模块是无状态的并且像一个二进制大对象（Blob）一样能够被缓存到 IndexedDB 中或者在 windows 和 workers 之间进行共享（通过 <code>postMessage()</code> 函数）。一个模块能够像一个 ES2015的模块一样声明导入和导出。   </li>
<li><strong>内存</strong> : 一个可变大小的 ArrayBuffer 。它包含了一个连续的字节数组并且 WebAssembly 的低级内存存取指令可对其进行读写操作。  </li>
<li><strong>表格</strong> : 一个可变大小的包含引用类型（比如，函数）的带类型数组。它包含了不能作为原始字节存储在内存中的引用（为了安全和可移植性的原因）。  </li>
<li><strong>实例</strong> : 一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。一个实例就像一个已经被加载到一个拥有一组特定导入的特定的全局变量的 ES2015模块。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面重构应该遵循的基本原则和规范</title>
    <link href="http://prefer-tyl.site/2017/04/30/restructure-web-page/"/>
    <id>http://prefer-tyl.site/2017/04/30/restructure-web-page/</id>
    <published>2017-04-30T00:30:13.000Z</published>
    <updated>2017-06-27T13:06:56.455Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#1-什么是页面重构">1. 什么是页面重构？</a></li>
<li><a href="#2-基本原则和规范">2. 基本原则和规范</a><ul>
<li><a href="#21-常用规范">2.1 常用规范</a></li>
<li><a href="#22-语义化-seo">2.2 语义化 &amp;&amp; SEO</a><ul>
<li><a href="#221-什么是语义化">2.2.1 什么是语义化</a></li>
<li><a href="#222-为什么要让页面语义化">2.2.2 为什么要让页面语义化</a></li>
<li><a href="#223-html-语义化">2.2.3 HTML 语义化</a></li>
<li><a href="#224-css-命名语义化">2.2.4 CSS 命名语义化</a></li>
</ul>
</li>
<li><a href="#23-样式抽离-组件复用">2.3 样式抽离 &amp;&amp; 组件复用</a></li>
</ul>
</li>
<li><a href="#3-总结">3. 总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-什么是页面重构"><a href="#1-什么是页面重构？" class="headerlink" title="1. 什么是页面重构？"></a>1. 什么是页面重构？</h2><p>简单来说，页面重构就是：<strong>将设计稿转换成 WEB 页面</strong>。  </p>
<p>那我们重构时该注意哪些东西呢？  </p>
<h2 id="2-基本原则和规范"><a href="#2-基本原则和规范" class="headerlink" title="2. 基本原则和规范"></a>2. 基本原则和规范</h2><p>在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护。  </p>
<h3 id="21-常用规范"><a href="#2-1-常用规范" class="headerlink" title="2.1 常用规范"></a>2.1 常用规范</h3><p>与使用其他语言开发工程一样，我们需要有着统一的规范，最常见就是 <strong>编码风格</strong>，比如：  </p>
<ol>
<li><p><strong>空格</strong>  </p>
<ul>
<li>等号前后空格、运算符前后使用空格分隔   </li>
<li>在逗号和冒号后添加空格  </li>
</ul>
</li>
<li><p><strong>空行</strong>  </p>
<ul>
<li>为每个逻辑功能块添加空行，这样更易于阅读    </li>
<li>将左花括号与选择器放在同一行  </li>
<li>将右花括号独立放在一行，并以分号作为结束符号  </li>
</ul>
</li>
<li><p><strong>缩进</strong>  </p>
<ul>
<li>缩进使用两个空格(不要使用制表符)    </li>
</ul>
</li>
</ol>
<p>其次是 <strong>命名</strong>，我们建议对 HTML 元素名称，属性，属性值，CSS 选择器，属性和属性值（字符串除外）使用小写字母命名，并且使用 <code>-</code> 进行分隔，举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">id</span>=<span class="string">"href-index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span>  </div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#E5E5E5</span>;  </div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#e5e5e5</span>;</div></pre></td></tr></table></figure>
<p>另外还有书写顺序，比较常见的 CSS 样式书写顺序如下：  </p>
<ol>
<li>位置属性(<code>position</code>, <code>top</code>, <code>right</code>, <code>z-index</code>, <code>display</code>, <code>float</code> 等)  </li>
<li>大小(<code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>)  </li>
<li>文字系列( <code>font</code>, <code>line-height</code>, <code>letter-spacing</code>, <code>color</code>, <code>text-align</code> 等)  </li>
<li>背景(<code>background</code>, <code>border</code> 等)  </li>
<li>其他(<code>animation</code>, <code>transition</code> 等)  </li>
</ol>
<p>以上仅列举了部分规范，更多请参考 <a href="http://eslint.cn/docs/rules/" target="_blank" rel="external">ESLint</a>  </p>
<h3 id="22-语义化-ampamp-seo"><a href="#2-2-语义化-amp-amp-SEO" class="headerlink" title="2.2 语义化 &amp;&amp; SEO"></a>2.2 语义化 &amp;&amp; SEO</h3><h4 id="221-什么是语义化"><a href="#2-2-1-什么是语义化" class="headerlink" title="2.2.1 什么是语义化"></a>2.2.1 什么是语义化</h4><blockquote>
<p>语义化是指使用恰当语义的 HTML 标签、class 类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。  </p>
</blockquote>
<h4 id="222-为什么要让页面语义化"><a href="#2-2-2-为什么要让页面语义化" class="headerlink" title="2.2.2 为什么要让页面语义化"></a>2.2.2 为什么要让页面语义化</h4><p>语义化的好处 ：  </p>
<ul>
<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构  </li>
<li><strong>有利于</strong> <a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="external">SEO</a> ( Search Engine Optimization——搜索引擎优化)：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重    </li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以特殊的方式来渲染网页     </li>
<li>便于团队开发和维护，可以减少很多差异化，减少成员间沟通成本，方便开发和后期维护，利于实现模块化开发</li>
</ul>
<h4 id="223-html-语义化"><a href="#2-2-3-HTML-语义化" class="headerlink" title="2.2.3 HTML 语义化"></a>2.2.3 HTML 语义化</h4><p>假设我们要开发一个页面，在 HTML5 出现之前，页面架构很有可能是下面这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%89%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的架构缺点比较明显：  </p>
<ul>
<li>需要用到很多 <code>div</code> 标签,但实际上 <code>div</code> 标签并没有语义，这不利于爬虫对页面内容进行抓取  </li>
<li>文档结构不明确。也许你认为有 <code>id</code> 就足够了，但是后面会发现在一大堆 <code>&lt;div&gt;</code> 中找出这些 <code>id</code> 并不高效</li>
</ul>
<p>于是，在 HTML5 中，页面架构变成了这样的：  </p>
<p><img src="http://ootgqk2ga.bkt.clouddn.com/%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84-html5%E4%B9%8B%E5%90%8E%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="">  </p>
<p>这样的结构看起来就清晰多了，我们可以直接从标签名称得知它的作用。  </p>
<p>当然，我们也不是说将所有的 <code>div</code> 全部替换为对应的语义化标签(比如考虑到网页兼容问题)，具体情况应具体分析。  </p>
<p>根据应用场景，一些常用的标签元素有：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">主要语义</th>
<th style="text-align:left">元素名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">本身无语义，组合其他 HTML 元素，常用于页面布局</td>
<td style="text-align:left"><code>div</code></td>
</tr>
<tr>
<td style="text-align:left">设置文本，填充段落</td>
<td style="text-align:left"><code>h1~h6</code>, <code>p</code>, <code>span</code>, <code>strong</code>, <code>em</code>…</td>
</tr>
<tr>
<td style="text-align:left">表现列表</td>
<td style="text-align:left"><code>ul</code>, <code>li</code>, <code>ol</code>, <code>dl</code>, <code>dt</code>, <code>dd</code></td>
</tr>
<tr>
<td style="text-align:left">表单相关</td>
<td style="text-align:left"><code>form</code>,<code>input</code>,<code>select</code>,<code>button</code></td>
</tr>
<tr>
<td style="text-align:left">表格相关</td>
<td style="text-align:left"><code>table</code>,<code>thead</code>,<code>tbody</code>,<code>tfoot</code>,<code>th</code>,<code>tr</code>,<code>td</code></td>
</tr>
<tr>
<td style="text-align:left">图像显示</td>
<td style="text-align:left"><code>img</code>, <code>canvas</code></td>
</tr>
<tr>
<td style="text-align:left">打开链接，发送邮件，段落跳转</td>
<td style="text-align:left"><code>a</code></td>
</tr>
</tbody>
</table>
<h4 id="224-css-命名语义化"><a href="#2-2-4-CSS-命名语义化" class="headerlink" title="2.2.4 CSS 命名语义化"></a>2.2.4 CSS 命名语义化</h4><p>CSS 命名的语义就是 <code>class</code> 和 <code>id</code> 命名的语义。<br><code>class</code> 属性作为 HTML 与 CSS 衔接的纽带，其本意是用来描述元素内容的。指用易于理解的名称对 HTML 标签附加的 <code>class</code> 或 <code>id</code> 命名。如果说 HTML 语义化标签是给机器看的，那么 CSS 命名的语义化就是给人看的。良好的 CSS 命名方式减少沟通调试成本，易于理解。  </p>
<p>CSS 命名首先要满足 W3C 的命名规范和团队的命名规范。其次是高效和可重用性。  </p>
<p>就好像 <code>.main</code> / <code>.sidebar</code> 会比 <code>.left_content</code> / <code>.right_content</code> 的 class 命名灵活性更好。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 以表现为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"lr margin10"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 以信息为中心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"user-info"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>nickName:seg<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="23-样式抽离-ampamp-组件复用"><a href="#2-3-样式抽离-amp-amp-组件复用" class="headerlink" title="2.3 样式抽离 &amp;&amp; 组件复用"></a>2.3 样式抽离 &amp;&amp; 组件复用</h3><p>在后端开发中，我们常常将一些公共的字符串、函数等抽离出来，在需要的地方便可方便的调用。前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>前端页面重构的时候，我们同样要注意组件的复用、组合性。</p>
<p>在 前端模块化 的历史演变中，曾有一段时期我们会这样构造组件：  </p>
<ul>
<li><strong>base</strong> 提供最底层的、功能和粒度最小的的通用类样式，可以被所有页面引用  </li>
<li><strong>common</strong> 出现频率高，功能相对独立的组件，如 <code>Button</code>、<code>Dialog</code>、<code>Tooltip</code> 等  </li>
<li><strong>page</strong> 各页面独有的样式，实际中可划分为 <code>page-index.css</code> 、<code>page-dashboard.css</code> 等  </li>
</ul>
<p>但是随着工程的逐渐壮大，使用及维护起来还是比较困难。我们期望 组件/样式 有着 “按需引入，即插即用” 的特性。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</div></pre></td></tr></table></figure></p>
<p>为了实现这样的引入方式，我们需要使用 Loader 。  </p>
<p>Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 <code>require</code> 来加载任何类型的模块或文件。  </p>
<p>如果我们要在 <code>index.html</code> 引入一个 CSS 文件 <code>style.css</code>，首页将 <code>style.css</code> 也看成是一个模块，然后用 <code>css-loader</code> 来读取它，再用 <code>style-loader</code> 把它插入到页面中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* style.css */</div><div class="line">body &#123; background: yellow; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"!style-loader!css-loader!./style.css"</span>) <span class="comment">// 载入 style.css</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>安装 loader :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://vuefe.cn/v2/guide/index.html" target="_blank" rel="external">Vue.js</a> 中，我们可以将 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 都写于一个 <code>.vue</code> 格式的文件中，一个文件便对应一个组件，并且可以在其他组件中很方便的引入。  </p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>当然，除了以上几点，我们需要遵循的原则和规范还很多。总的来说，页面重构时，在规范编码的基础上我们首先考虑的因素便是语义化：HTML 标签语义化、CSS 命名语义化等等。语义化的最终目的就是使得人与机器对页面识别度更高。其次，为了方便协作与后期维护，我们应该考虑组件复用、样式抽离，或者说模块化等。原则和规范并不总是一成不变的，随着前端技术的快速发展，高效、便于协作与维护的方式便是最佳原则与规范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，页面重构就是：将设计稿转换成 WEB 页面。在多人协同完成一个大型工程时，必要的原则与规范不仅能加快开发效率，更能使工程有着更好的体系结构，方便维护…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

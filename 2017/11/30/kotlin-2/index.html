<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> kotlin 类型结构设计 · Prefert</title><meta name="description" content="kotlin 类型结构设计 - Prefert"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avator.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://prefer-tyl.site/atom.xml" title="Prefert"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avator.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/YarenTang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">kotlin 类型结构设计</h1><div class="post-info">Nov 30, 2017</div><div class="post-content"><p>无论在静态语言还是动态语言中，「类型系统」都起到了至关重要的作用。<br><a id="more"></a></p>
<h4 id="类型系统简介"><a href="#类型系统简介" class="headerlink" title="类型系统简介"></a>类型系统简介</h4><blockquote>
<p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。</p>
<p>类型可以确认一个值或者一组值具有特定的意义和目的（虽然某些类型，如抽象类型和函数类型，在程序运行中，可能不表示为值）。</p>
</blockquote>
<h4 id="类型系统的作用"><a href="#类型系统的作用" class="headerlink" title="类型系统的作用"></a>类型系统的作用</h4><p>类型系统在各种语言之间存在比较大的差异。最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。</p>
<p>但是他们的目的都是一致的：</p>
<p><strong>1. 安全</strong>，有了类型系统以后就可以实现类型安全，这时候程序就变成了一个严格的数学证明过程，编译器可以机械地验证程序某种程度的正确性，从而杜绝很多错误的发生。比如：Scala、Java。但是 JavaScript 等动态语言/弱类型语言就要借助其他插件（如 ESLint）来提示语法等错误。</p>
<p><strong>2. 抽象能力</strong>。在安全的前提下，一个强大的类型系统的标准是抽象能力，能将程序中的很多东西纳入安全的类型系统中进行抽象，这在安全性的前提下又不损耗灵活性，甚至性能也能很优化。动态语言的抽象能力可以很强，但安全性和性能就不行了。泛型、高阶函数（闭包）、类型类、<code>Monad</code>、<code>Lifetime</code>（Rust） 属于这一块。</p>
<p><strong>3. 工程能力</strong>，一个强类型的编程语言比动态类型的语言更适合大规模软件的构建，哪怕不存在性能问题，但是同样取决于前两点。</p>
<blockquote>
<p>Hint: 想深入了解类型系统的朋友可以参考 <a href="http://www.cs.colorado.edu/~bec/courses/csci5535/reading/cardelli-typesystems.pdf" target="_blank" rel="external">《Type Systems》</a>和 <a href="http://www.ling.ohio-state.edu/~pollard.4/type/books/pierce-tpl.pdf" target="_blank" rel="external">《Types and Programming》</a></p>
</blockquote>
<p>Kotlin 作为一门静态类型编程语言，同样拥有着强大的类型系统。</p>
<p><img src="kotlin-types.png" alt="Kotlin types"></p>
<h2 id="kotlin-的类型系统"><a href="#Kotlin-的类型系统" class="headerlink" title="Kotlin 的类型系统"></a>Kotlin 的类型系统</h2><h3 id="11-基本数据类型-intboolean-及其他"><a href="#1-1-基本数据类型-——-Int-Boolean-及其他" class="headerlink" title="1.1 基本数据类型 —— Int,Boolean 及其他"></a>1.1 基本数据类型 —— Int,Boolean 及其他</h3><p>我们都知道，Java 将 <strong>基本数据类型</strong> 和 <strong>引用类型</strong> 做了区分：</p>
<ul>
<li>基本数据类型，例如 int 的变量直接存储了它的值，我们不能对这些值调用方法，或者把它们放到集合中。</li>
<li>引用类型的变量存储的是指向包含该对象的内存地址的引用。</li>
</ul>
<p>在 Kotlin 中，并不区分基本数据类型和包装类型——你使用的永远是同一个类型。  </p>
<h3 id="12-数字转换"><a href="#1-2-数字转换" class="headerlink" title="1.2 数字转换"></a>1.2 数字转换</h3><p>Kotlin 中我们必须使用 <strong>显示转换</strong> 来对数字进行转换,例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> z = <span class="number">13</span></div><div class="line">  println(z.toLong() <span class="keyword">in</span> list(<span class="number">2</span>L, <span class="number">0</span>L, <span class="number">3</span>L))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果觉得这种方式不够简便，你也可以尝试使用 Kotlin 中的字面量：</p>
<ul>
<li>使用后缀 <code>L</code> 表示 <code>Long</code>: <code>123L</code></li>
<li>使用后缀 <code>F</code> 表示 <code>Float</code>: <code>.123f</code>、<code>1e3f</code></li>
<li>使用前缀 <code>0x</code> / <code>0X</code> 表示十六进制：<code>0xadcL</code>  </li>
<li>…</li>
</ul>
<p><strong>当你使用数字字面值去初始化一个类型已知的变量时，又或是把字面值作为实参传给函数时</strong> ，会发生隐式转换，并且算数运算符会被重载。<br>例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">long</span><span class="params">(l: <span class="type">Long</span>)</span></span> = println(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// Int -&gt; Byte</span></div><div class="line">  <span class="keyword">val</span> l = b + <span class="number">1</span>L</div><div class="line">  foo(<span class="number">234</span>) <span class="comment">// Int 隐式转换 为 Long</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-通用类型系统-any-any"><a href="#1-3-通用类型系统-——-Any-Any" class="headerlink" title="1.3 通用类型系统 —— Any, Any?"></a>1.3 通用类型系统 —— Any, Any?</h3><p>和 <code>Object</code> 作为 Java 类层级结构的顶层类似，<code>Any</code> 类型是 Kotlin <strong>所有非空类型</strong> 的超类（ex: String, Int)。</p>
<center><img src="top-1.png" alt="Kotlin types"></center>

<p>与 Java 不同的是： Kotlin 不区分「原始类型」（primitive type）和其它的类型。它们都是同一类型层级结构的一部分。</p>
<p>如果定义了一个没有指定父类型的类型，则该类型将是 <code>Any</code> 的直接子类型:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>(<span class="keyword">val</span> ripeness: <span class="built_in">Double</span>)</div></pre></td></tr></table></figure></p>
<center><img src="top-2.png" alt="Kotlin types"></center>  

<p>如果你为定义的类型指定了父类型，则该父类型将是新类型的直接父类型，并且新类型的最终祖先为 <code>Any</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>(<span class="keyword">val</span> ripeness: <span class="built_in">Double</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span></span>(ripeness: <span class="built_in">Double</span>, <span class="keyword">val</span> bendiness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peach</span></span>(ripeness: <span class="built_in">Double</span>, <span class="keyword">val</span> fuzziness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness)</div></pre></td></tr></table></figure>
<center><img src="top-3.png" alt="Kotlin types"></center>  

<p>如果你的类型实现了多个接口，那么它将具有多个直接的父类型，而 <code>Any</code> 同样是最终的祖先。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICanGoInASalad</span></span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICanBeSunDried</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tomato</span></span>(ripeness: <span class="built_in">Double</span>):</div><div class="line">    Fruit(ripeness),</div><div class="line">    ICanGoInASalad,</div><div class="line">    ICanBeSunDried</div></pre></td></tr></table></figure>
<center><img src="top-4.png" alt="Kotlin types"></center>

<p>Kotlin 的类型检查器实施父类型/子类型关系。</p>
<p>例如你可以将子类型值存储到父类型变量中：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f: Fruit = Banana(bendiness=<span class="number">0.5</span>)</div><div class="line">f = Peach(fuzziness=<span class="number">0.8</span>)</div></pre></td></tr></table></figure></p>
<p>但是你不能将父类型值存储到子类型变量中：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b = Banana(bendiness=<span class="number">0.5</span>)</div><div class="line"><span class="keyword">val</span> f: Fruit = b</div><div class="line"><span class="keyword">val</span> b2: Banana = f</div><div class="line"><span class="comment">// Error: Type mismatch: inferred type is Fruit but Banana was expected</span></div></pre></td></tr></table></figure></p>
<p>另外，Kotlin 把 Java 方法参数和返回类型中用到的 <code>Object</code> 类型看作 <code>Any</code>(更确切地是当做「平台类型」)。当 Kotlin 函数函数中使用 <code>Any</code> 时，它会被编译成 Java 字节码中的 <code>Object</code>。</p>
<blockquote>
<p>Hint: 平台类型本质上就是 Kotlin 不知道可控性信息的类型。</p>
</blockquote>
<p>上面提到：在 Kotlin 中， <strong><code>Any</code> 是所有 非空类型 的超类</strong>。<br>你可能会有疑问： <code>null</code> 类型的父类是什么呢？</p>
<h3 id="14-可空类型nullable-types-intboolean-及其他"><a href="#1-4-可空类型-Nullable-Types-——-Int？-Boolean？-及其他" class="headerlink" title="1.4 可空类型(Nullable Types) —— Int？,Boolean？ 及其他"></a>1.4 可空类型(Nullable Types) —— Int？,Boolean？ 及其他</h3><p>与 Java 不同，Kotlin 区分非空（non-null）和可空（nullable）类型。到目前为止，我们看到的类型都是非空类型，Kotlin 不允许 null 作为这些类型的值。访问非空类型的变量将永远不会抛出空指针异常。</p>
<p>由于 <code>null</code> 只能被存储在 Java 的引用类型的变量中，所以在 Kotlin 中基本数据的可空版本都会使用该类型的包装形式。</p>
<p>同样的，如果你用基本数据类型作为泛型类的类型参数，Kotlin 同样会使用该类型的包装形式。</p>
<p>我们可以在任何类型后面加上<code>？</code>，比如<code>Int?</code>，实际上等同于<code>Int? = Int or null</code>，通过合理的使用，我们能够简化很多判空代码。并且我们能够有效规避 <code>NullPointerException</code>导致的崩溃。基于可空类型，Kotlin 才拥有很多促使安全的运算符：</p>
<h4 id="安全调用"><a href="#——-安全调用" class="headerlink" title="?. —— 安全调用"></a>?. —— 安全调用</h4><p><code>?.</code>允许我们把一次 <code>null</code> 检查和一次方法的调用合并成一个操作，比如：</p>
<p><code>str?.toUpperCase()</code> 等同于 <code>if (str != null) str.toUpperCase() else null</code></p>
<p>当然，<code>?.</code> 同样可以处理属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String, <span class="keyword">val</span> master: User?)</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">masterInfo</span><span class="params">(user: <span class="type">User</span>)</span></span>: String? = user.master?.nickname</div><div class="line"></div><div class="line"><span class="comment">// test</span></div><div class="line"><span class="keyword">val</span> ceo = User(<span class="string">"boss"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">val</span> employee = User(<span class="string">"employee-1"</span>, ceo)</div><div class="line">println(masterInfo(employee)) <span class="comment">// boss</span></div><div class="line">println(masterInfo(ceo)) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<h4 id="elvis-运算符"><a href="#——-Elvis-运算符" class="headerlink" title="?: —— Elvis 运算符"></a>?: —— Elvis 运算符</h4><p>刚开始我也不知道为什么称之为「Elvis 」运算符——直到我看到了这张图…</p>
<p><img src="elvis.png" alt="elvis"></p>
<p>如果你不喜欢这个名字，我们也可以叫它——「null 合并运算符」。如果你学习过 Scala，这类似于 <code>getOrElse</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun getOrElse(str: String?) &#123;</div><div class="line">  val result: String = str ?: &quot;&quot; // 等价于 str == null ? &quot;&quot; : str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外还有<code>as?</code>（安全转换）、<code>!!</code>（非空断言）、<code>let</code>、<code>lateinit</code>（延迟初始化属性）等此处就不详细介绍。</p>
<h3 id="15-unit-kotlin-里的-void"><a href="#1-5-Unit-——-Kotlin-里的-void" class="headerlink" title="1.5 Unit —— Kotlin 里的 void"></a>1.5 Unit —— Kotlin 里的 void</h3><p>Kotlin 是一种表达式导向的语言，所有流程控制语句都是表达式。它没有 Java 和 C 中的 <code>void</code> 函数，函数总是会返回一个值。有时候函数并没有计算任何东西 —— 这被我们称作他们的副作用（side effect），这时将会返回 <code>Unit</code>——具有单一值的类型。</p>
<p>大多数情况下，你不需要明确指定 <code>Unit</code> 作为返回类型或从函数返回<code>Unit</code>。如果编写的函数具有块代码体，并且不指定返回类型，则编译器会将其视为返回 <code>Unit</code> 类型，否则编译器会使用推断的类型。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"block body and no explicit return type, so returns Unit"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> u: <span class="built_in">Unit</span> = example()</div></pre></td></tr></table></figure></p>
<p><code>Unit</code> 并没什么特别之处。就像任何其他类型一样，它是 <code>Any</code> 的子类型，而 <code>Unit?</code> 是 <code>Any?</code> 的子类型。</p>
<center><img src="unit-1.png" alt="Kotlin types"></center>

<p>然而 <code>Unit?</code> 类型却是一个奇怪的特殊例子，这是 Kotlin 的类型系统一致性的结果。<code>Unit?</code> 类型只有两个值：<code>Unit</code> 单例和 <code>null</code>。我从来没有发现需要明确使用 <code>Unit?</code> 类型的地方，但是在类型系统中没有特殊的 void 这一事实，使得处理各种函数泛型变得更加容易。  </p>
<h3 id="16-nothing"><a href="#1-6-Nothing" class="headerlink" title="1.6 Nothing"></a>1.6 Nothing</h3><p>在 Kotlin 类型层级结构的最底层是 <code>Nothing</code> 类型。  </p>
<center><img src="nothing-1.png" alt="Kotlin types"></center>  

<p>顾名思义，<code>Nothing</code> 是没有实例的类型。<code>Nothing</code> 类型的表达式不会产生任何值。</p>
<p>注意 <code>Unit</code> 和 <code>Nothing</code> 之间的区别，对 <code>Unit</code> 类型的表达式求值将返回 <code>Unit</code> 的单例，而对 <code>Nothing</code> 类型的表达式求值则永远都不会返回。</p>
<p>这意味着任何类型为 <code>Nothing</code> 的表达式之后的所有代码都是无法得到执行的（unreachable code），编译器和 IDE 会向你发出警告。</p>
<p>什么样的表达式类型为 <code>Nothing</code> 呢？<a href="https://kotlinlang.org/docs/reference/grammar.html#jump" target="_blank" rel="external">流程控制中与跳转相关的表达式。</a></p>
<p>例如 <code>throw</code> 关键字会中断表达式的计算，并从函数中抛出异常。因此 <code>throw</code> 就是 <code>Nothing</code> 类型的表达式。</p>
<p>通过将 <code>Nothing</code> 作为所有类型的子类型，类型系统允许程序中的任何表达求值失败。这是真实世界的模型，例如 JVM 在计算表达式时内存不足，或者是有人拔掉了计算机的电源插头。这也意味着我们可以从任何表达式中抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">formatCell</span><span class="params">(value: <span class="type">Double</span>)</span></span>: String =</div><div class="line">    <span class="keyword">if</span> (value.isNaN())</div><div class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="subst">$value</span> is not a number"</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        value.toString()</div></pre></td></tr></table></figure>
<p>你可能会惊奇地发现，<code>return</code> 语句的类型也为 <code>Nothing</code>。<code>return</code> 是一个流程控制语句，它立即从函数中返回一个值，打断其所在表达式的求值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">formatCellRounded</span><span class="params">(value: <span class="type">Double</span>)</span></span>: String =</div><div class="line">    <span class="keyword">val</span> rounded: <span class="built_in">Long</span> = <span class="keyword">if</span> (value.isNaN()) <span class="keyword">return</span> <span class="string">"#ERROR"</span> <span class="keyword">else</span> Math.round(value)</div><div class="line">    rounded.toString()</div></pre></td></tr></table></figure>
<p>进入无限循环或杀死当前进程的函数返回类型也为 Nothing。例如 Kotlin 标准库将 <code>exitProcess</code> 函数声明为：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exitProcess</span><span class="params">(status: <span class="type">Int</span>)</span></span>: <span class="built_in">Nothing</span></div></pre></td></tr></table></figure></p>
<p>如果你编写返回 <code>Nothing</code> 的自定义函数，编译器同样能检查出调用函数后无法得到执行的代码，就像使用语言本身的流程控制语句一样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">forever</span><span class="params">(action: ()</span></span>-&gt;<span class="built_in">Unit</span>): <span class="built_in">Nothing</span> &#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) action()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">()</span></span> &#123;</div><div class="line">    forever &#123;</div><div class="line">        println(<span class="string">"doing..."</span>)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"done"</span>) <span class="comment">// Warning: Unreachable code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与空安全一样，不可达代码分析是类型系统的一个特性。无需像 Java 一样在编译器和 IDE 中使用一些手段进行特殊处理。</p>
<h3 id="17-可空的-nothing"><a href="#1-7-可空的-Nothing" class="headerlink" title="1.7 可空的 Nothing?"></a>1.7 可空的 Nothing?</h3><p><code>Nothing</code> 像任何其他类型一样，如果允许其为空则可以得到对应的类型 <code>Nothing?</code>。<code>Nothing?</code> 只能包含一个值：<code>null</code>。事实上 <code>Nothing?</code> 就是 <code>null</code> 的类型。</p>
<p><code>Nothing?</code> 是所有可空类型的最终子类型，所以我们可以使用 null 作为任何可空类型的值。</p>
<center><img src="nullable-nothing.png" alt="Kotlin types"></center>  





<hr>
<p>参考：</p>
<ul>
<li><a href="http://natpryce.com/articles/000818.html" target="_blank" rel="external">A Whirlwind Tour of the Kotlin Type Hierarchy</a></li>
<li><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="external"> 《Kotlin in Action》</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/20/scala-design-patterns-5-adapter/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'prefer-tyl-site';
var disqus_identifier = '2017/11/30/kotlin-2/';
var disqus_title = 'kotlin 类型结构设计';
var disqus_url = 'http://prefer-tyl.site/2017/11/30/kotlin-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//prefer-tyl-site.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://prefer-tyl.site">Prefert</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
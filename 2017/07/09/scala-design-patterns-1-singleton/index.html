<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Scala 与设计模式（一）：Singleton 单例模式 · Prefert</title><meta name="description" content="Scala 与设计模式（一）：Singleton 单例模式 - Prefert"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avator.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://prefer-tyl.site/atom.xml" title="Prefert"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avator.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/YarenTang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Scala 与设计模式（一）：Singleton 单例模式</h1><div class="post-info">Jul 9, 2017</div><div class="post-content"><p>单例模式（<code>Singleton Pattern</code>）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#why-singleton">Why Singleton</a></li>
<li><a href="#结构图">结构图</a></li>
<li><a href="#java-实现">Java 实现</a><ul>
<li><a href="#饿汉-基础版">饿汉 —— 基础版</a></li>
<li><a href="#饿汉-静态内部类版">饿汉 —— 静态内部类版</a></li>
<li><a href="#懒汉-基础版">懒汉 —— 基础版</a></li>
<li><a href="#懒汉-双重检查锁版double-checked-locking">懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</a></li>
<li><a href="#枚举类模式">枚举类模式</a></li>
</ul>
</li>
<li><a href="#scala-实现">Scala 实现</a><ul>
<li><a href="#obeject"><code>obeject</code></a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。  </p>
</blockquote>
<p>通俗一点说就是：保证一个类只有一个实例。</p>
<h2 id="why-singleton"><a href="#Why-Singleton" class="headerlink" title="Why Singleton"></a>Why Singleton</h2><p>什么时候需要使用单例模式呢？ 如果某个类，创建时需要消耗很多资源，即创建出这个类的代价很大时我们就需要使用单例模式。通俗的讲，我们可以将单例对象比作地球，因为很难创建出第二颗这样的星球，这时我们就需要共用地球。</p>
<p>在编写程序的时候，很多操作都会占用大量的资源，如：日志类、配置类、共享资源类等等，我们倡导节能减排，高效利用资源。所以，对于这些操作我们需要一个全局的可访问接口的实现（也可能是懒加载）。</p>
<p>但是我们如何才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但是它并不可以防止我们实例化多个对象。一个更有效的方法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求),并且它可以提供一个访问该实例的方法。这就是单例模式。  </p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://om6vvgjw7.bkt.clouddn.com/Singleton-dp.PNG" alt="singleton"></p>
<h2 id="java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>单例模式应该是 Java 中最出名的设计模式，虽然 Java 语言中包含了静态关键词，但是静态成员与任何对象都不存在直接联系，并且静态成员类不能实现接口。因此，静态方法的概念违背了 <a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">OOP</a> 的前提：所有东西都是对象。  </p>
<p>在 Java 中单例模式有多种形式：<strong>饿汉模式</strong>、<strong>懒汉模式</strong>、<strong>枚举类</strong> 等。</p>
<h4 id="饿汉-基础版"><a href="#饿汉-——-基础版" class="headerlink" title="饿汉 —— 基础版"></a>饿汉 —— 基础版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingletonOne</span> </span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingletonOne instance = <span class="keyword">new</span> HungrySingletonOne();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingletonOne</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"HungrySingletonOne is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HungrySingletonOne.getInstance().run();</div></pre></td></tr></table></figure>
<p>这种饿汉模式有一个缺点: 不是懒加载(lazy initialization)，即单例会在加载类后一开始就被初始化。并且这种模式并没有提供一个设置其他参数的方法入口，适用范围不够广。</p>
<h4 id="饿汉-静态内部类版"><a href="#饿汉-——-静态内部类版" class="headerlink" title="饿汉 —— 静态内部类版"></a>饿汉 —— 静态内部类版</h4><p>为了解决基础版饿汉中的问题，我们可以将代码改进为下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingletonTwo</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明为 final 能防止其在派生类中被 clone</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Countdown;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingletonTwo instance = <span class="keyword">new</span> HungrySingletonTwo(<span class="number">60</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Countdown;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123;</div><div class="line">        Countdown = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingletonTwo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        Countdown = x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HungrySingletonTwo.getInstance().run();</div></pre></td></tr></table></figure></p>
<p>上面的代码中，我们将单例类设置为 <code>final</code> 类型，这样能够禁止克隆的发生；除此之外，我们可以添加带参数的构造函数，提高单例类的扩展性。</p>
<h4 id="懒汉-基础版"><a href="#懒汉-——-基础版" class="headerlink" title="懒汉 —— 基础版"></a>懒汉 —— 基础版</h4><p>相信很多初学者在最开始实现单例的时候，都曾写出过如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonOne</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonOne instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonOne</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println((<span class="string">"LazySingletonOne is running"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingletonOne();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">LazySingletonOne.getInstance().run();</div></pre></td></tr></table></figure></p>
<p>这是一段懒汉模式的代码，它有一个致命的缺点：在多线程环境下会出现创建出多个实例的情况。由于在 <code>getInstance</code> 整个方法外加同步锁（<code>synchronized</code>）会造成很大的性能开销。我们就只能在方法的临界区做一些文章，<code>Double-checked locking</code> 应声而至。</p>
<h4 id="懒汉-双重检查锁版double-checked-locking"><a href="#懒汉-——-双重检查锁版-Double-checked-locking" class="headerlink" title="懒汉 —— 双重检查锁版(Double-checked locking)"></a>懒汉 —— 双重检查锁版(<code>Double-checked locking</code>)</h4><p>直接看代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">// 第一次检查</span></div><div class="line">          <span class="keyword">synchronized</span> (LazySingletonTwo.class) &#123;</div><div class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">// 第二次检查</span></div><div class="line">                  instance = <span class="keyword">new</span> LazySingletonTwo();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance ;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>为了避开多次同步锁的开销，我们先判断单例实体是否存在再进行同步锁操作。这样虽然已经能应对大部分的问题，但是依然存在一个问题：其他线程可能会 <code>read</code> 初始化到一半的 <code>instance</code>。只有将 <code>instance</code> 设置为 <code>volatile</code> ，才能保证每次的 <code>write</code> 操作优先于 <code>read</code> 操作。可以将代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// private static LazySingletonOne instance;           ----old</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingletonOne instance;  ----<span class="keyword">new</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong> ：我们至少要创建一个 <code>private</code> 构造器，否则编译器默认将为我们生成一个 <code>friendly</code> 的构造器，而非 <code>private</code>；其次，<code>instance</code> 成员变量和 <code>getInstance()</code> 方法必须是 <code>static</code> 的；如果单例类实现了 <code>java.io.Serializable</code> 接口，就可能被反序列化，从而产生新的实例。</p>
<h4 id="枚举类模式"><a href="#枚举类模式" class="headerlink" title="枚举类模式"></a>枚举类模式</h4><p>当然我们还可以使用 Java 中的枚举类实现单例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] preference =</div><div class="line">            &#123; <span class="string">"intresting"</span>,<span class="string">"nice"</span>,<span class="string">"just so so"</span> &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Arrays.toString(preference));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 《Effictive Java》 中所推荐的单例模式在 Java 中的最佳实现方式，同时也是 Stack Overflow 中 <a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="external">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a> 最高票回答。</p>
<p>注意：<code>Enum</code> 与 <code>enum</code> 是不同的。后者只是 Java 1.5 后增加的一个语法糖，不是新的类型。 我们可以反编译 <code>EnumSingleton.class</code> 查看一下内部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ javap EnumSingleton.class</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Singleton</span>.<span class="title">Java</span>.<span class="title">EnumSingleton</span>&gt;</span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton.Java.EnumSingleton INSTANCE;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.EnumSingleton[]values();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton.Java.<span class="function">EnumSingleton <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPreference</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">static</span> &#123;&#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>简单总结一下，选用 <code>enum</code> 原因如下：</p>
<ul>
<li><code>enum</code> 防止反序列化重新创建新的对象。</li>
<li>类的修饰 <code>abstract</code>，所以没法实例化，反射也无能为力。</li>
<li>关于线程安全的保证，其实是通过类加载机制来保证的，我们看看 <code>INSTANCE</code> 的实例化时机，是在 <code>static</code> 块中，JVM加载类的过程显然是线程安全的。</li>
</ul>
<h2 id="scala-实现"><a href="#Scala-实现" class="headerlink" title="Scala 实现"></a>Scala 实现</h2><p>在 Scala 中并没有 <code>static</code> 关键字，你不用纠结太多，我们用 <code>object</code> 便能实现单例，再也不用为你的选择困难症烦恼！</p>
<h4 id="obeject"><a href="#obeject" class="headerlink" title="obeject"></a><code>obeject</code></h4><p><code>object</code> 在 Scala 中被称作 “伴生对象” (<code>companion object</code>)。因其可与类同名存在而得名，我们可以在 <code>object</code> 中写一些常量或者工具函数等，比较典型的一点是 Scala 类的 <code>apply</code> 函数也写于 <code>obejct</code> 中（将在本系列工厂模式中详细提到，敬请期待）。看到 <code>object</code> 的介绍，大家就应该能从它身上闻到强烈的单例味。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singleton2Scala</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(l: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = l.sum</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="type">Singleton2Scala</span>.sum(<span class="type">List</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来是不是比 Java 优雅多了！  </p>
<p>你问有没有多线程问题？是否是惰性初始化？这些都不用你来处理。</p>
<p>Scala 被编译后生成 <code>&#39;Singleton2Scala$.class&#39;</code> 和  <code>Singleton2Scala.class</code>，我们可以对其进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ javap  &apos;Singleton2Scala$.class&apos;</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala$ &#123;</div><div class="line">  public static Singleton.Scala.Singleton2Scala$ MODULE$;</div><div class="line">  public static &#123;&#125;;</div><div class="line">  public int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">$ javap  Singleton2Scala.class</div><div class="line">Compiled from &quot;Singleton2Scala.scala&quot;</div><div class="line"></div><div class="line">public final class Singleton.Scala.Singleton2Scala &#123;</div><div class="line">  public static int sum(scala.collection.immutable.List&lt;java.lang.Object&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上方代码我们能看到，所有的方法前都带上了 <code>static</code> 关键字。</p>
<p>在实际项目开发的时候，我们还可以继承其他 类 与 特质。举个例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">xxClass</span> <span class="keyword">with</span> <span class="title">xxtrait</span></span>&#123;</div><div class="line">  println(<span class="string">"Registry initialization block called."</span>)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> users: scala.collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>] =  scala.collection.mutable.<span class="type">HashMap</span>.empty</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addUser</span></span>(id: <span class="type">String</span>, name: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.put(id, name) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>(id: <span class="type">String</span>): <span class="type">Unit</span> = &#123; users.remove(id) &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUserRegistered</span></span>(id: <span class="type">String</span>): <span class="type">Boolean</span> = users.contains(id)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAllUserNames</span></span>(): <span class="type">List</span>[<span class="type">String</span>] = users.map(_._2).toList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比 <code>static class</code> 更易于理解  </li>
<li>语法简洁</li>
<li>按需初始化(<code>lazy initialization</code>)</li>
<li>线程安全(Scala 中不用考虑 <code>double-checked locking</code>)  </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>缺乏对初始化行为的控制  </li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人们对单例模式的看法褒贬不一，甚至被称为是 <code>anti-pattern</code> (反面模式）。如果你是一名 Java 开发者，可能 Spring 框架中 <code>Dependency Injection</code> 是你的更优先的选择。但是单例模式你不能否认的是单例模式在 Android SDK 中得到了广泛的应用。在 Scala 中，伴生对象出现的频率更是非常之高。当你面对的业务场景需要用到单例模式的时候，请注意 多线程 与开销的问题。</p>
<p><a href="https://github.com/YarenTang/Design_Patterns_Examples" target="_blank" rel="external">源码链接</a><br>如有说错的地方，还请指出，不胜感激。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/27/front-page-modular-history/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'prefer-tyl-site';
var disqus_identifier = '2017/07/09/scala-design-patterns-1-singleton/';
var disqus_title = 'Scala 与设计模式（一）：Singleton 单例模式';
var disqus_url = 'http://prefer-tyl.site/2017/07/09/scala-design-patterns-1-singleton/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//prefer-tyl-site.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://prefer-tyl.site">Prefert</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · Prefert</title><meta name="description" content=" - Prefert"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://prefer-tyl.site/atom.xml" title="Prefert"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/YarenTang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Jun 26, 2017</div><div class="post-content"><h2 id="前端模块化的演变"><a href="#前端模块化的演变" class="headerlink" title="  前端模块化的演变  "></a><center> <h1 id="前端模块化的演变"> 前端模块化的演变</h1>  </center></h2><h2 id="title-前端模块化的历史"><a href="#title-前端模块化的历史" class="headerlink" title="title: 前端模块化的历史"></a>title: 前端模块化的历史</h2><p>[TOC]  </p>
<h2 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1. 什么是模块化"></a>1. 什么是模块化</h2><p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
<h2 id="2-为什么要模块化"><a href="#2-为什么要模块化" class="headerlink" title="2. 为什么要模块化"></a>2. 为什么要模块化</h2><p>随着互联网的飞速发展，新的前端框架与技术不断涌现。这些框架在带给开发者便利的同时，也带去了维护困难的隐患————项目逻辑的复杂化与代码库膨胀。我们可以概括为以下三点：  </p>
<ul>
<li>Web 网站正在转变为 Web 应用  </li>
<li>网站规模越大，代码也越来越复杂  </li>
<li>高度解耦的 JS 文件被大家所需求<br>前端开发领域(<code>JavaScript</code>、<code>CSS</code>、<code>Template</code>)并没有为开发者们提供以一种简洁、有条理地的方式来管理模块的方法。为了解决以上问题，我们必须进行合理的模块化管理。  </li>
</ul>
<p>熟悉 Java 语言的同学都知道，在 Java 中有一个重要的概念————package，我们会将相同逻辑的代码放到一个package(包)下，在需要的地方import(引入)即可。<br>    前端是否有类似package的概念呢？<br>    <code>CommonJS</code>(规划并标准化、致力于设计 JavaScript API)的诞生开启了 “JavaScript 模块化” 的时代。<code>CommonJS</code> 的模块提案为在服务器端的 JavaScript 模块化做出了很大的贡献，但是在浏览器下的 JavaScript 模块应用很有限。随之而来又诞生了其它前端领域的模块化方案，像 requireJS、SeaJS 等，然而这些模块化方案并不是十分适用 ，并没有从根本上解决模块化的问题。  </p>
<h2 id="3-web-前端的模块化如何发展"><a href="#3-Web-前端的模块化如何发展" class="headerlink" title="3. Web 前端的模块化如何发展"></a>3. Web 前端的模块化如何发展</h2><h3 id="31-发展历史"><a href="#3-1-发展历史" class="headerlink" title="3.1 发展历史"></a>3.1 发展历史</h3><p>由于JavaScript这门语言设计用时非常短，所以很多方面都没有考虑周全。好在它的生态圈非常强大，广大开发者为了更好的使用它，对它不断优化。</p>
<h3 id="311-函数封装"><a href="#3-1-1-函数封装" class="headerlink" title="3.1.1 函数封装"></a>3.1.1 函数封装</h3><p>  最早期的时候，我们在一个文件里编写相关函数，像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function fn1()&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn2()&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">需要的时候加载文件并调用相关函数即可。</div><div class="line">缺点：Global被污染，代码中很容易出现命名冲突。</div><div class="line"></div><div class="line">### 3.1.2 对象  </div><div class="line">为了解决上面的问题，我们又将一个个文件划分为一个个对象，这样在加载的时候就不用加载很多文件。代码如下：</div></pre></td></tr></table></figure></p>
<p> var MYAPP = {<br>   foo: function(){},<br>   bar: function(){}<br> }</p>
<p> MYAPP.foo(); //需要时执行<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样虽然能减少Global上的变量数目，避免变量污染。但是本质是对象，外部对象可以对其他对象进行修改，很不安全。  </div><div class="line"></div><div class="line">### 3.1.3 立即执行函数(immediately-invoked function expression )    </div><div class="line"> &gt; IIFE (立即调用函数表达式) 是一个 JavaScript 函数 ，它会在定义时立即执行.</div><div class="line">也有人将IIFE称为匿名闭包.</div><div class="line"></div><div class="line">举个例子：</div></pre></td></tr></table></figure></p>
<p>var Module = (function(){<br>    var _private = “safe now”;<br>    var foo = function(){<br>        console.log(_private)<br>    }</p>
<pre><code>return {
    foo: foo
}
</code></pre><p>})()</p>
<p>Module.foo();<br>Module._private; // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">我们可以调用定义的方法，但是不能调用定义的属性。这样的模式使得变量冲突降到最低，并且能够控制暴露的方法(类似于接口）。这便是现代模块实现的基石！</div><div class="line"></div><div class="line">### 3.1.4 Script Loader</div><div class="line"></div><div class="line">最原始的 JS 加载方法就是在 Html 头文件中通过 Script 标签直接引入，类似下面这样：</div></pre></td></tr></table></figure></p>
<p><script src="http://remote.tld/jquery.js"></script></p>
<p><script src="local/plugin1.jquery.js"></script></p>
<p><script src="local/plugin2.jquery.js"></script></p>
<p><script src="local/init.js"></script></p>
<p><script><br>    initMyPage();<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">初学者可能会有疑问，全都写在一个文件中看着不是挺方便的吗？  </div><div class="line">首先以上列举的可能只是实际项目中的一小部分，其次不要忽视 `&lt;script&gt;` 的一个特点：`并行加载，顺序执行`，这要求开发者需要按照严格的读取顺序，并且很有可能会阻塞阻止文档渲染(`async`新特性在HTML5中才提出)。文件少的时候写起来会很方便，一旦项目变复杂缺点就会暴露无疑： **难以维护，依赖模糊，请求过多** 。  </div><div class="line"></div><div class="line">#### LABjs  </div><div class="line">为了解决依赖模糊，我们迫切需要一个加载器（`Loader`）最先出现在开发者视野中的 `Loader` 应该是 [`LABjs`](https://github.com/getify/LABjs])(2009)（ HTML5 发布才有了 `async` 特性）</div><div class="line"></div><div class="line">&gt; LABjs 的核心是 LAB（Loading and Blocking）：Loading 指异步并行加载，Blocking 是指同步等待执行。  </div><div class="line"></div><div class="line">通过使用 LABjs ,上方代码就可以变成这样：</div></pre></td></tr></table></figure></p>
<p><script src="LAB.js"></script></p>
<p><script><br>  $LAB<br>  .script(“<a href="http://remote.tld/jquery.js&quot;).wait(">http://remote.tld/jquery.js&quot;).wait(</a>)<br>  .script(“/local/plugin1.jquery.js”)<br>  .script(“/local/plugin2.jquery.js”).wait()<br>  .script(“/local/init.js”).wait(function(){<br>      initMyPage();<br>  });<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">其中 `.wait` 表示加载后立即运行。</div><div class="line"></div><div class="line"></div><div class="line">#### CommonJS  </div><div class="line"></div><div class="line">服务器端的 `Node.js` 遵循 [CommonJS规范](http://wiki.commonjs.org/wiki/CommonJS)，该规范的核心思想是允许模块通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或 `module.exports` 来导出需要暴露的接口。</div></pre></td></tr></table></figure></p>
<p>require(“module”);<br>require(“../file.js”);<br>exports.doStuff = function() {};<br>module.exports = someValue;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">优点：  </div><div class="line">- 服务器端模块便于重用  </div><div class="line">- [NPM](https://www.npmjs.com/) 中已经有将近20万个可以使用模块包  </div><div class="line">- 简单并容易使用  </div><div class="line"></div><div class="line">缺点：</div><div class="line">- 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的  </div><div class="line">- 不能非阻塞的并行加载多个模块  </div><div class="line"></div><div class="line">实现:</div><div class="line">- NodeJS</div><div class="line"></div><div class="line">#### 双塔奇兵 AMD/CMD  </div><div class="line"></div><div class="line">Commonjs用在服务器端，加载是同步的</div><div class="line">AMD, CMD用在浏览器端，加载是异步的  </div><div class="line"></div><div class="line">|       -        | AMD          | CMD  |  </div><div class="line">| ------------- |:-------------|:-----:|</div><div class="line">| 概念      | [Asynchronous Module Definition](https://github.com/amdjs/amdjs-api) 规范其实只有一个主要接口 `define(id?, dependencies?, factory)`，它要在声明模块的时候指定所有的依赖 `dependencies`，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。| [Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md) 规范和 AMD 很相似，尽量保持简单，并与 `CommonJS` 和 `Node.js` 的 `Modules 规范` 保持了很大的兼容性。 |</div><div class="line">| 优点      | 1. 适合在浏览器环境中异步加载模块&lt;/br&gt; 2. 可以并行加载多个模块      |   1. 依赖就近，延迟执行 &lt;/br&gt; 2. 可以很容易在 Node.js 中运行 |</div><div class="line">| 缺点      | 1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅&lt;/br&gt; 2. 不符合通用的模块化思维方式，是一种妥协的实现      |   依赖 SPM 打包，模块的加载逻辑偏重 |</div><div class="line">| 实现      |     [RequireJS](http://requirejs.org/)          |  [SeaJS](http://seajs.org/)     |</div><div class="line"></div><div class="line"></div><div class="line">两者最明显的区别可以从以下代码中查看：</div></pre></td></tr></table></figure></p>
<p>//AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>define([‘a’, ‘b’], function(a, b){<br>    a.doSomething();    // 依赖前置，提前执行<br>    b.doSomething();<br>})</p>
<p>//CMD 推崇依赖就近，只有在用到某个模块的时候再去require<br>define(function(require, exports, module){<br>    var a = require(“a”);<br>    a.doSomething();<br>    var b = require(“b”);<br>    b.doSomething();    // 依赖就近，延迟执行<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 3.2 解决方案  </div><div class="line"></div><div class="line">前面已经为大家回顾了 JavaScript 的模块化发展历史，然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。如果他们都可以视作模块，并且都可以通过 `require` 的方式来加载，将带来优雅的开发体验，比如：</div></pre></td></tr></table></figure></p>
<p>require(“./style.css”);<br>require(“./style.less”);<br>require(“./template.jade”);<br>require(“./image.png”);<br><code>``
那么如何做到让</code>require` 能加载各种资源呢？  </p>
<h4 id="webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack</a> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。  </p>
</blockquote>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/what-is-webpack.png" alt="webpack">  </p>
<p>Webpack 的优点可以概括为以下6点：  </p>
<ul>
<li><strong>代码拆分</strong><br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。  </li>
<li><strong>Loader</strong><br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。  </li>
<li><strong>智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。  </li>
<li><strong>插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。  </li>
<li><strong>快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。  </li>
</ul>
<p><img src="http://om6vvgjw7.bkt.clouddn.com/%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94.png" alt="webpack与其他工具的对比"></p>
<p>当然，光有 <code>Webpack</code> 是不够的，目前大家比较推崇的最佳拍档为：</p>
<table>
<thead>
<tr>
<th>包管理工具</th>
<th style="text-align:center">模块化构建工具</th>
<th style="text-align:center">模块化规范</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm</td>
<td style="text-align:center">Webpack</td>
<td style="text-align:center">ES6模块</td>
</tr>
</tbody>
</table>
<p>当然，目前比较有许多 “自带模块化buff” 的前端框架（采用上述的最佳拍档）：<code>Vue</code> 、 <code>React</code>等，它们都有以下特点：</p>
<ul>
<li>使用 Virtual DOM</li>
<li>提供了响应式（Reactive）和组件化（Composable）的视图组件。</li>
<li>保持注意力集中在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。</li>
</ul>
<p>在 <code>Vue</code> 中，一个组件文件(<code>.Vue</code>)中，拥有<code>&lt;template&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;style&gt;</code>三个部分，每个组件中管理自己的样式与脚本，开发与维护时都非常方便。  </p>
<h2 id="4-未来的模块化"><a href="#4-未来的模块化" class="headerlink" title="4. 未来的模块化"></a>4. 未来的模块化</h2><p>说到模块化未来的发展，值得一提的便是 <a href="http://webassembly.org/" target="_blank" rel="external"><code>WebAssembly</code></a>。大家都知道 <code>JavaScript</code> 是一种解释性脚本语言，导致其运行时消耗大量的性能做为代价，这也是 <code>JavaScript</code> 的瓶颈之一。<code>WebAssembly</code> 旨在解决这个问题。</p>
<blockquote>
<p>Define a portable, size- and load-time-efficient binary format to serve as a compilation target which can be compiled to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms, including mobile and IoT.<br>定义一个可移植，体积紧凑，加速迅捷的二进制格式为编译目标，而此二进制格式文件将可以在各种平台（包括移动设备和物联网设备）上被编译，然后发挥通用的性能以原生应用的速度运行。</p>
</blockquote>
<p>某乎上广传”谷歌、苹果、谋智、微软一起再一次发明了Silverlight”。可以看出，大家对 <code>WebAssembly</code> 充满了信心与期待。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/30/restructure-web-page/" class="prev">PREV</a></div><div class="copyright"><p>© 2017 <a href="http://prefer-tyl.site">Prefert</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>